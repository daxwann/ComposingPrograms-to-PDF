<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Page Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="../style/cp.css" />
</head>
<body><div class="inner-content">
	<p>Welcome to <a href="http://www.composingprograms.com">Composing Programs</a>, a free online introduction to programming and computer science.

	</p>
<p>In the tradition of <a href="http://mitpress.mit.edu/sicp/">SICP</a>, this text focuses on methods for abstraction, programming paradigms, and techniques for managing the complexity of large programs.  These concepts are illustrated primarily using the <a href="http://www.python.org">Python 3</a> programming language.

	</p>
<p>In addition to reading the chapters below, you can apply your knowledge to the <a href="projects.html">programming projects</a> that accompany the text and visualize program execution using the <a href="tutor.html">Online Python Tutor</a>.

	</p>
<p><b>Instructors</b>: If you are interested in adapting any of these materials for your courses, please <a href="https://docs.google.com/forms/d/1lcDf-_y9t1oSDH_-HFz3UhUFouAX1518XeCMnlRISss/viewform">fill out this short survey</a> so that we can support your efforts.

			</p>
<h3>Chapter 1: Building Abstractions with Functions</h3>
    <li><a href="./pages/11-getting-started.html">1.1 Getting Started</a></li>
    <li><a href="./pages/12-elements-of-programming.html">1.2 Elements of Programming</a></li>
    <li><a href="./pages/13-defining-new-functions.html">1.3 Defining New Functions</a></li>
    <li><a href="./pages/14-designing-functions.html">1.4 Designing Functions</a></li>
    <li><a href="./pages/15-control.html">1.5 Control</a></li>
    <li><a href="./pages/16-higher-order-functions.html">1.6 Higher-Order Functions</a></li>
    <li><a href="./pages/17-recursive-functions.html">1.7 Recursive Functions</a></li>
			<h3>Chapter 2: Building Abstractions with Data</h3>
    <li><a href="./pages/21-introduction.html">2.1 Introduction</a></li>
    <li><a href="./pages/22-data-abstraction.html">2.2 Data Abstraction</a></li>
    <li><a href="./pages/23-sequences.html">2.3 Sequences</a></li>
    <li><a href="./pages/24-mutable-data.html">2.4 Mutable Data</a></li>
    <li><a href="./pages/25-object-oriented-programming.html">2.5 Object-Oriented Programming</a></li>
    <li><a href="./pages/26-implementing-classes-and-objects.html">2.6 Implementing Classes and Objects</a></li>
    <li><a href="./pages/27-object-abstraction.html">2.7 Object Abstraction</a></li>
    <li><a href="./pages/28-efficiency.html">2.8 Efficiency</a></li>
    <li><a href="./pages/29-recursive-objects.html">2.9 Recursive Objects</a></li>
			<h3>Chapter 3: Interpreting Computer Programs</h3>
    <li><a href="./pages/31-introduction.html">3.1 Introduction</a></li>
    <li><a href="./pages/32-functional-programming.html">3.2 Functional Programming</a></li>
    <li><a href="./pages/33-exceptions.html">3.3 Exceptions</a></li>
    <li><a href="./pages/34-interpreters-for-languages-with-combination.html">3.4 Interpreters for Languages with Combination</a></li>
    <li><a href="./pages/35-interpreters-for-languages-with-abstraction.html">3.5 Interpreters for Languages with Abstraction</a></li>
			<h3>Chapter 4: Data Processing</h3>
    <li><a href="./pages/41-introduction.html">4.1 Introduction</a></li>
    <li><a href="./pages/42-implicit-sequences.html">4.2 Implicit Sequences</a></li>
    <li><a href="./pages/43-declarative-programming.html">4.3 Declarative Programming</a></li>
    <li><a href="./pages/44-logic-programming.html">4.4 Logic Programming</a></li>
    <li><a href="./pages/45-unification.html">4.5 Unification</a></li>
    <li><a href="./pages/46-distributed-computing.html">4.6 Distributed Computing</a></li>
    <li><a href="./pages/47-distributed-data-processing.html">4.7 Distributed Data Processing</a></li>
    <li><a href="./pages/48-parallel-computing.html">4.8 Parallel Computing</a></li>
      </div><div class="inner-content">
	<h1>Chapter 1: Building Abstractions with Functions</h1>
  <div class="section" id="getting-started">
<h2>1.1   Getting Started</h2>
<p>Computer science is a tremendously broad academic discipline. The areas of
globally distributed systems, artificial intelligence, robotics, graphics,
security, scientific computing, computer architecture, and dozens of emerging
sub-fields all expand with new techniques and discoveries every year. The
rapid progress of computer science has left few aspects of human life
unaffected. Commerce, communication, science, art, leisure, and politics have
all been reinvented as computational domains.</p>
<p>The high productivity of computer science is only possible because the
discipline is built upon an elegant and powerful set of fundamental ideas. All
computing begins with representing information, specifying logic to process it,
and designing abstractions that manage the complexity of that logic. Mastering
these fundamentals will require us to understand precisely how computers
interpret computer programs and carry out computational processes.</p>
<p>These fundamental ideas have long been taught using the classic textbook
<em>Structure and Interpretation of Computer Programs</em> (<a class="reference external" href="http://mitpress.mit.edu/sicp">SICP</a>) by Harold Abelson
and Gerald Jay Sussman with Julie Sussman. This text borrows heavily from that
textbook, which the original authors have kindly licensed for adaptation and
reuse under a Creative Commons license. These notes are published under the
<a class="reference external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons attribution non-commericial share-alike license version 3</a>.</p>
<div class="section" id="programming-in-python">
<h3>1.1.1   Programming in Python</h3>
<blockquote class="epigraph">
<p>A language isn't something you learn so much as something you join.</p>
<p class="attribution">—<a class="reference external" href="http://arikaokrent.com/">Arika Okrent</a></p>
</blockquote>
<p>In order to define computational processes, we need a programming language;
preferably one that many humans and a great variety of computers can all
understand.  In this text, we will work primarily with the <a class="reference external" href="http://docs.python.org/py3k/">Python</a> language.</p>
<p>Python is a widely used programming language that has recruited enthusiasts from
many professions: web programmers, game engineers, scientists, academics, and
even designers of new programming languages. When you learn Python, you join a
million-person-strong community of developers. Developer communities are
tremendously important institutions: members help each other solve problems,
share their projects and experiences, and collectively develop software and
tools.  Dedicated members often achieve celebrity and widespread esteem for
their contributions.</p>
<p>The Python language itself is the product of a <a class="reference external" href="http://www.python.org/psf/members/">large volunteer community</a> that prides itself on the <a class="reference external" href="http://python.org/community/diversity/">diversity</a> of its contributors. The language
was conceived and first implemented by <a class="reference external" href="http://en.wikipedia.org/wiki/Guido_van_Rossum">Guido van Rossum</a> in the late 1980's.
The first chapter of his <a class="reference external" href="http://docs.python.org/py3k/tutorial/appetite.html">Python 3 Tutorial</a> explains why Python is so
popular, among the many languages available today.</p>
<p>Python excels as an instructional language because, throughout its history,
Python's developers have emphasized the human interpretability of Python code,
reinforced by the <a class="reference external" href="http://www.python.org/dev/peps/pep-0020/">Zen of Python</a> guiding principles of beauty, simplicity, and
readability. Python is particularly appropriate for this text because its broad
set of features support a variety of different programming styles, which we will
explore. While there is no single way to program in Python, there are a set of
conventions shared across the developer community that facilitate reading,
understanding, and extending existing programs. Python's combination of great
flexibility and accessibility allows students to explore many programming
paradigms, and then apply their newly acquired knowledge to thousands of
<a class="reference external" href="http://pypi.python.org/pypi">ongoing projects</a>.</p>
<p>These notes maintain the spirit of <a class="reference external" href="http://mitpress.mit.edu/sicp">SICP</a> by introducing the features of Python
in step with techniques for abstraction and a rigorous model of computation. In
addition, these notes provide a practical introduction to Python programming,
including some advanced language features and illustrative examples. Increasing
your facility with Python should come naturally as you progress through the
text.</p>
<p>The best way to get started programming in Python is to interact with the
interpreter directly. This section describes how to install Python 3, initiate
an interactive session with the interpreter, and start programming.</p>
</div>
<div class="section" id="installing-python-3">
<h3>1.1.2   Installing Python 3</h3>
<p>As with all great software, Python has many versions. This text will use the
most recent stable version of Python 3. Many computers have older versions of
Python installed already, such as Python 2.7, but those will not match the
descriptions in this text. You should be able to use any computer, but expect to
install Python 3. (Don't worry, Python is free.)</p>
<p>You can download Python 3 from the <cite>Python downloads</cite> page by clicking on the
version that begins with 3 (not 2). Follow the instructions of the installer
to complete installation.</p>
<p>For further guidance, try these video tutorials on <a class="reference external" href="http://www.youtube.com/watch?v=54-wuFsPi0w">Windows installation</a> and
<a class="reference external" href="http://www.youtube.com/watch?v=smHuBHxJdK8">Mac installation</a> of Python 3, created by Julia Oh.</p>
</div>
<div class="section" id="interactive-sessions">
<h3>1.1.3   Interactive Sessions</h3>
<p>In an interactive Python session, you type some Python <em>code</em> after the
<em>prompt</em>, <tt class="docutils literal">&gt;&gt;&gt;</tt>. The Python <em>interpreter</em> reads and executes what you type,
carrying out your various commands.</p>
<p>To start an interactive session, run the Python 3 application. Type <tt class="docutils literal">python3</tt>
at a terminal prompt (Mac/Unix/Linux) or open the Python 3 application in
Windows.</p>
<p>If you see the Python prompt, <tt class="docutils literal">&gt;&gt;&gt;</tt>, then you have successfully started an
interactive session. These notes depict example interactions using the prompt,
followed by some input.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="go">4</span>
</pre></div>

<p><strong>Interactive controls.</strong> Each session keeps a history of what you have typed.
To access that history, press <tt class="docutils literal"><span class="pre">&lt;Control&gt;-P</span></tt> (previous) and <tt class="docutils literal"><span class="pre">&lt;Control&gt;-N</span></tt>
(next).  <tt class="docutils literal"><span class="pre">&lt;Control&gt;-D</span></tt> exits a session, which discards this history. Up and
down arrows also cycle through history on some systems.</p>
</div>
<div class="section" id="first-example">
<h3>1.1.4   First Example</h3>
<blockquote class="epigraph">
<div class="line-block">
<div class="line">And, as imagination bodies forth</div>
<div class="line">The forms of things to unknown, and the poet's pen</div>
<div class="line">Turns them to shapes, and gives to airy nothing</div>
<div class="line">A local habitation and a name.</div>
</div>
<p class="attribution">—William Shakespeare, A Midsummer-Night's Dream</p>
</blockquote>
<p>To give Python a proper introduction, we will begin with an example that uses
several language features.  In the next section, we will start from scratch and
build up the language piece by piece. Think of this section as a sneak preview
of features to come.</p>
<p>Python has built-in support for a wide range of common programming activities,
such as manipulating text, displaying graphics, and communicating over the
Internet.  The line of Python code</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.request</span> <span class="k">import</span> <span class="n">urlopen</span>
</pre></div>

<p>is an <tt class="docutils literal">import</tt> statement that loads functionality for accessing data on the
Internet. In particular, it makes available a function called <tt class="docutils literal">urlopen</tt>, which
can access the content at a uniform resource locator (URL), a location of
something on the Internet.</p>
<p><strong>Statements &amp; Expressions</strong>. Python code consists of expressions and
statements. Broadly, computer programs consist of instructions to either</p>
<ol class="arabic simple">
<li>Compute some value</li>
<li>Carry out some action</li>
</ol>
<p>Statements typically describe actions. When the Python interpreter executes a
statement, it carries out the corresponding action. On the other hand,
expressions typically describe computations. When Python evaluates an
expression, it computes the value of that expression. This chapter introduces
several types of statements and expressions.</p>
<p>The assignment statement</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shakespeare</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="s1">'http://composingprograms.com/shakespeare.txt'</span><span class="p">)</span>
</pre></div>

<p>associates the name <tt class="docutils literal">shakespeare</tt> with the value of the expression that
follows <tt class="docutils literal">=</tt>.  That expression applies the <tt class="docutils literal">urlopen</tt> function to a URL that
contains the complete text of William Shakespeare's 37 plays, all in a single
text document.</p>
<p><strong>Functions</strong>. Functions encapsulate logic that manipulates data. <tt class="docutils literal">urlopen</tt>
is a function.  A web address is a piece of data, and the text of Shakespeare's
plays is another. The process by which the former leads to the latter may be
complex, but we can apply that process using only a simple expression because
that complexity is tucked away within a function. Functions are the primary
topic of this chapter.</p>
<p>Another assignment statement</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">shakespeare</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
</pre></div>

<p>associates the name <tt class="docutils literal">words</tt> to the set of all unique words that appear in
Shakespeare's plays, all 33,721 of them.  The chain of commands to <tt class="docutils literal">read</tt>,
<tt class="docutils literal">decode</tt>, and <tt class="docutils literal">split</tt>, each operate on an intermediate computational entity:
we <tt class="docutils literal">read</tt> the data from the opened URL, then <tt class="docutils literal">decode</tt> the data into text,
and finally <tt class="docutils literal">split</tt> the text into words.  All of those words are placed in a
<tt class="docutils literal">set</tt>.</p>
<p><strong>Objects</strong>. A <tt class="docutils literal">set</tt> is a type of object, one that supports set operations
like computing intersections and membership. An object seamlessly bundles
together data and the logic that manipulates that data, in a way that manages
the complexity of both. Objects are the primary topic of Chapter 2.  Finally,
the expression</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span> <span class="ow">and</span> <span class="n">w</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">words</span><span class="p">}</span>
<span class="go">{'redder', 'drawer', 'reward', 'diaper', 'repaid'}</span>
</pre></div>

<p>is a compound expression that evaluates to the set of all Shakespearian words
that are simultaneously a word spelled in reverse. The cryptic notation
<tt class="docutils literal"><span class="pre">w[::-1]</span></tt> enumerates each letter in a word, but the <tt class="docutils literal"><span class="pre">-1</span></tt> dictates to step
backwards.  When you enter an expression in an interactive session, Python
prints its value on the following line.</p>
<p><strong>Interpreters</strong>. Evaluating compound expressions requires a precise procedure
that interprets code in a predictable way. A program that implements such a
procedure, evaluating compound expressions, is called an interpreter. The
design and implementation of interpreters is the primary topic of Chapter 3.</p>
<p>When compared with other computer programs, interpreters for programming
languages are unique in their generality. Python was not designed with
Shakespeare in mind. However, its great flexibility allowed us to process a
large amount of text with only a few statements and expressions.</p>
<p>In the end, we will find that all of these core concepts are closely related:
functions are objects, objects are functions, and interpreters are instances of
both. However, developing a clear understanding of each of these concepts and
their role in organizing code is critical to mastering the art of programming.</p>
</div>
<div class="section" id="errors">
<h3>1.1.5   Errors</h3>
<p>Python is waiting for your command.  You are encouraged to experiment with the
language, even though you may not yet know its full vocabulary and structure.
However, be prepared for errors.  While computers are tremendously fast and
flexible, they are also extremely rigid. The nature of computers is described in
<a class="reference external" href="http://web.stanford.edu/class/cs101/code-1-introduction.html">Stanford's introductory course</a> as</p>
<blockquote class="epigraph">
<p>The fundamental equation of computers is:</p>
<p><tt class="docutils literal">computer = powerful + stupid</tt></p>
<p>Computers are very powerful, looking at volumes of data very quickly.
Computers can perform billions of operations per second, where each operation
is pretty simple.</p>
<p>Computers are also shockingly stupid and fragile. The operations that they can
do are extremely rigid, simple, and mechanical. The computer lacks anything
like real insight ... it's nothing like the HAL 9000 from the movies. If
nothing else, you should not be intimidated by the computer as if it's some
sort of brain. It's very mechanical underneath it all.</p>
<p>Programming is about a person using their real insight to build something
useful, constructed out of these teeny, simple little operations that the
computer can do.</p>
<p class="attribution">—Francisco Cai and Nick Parlante, Stanford CS101</p>
</blockquote>
<p>The rigidity of computers will immediately become apparent as you experiment
with the Python interpreter: even the smallest spelling and formatting changes
will cause unexpected output and errors.</p>
<p>Learning to interpret errors and diagnose the cause of unexpected errors is
called <em>debugging</em>. Some guiding principles of debugging are:</p>
<ol class="arabic simple">
<li>
<strong>Test incrementally</strong>: Every well-written program is composed of small,
modular components that can be tested individually. Try out everything you
write as soon as possible to identify problems early and gain confidence in
your components.</li>
<li>
<strong>Isolate errors</strong>: An error in the output of a statement can typically be
attributed to a particular modular component.  When trying to diagnose a
problem, trace the error to the smallest fragment of code you can before
trying to correct it.</li>
<li>
<strong>Check your assumptions</strong>: Interpreters do carry out your instructions to
the letter — no more and no less. Their output is unexpected when the
behavior of some code does not match what the programmer believes (or
assumes) that behavior to be. Know your assumptions, then focus your
debugging effort on verifying that your assumptions actually hold.</li>
<li>
<strong>Consult others</strong>: You are not alone!  If you don't understand an error
message, ask a friend, instructor, or search engine. If you have isolated an
error, but can't figure out how to correct it, ask someone else to take a
look. A lot of valuable programming knowledge is shared in the process of
group problem solving.</li>
</ol>
<p>Incremental testing, modular design, precise assumptions, and teamwork are
themes that persist throughout this text. Hopefully, they will also persist
throughout your computer science career.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/12-elements-of-programming.html">
  		1.2 Elements of Programming
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="elements-of-programming">
<h2>1.2   Elements of Programming</h2>
<p>A programming language is more than just a means for instructing a computer to
perform tasks. The language also serves as a framework within which we organize
our ideas about computational processes. Programs serve to communicate those
ideas among the members of a programming community. Thus, programs must be
written for people to read, and only incidentally for machines to execute.</p>
<p>When we describe a language, we should pay particular attention to the means
that the language provides for combining simple ideas to form more complex
ideas. Every powerful language has three such mechanisms:</p>
<ul class="simple">
<li>
<strong>primitive expressions and statements</strong>, which represent the simplest
building blocks that the language provides,</li>
<li>
<strong>means of combination</strong>, by which compound elements are built from simpler
ones, and</li>
<li>
<strong>means of abstraction</strong>, by which compound elements can be named and
manipulated as units.</li>
</ul>
<p>In programming, we deal with two kinds of elements: functions and data. (Soon
we will discover that they are really not so distinct.) Informally, data is
stuff that we want to manipulate, and functions describe the rules for
manipulating the data. Thus, any powerful programming language should
be able to describe primitive data and primitive functions, as well as have some
methods for combining and abstracting both functions and data.</p>
<div class="section" id="expressions">
<h3>1.2.1   Expressions</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#avguCdBIHQmI').src &amp;&amp; (document.querySelector('#avguCdBIHQmI').src = 'http://www.youtube.com/embed/vguCdBIHQmI?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#avguCdBIHQmI').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#avguCdBIHQmI').style.cssText = 'display:none'; document.querySelector('#avguCdBIHQmI').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="avguCdBIHQmI" style="display:none;" width="640"></iframe>
</div>
<p>Having experimented with the full Python interpreter in the previous section,
we now start anew, methodically developing the Python language element by
element.  Be patient if the examples seem simplistic — more exciting material
is soon to come.</p>
<p>We begin with primitive expressions. One kind of primitive expression is a
number. More precisely, the expression that you type consists of the numerals
that represent the number in base 10.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">42</span>
<span class="go">42</span>
</pre></div>

<p>Expressions representing numbers may be combined with mathematical operators
to form a compound expression, which the interpreter will evaluate:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="o">-</span><span class="mi">1</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">16</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">32</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">64</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">128</span>
<span class="go">0.9921875</span>
</pre></div>

<p>These mathematical expressions use <em>infix</em> notation, where the <em>operator</em>
(e.g., <tt class="docutils literal">+</tt>, <tt class="docutils literal">-</tt>, <tt class="docutils literal">*</tt>, or <tt class="docutils literal">/</tt>) appears in between the <em>operands</em>
(numbers). Python includes many ways to form compound expressions. Rather than
attempt to enumerate them all immediately, we will introduce new expression
forms as we go, along with the language features that they support.</p>
</div>
<div class="section" id="call-expressions">
<h3>1.2.2   Call Expressions</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#a2SopsFYlGr4').src &amp;&amp; (document.querySelector('#a2SopsFYlGr4').src = 'http://www.youtube.com/embed/2SopsFYlGr4?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#a2SopsFYlGr4').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#a2SopsFYlGr4').style.cssText = 'display:none'; document.querySelector('#a2SopsFYlGr4').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="a2SopsFYlGr4" style="display:none;" width="640"></iframe>
</div>
<p>The most important kind of compound expression is a <em>call expression</em>, which
applies a function to some arguments. Recall from algebra that the mathematical
notion of a function is a mapping from some input arguments to an output value.
For instance, the <tt class="docutils literal">max</tt> function maps its inputs to a single output, which is
the largest of the inputs.  The way in which Python expresses function
application is the same as in conventional mathematics.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="mf">7.5</span><span class="p">,</span> <span class="mf">9.5</span><span class="p">)</span>
<span class="go">9.5</span>
</pre></div>

<p>This call expression has subexpressions: the <em>operator</em> is an expression that
precedes parentheses, which enclose a comma-delimited list of <em>operand</em>
expressions.</p>
<div class="figure">
<img alt="" src="../img/call_expression.png">
</div>
<p>The operator specifies a <em>function</em>.  When this call expression is evaluated,
we say that the function <tt class="docutils literal">max</tt> is <em>called</em> with <em>arguments</em> 7.5 and 9.5, and
<em>returns</em> a <em>value</em> of 9.5.</p>
<p>The order of the arguments in a call expression matters. For instance, the
function <tt class="docutils literal">pow</tt> raises its first argument to the power of its second argument.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">pow</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">10000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">1267650600228229401496703205376</span>
</pre></div>

<p>Function notation has three principal advantages over the mathematical
convention of infix notation. First, functions may take an arbitrary number of
arguments:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>

<p>No ambiguity can arise, because the function name always precedes its
arguments.</p>
<p>Second, function notation extends in a straightforward way to <em>nested</em>
expressions, where the elements are themselves compound expressions. In nested
call expressions, unlike compound infix expressions, the structure of the
nesting is entirely explicit in the parentheses.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="o">-</span><span class="mi">4</span><span class="p">))</span>
<span class="go">-2</span>
</pre></div>

<p>There is no limit (in principle) to the depth of such nesting and to the overall
complexity of the expressions that the Python interpreter can evaluate.
However, humans quickly get confused by multi-level nesting. An important role
for you as a programmer is to structure expressions so that they remain
interpretable by yourself, your programming partners, and other people who may
read your expressions in the future.</p>
<p>Third, mathematical notation has a great variety of forms:  multiplication
appears between terms, exponents appear as superscripts, division as a
horizontal bar, and a square root as a roof with slanted siding. Some of this
notation is very hard to type! However, all of this complexity can be unified
via the notation of call expressions. While Python supports common mathematical
operators using infix notation (like <tt class="docutils literal">+</tt> and <tt class="docutils literal">-</tt>), any operator can be
expressed as a function with a name.</p>
</div>
<div class="section" id="importing-library-functions">
<h3>1.2.3   Importing Library Functions</h3>
<p>Python defines a very large number of functions, including the operator
functions mentioned in the preceding section, but does not make all of their
names available by default. Instead, it organizes the functions and other
quantities that it knows about into modules, which together comprise the Python
Library.  To use these elements, one imports them. For example, the <tt class="docutils literal">math</tt>
module provides a variety of familiar mathematical functions:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span>
<span class="go">16.0</span>
</pre></div>

<p>and the <tt class="docutils literal">operator</tt> module provides access to functions corresponding to infix
operators:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">add</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="go">16</span>
</pre></div>

<p>An <tt class="docutils literal">import</tt> statement designates a module name (e.g., <tt class="docutils literal">operator</tt> or
<tt class="docutils literal">math</tt>), and then lists the named attributes of that module to import (e.g.,
<tt class="docutils literal">sqrt</tt>). Once a function is imported, it can be called multiple times.</p>
<p>There is no difference between using these operator functions (e.g., <tt class="docutils literal">add</tt>)
and the operator symbols themselves (e.g., <tt class="docutils literal">+</tt>). Conventionally, most
programmers use symbols and infix notation to express simple arithmetic.</p>
<p>The <a class="reference external" href="http://docs.python.org/py3k/library/index.html">Python 3 Library Docs</a> list the functions defined by each module, such as
the <a class="reference external" href="http://docs.python.org/py3k/library/math.html">math module</a>. However, this documentation is written for developers who
know the whole language well. For now, you may find that experimenting with a
function tells you more about its behavior than reading the documentation.  As
you become familiar with the Python language and vocabulary, this documentation
will become a valuable reference source.</p>
</div>
<div class="section" id="names-and-the-environment">
<h3>1.2.4   Names and the Environment</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#aJinchX1Vn-I').src &amp;&amp; (document.querySelector('#aJinchX1Vn-I').src = 'http://www.youtube.com/embed/JinchX1Vn-I?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#aJinchX1Vn-I').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#aJinchX1Vn-I').style.cssText = 'display:none'; document.querySelector('#aJinchX1Vn-I').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="aJinchX1Vn-I" style="display:none;" width="640"></iframe>
</div>
<p>A critical aspect of a programming language is the means it provides for using
names to refer to computational objects. If a value has been given a name, we
say that the name <em>binds</em> to the value.</p>
<p>In Python, we can establish new bindings using the assignment statement, which
contains a name to the left of <tt class="docutils literal">=</tt> and a value to the right:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">radius</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">radius</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span>
<span class="go">20</span>
</pre></div>

<p>Names are also bound via <tt class="docutils literal">import</tt> statements.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">*</span> <span class="mi">71</span> <span class="o">/</span> <span class="mi">223</span>
<span class="go">1.0002380197528042</span>
</pre></div>

<p>The <tt class="docutils literal">=</tt> symbol is called the <em>assignment</em> operator in Python (and many other
languages). Assignment is our simplest means of <em>abstraction</em>, for it allows us
to use simple names to refer to the results of compound operations, such as the
<tt class="docutils literal">area</tt> computed above. In this way, complex programs are constructed by
building, step by step, computational objects of increasing complexity.</p>
<p>The possibility of binding names to values and later retrieving those values by
name means that the interpreter must maintain some sort of memory that keeps
track of the names, values, and bindings. This memory is called an
<em>environment</em>.</p>
<p>Names can also be bound to functions.  For instance, the name <tt class="docutils literal">max</tt> is bound
to the max function we have been using. Functions, unlike numbers, are tricky to
render as text, so Python prints an identifying description instead, when asked
to describe a function:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span>
<span class="go">&lt;built-in function max&gt;</span>
</pre></div>

<p>We can use assignment statements to give new names to existing functions.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">max</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">&lt;built-in function max&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>

<p>And successive assignment statements can rebind a name to a new value.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">2</span>
</pre></div>

<p>In Python, names are often called <em>variable names</em> or <em>variables</em> because they
can be bound to different values in the course of executing a program. When a
name is bound to a new value through assignment, it is no longer bound to any
previous value.  One can even bind built-in names to new values.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span>
<span class="go">5</span>
</pre></div>

<p>After assigning <tt class="docutils literal">max</tt> to 5, the name <tt class="docutils literal">max</tt> is no longer bound to a
function, and so attempting to call <tt class="docutils literal">max(2, 3, 4)</tt> will cause an error.</p>
<p>When executing an assignment statement, Python evaluates the expression to the
right of <tt class="docutils literal">=</tt> before changing the binding to the name on the left.  Therefore,
one can refer to a name in right-side expression, even if it is the name to be
bound by the assignment statement.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">3</span>
</pre></div>

<p>We can also assign multiple values to multiple names in a single statement,
where names on the left of <tt class="docutils literal">=</tt> and expressions on the right of <tt class="docutils literal">=</tt> are
separated by commas.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">area</span><span class="p">,</span> <span class="n">circumference</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">area</span>
<span class="go">314.1592653589793</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">circumference</span>
<span class="go">62.83185307179586</span>
</pre></div>

<p>Changing the value of one name does not affect other names. Below, even though
the name <tt class="docutils literal">area</tt> was bound to a value defined originally in terms of
<tt class="docutils literal">radius</tt>, the value of <tt class="docutils literal">area</tt> has not changed.  Updating the value of
<tt class="docutils literal">area</tt> requires another assignment statement.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">radius</span> <span class="o">=</span> <span class="mi">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">area</span>
<span class="go">314.1592653589793</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">area</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span>
<span class="go">380.132711084365</span>
</pre></div>

<p>With multiple assignment, <em>all</em> expressions to the right of <tt class="docutils literal">=</tt> are evaluated
before <em>any</em> names to the left are bound to those values. As a result of this
rule, swapping the values bound to two names can be performed in a single
statement.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">4.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">4.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">3</span>
</pre></div>

</div>
<div class="section" id="evaluating-nested-expressions">
<h3>1.2.5   Evaluating Nested Expressions</h3>
<p>One of our goals in this chapter is to isolate issues about thinking
procedurally. As a case in point, let us consider that, in evaluating nested
call expressions, the interpreter is itself following a procedure.</p>
<p>To evaluate a call expression, Python will do the following:</p>
<ol class="arabic simple">
<li>Evaluate the operator and operand subexpressions, then</li>
<li>Apply the function that is the value of the operator subexpression to the
arguments that are the values of the operand subexpressions.</li>
</ol>
<p>Even this simple procedure illustrates some important points about processes in
general. The first step dictates that in order to accomplish the evaluation
process for a call expression we must first evaluate other expressions. Thus,
the evaluation procedure is <em>recursive</em> in nature; that is, it includes, as one
of its steps, the need to invoke the rule itself.</p>
<p>For example, evaluating</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)),</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">2016</span>
</pre></div>

<p>requires that this evaluation procedure be applied four times. If we draw each
expression that we evaluate, we can visualize the hierarchical structure of this
process.</p>
<div class="figure">
<img alt="" src="../img/expression_tree.png">
</div>
<p>This illustration is called an <em>expression tree</em>.  In computer science, trees
conventionally grow from the top down.  The objects at each point in a tree are
called nodes; in this case, they are expressions paired with their values.</p>
<p>Evaluating its root, the full expression at the top, requires first evaluating
the branches that are its subexpressions.  The leaf expressions (that is, nodes
with no branches stemming from them) represent either functions or numbers. The
interior nodes have two parts: the call expression to which our evaluation rule
is applied, and the result of that expression.  Viewing evaluation in terms of
this tree, we can imagine that the values of the operands percolate upward,
starting from the terminal nodes and then combining at higher and higher
levels.</p>
<p>Next, observe that the repeated application of the first step brings us to the
point where we need to evaluate, not call expressions, but primitive expressions
such as numerals (e.g., 2) and names (e.g., <tt class="docutils literal">add</tt>). We take care of the
primitive cases by stipulating that</p>
<ul class="simple">
<li>A numeral evaluates to the number it names,</li>
<li>A name evaluates to the value associated with that name in the current
environment.</li>
</ul>
<p>Notice the important role of an environment in determining the meaning of the
symbols in expressions. In Python, it is meaningless to speak of the value of an
expression such as</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

<p>without specifying any information about the environment that would provide a
meaning for the name <tt class="docutils literal">x</tt> (or even for the name <tt class="docutils literal">add</tt>). Environments provide
the context in which evaluation takes place, which plays an important role in
our understanding of program execution.</p>
<p>This evaluation procedure does not suffice to evaluate all Python code, only
call expressions, numerals, and names. For instance, it does not handle
assignment statements.  Executing</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>

<p>does not return a value nor evaluate a function on some arguments, since the
purpose of assignment is instead to bind a name to a value.  In general,
statements are not evaluated but <em>executed</em>; they do not produce a value but
instead make some change. Each type of expression or statement has its own
evaluation or execution procedure.</p>
<p>A pedantic note: when we say that "a numeral evaluates to a number," we actually
mean that the Python interpreter evaluates a numeral to a number.  It is the
interpreter which endows meaning to the programming language.  Given that the
interpreter is a fixed program that always behaves consistently, we can say that
numerals (and expressions) themselves evaluate to values in the context of
Python programs.</p>
</div>
<div class="section" id="the-non-pure-print-function">
<h3>1.2.6   The Non-Pure Print Function</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#ajNYc5Gdwo3c').src &amp;&amp; (document.querySelector('#ajNYc5Gdwo3c').src = 'http://www.youtube.com/embed/jNYc5Gdwo3c?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#ajNYc5Gdwo3c').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#ajNYc5Gdwo3c').style.cssText = 'display:none'; document.querySelector('#ajNYc5Gdwo3c').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="ajNYc5Gdwo3c" style="display:none;" width="640"></iframe>
</div>
<p>Throughout this text, we will distinguish between two types of functions.</p>
<p><strong>Pure functions.</strong> Functions have some input (their arguments) and return some
output (the result of applying them).  The built-in function</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>

<p>can be depicted as a small machine that takes input and produces output.</p>
<div class="figure">
<img alt="" src="../img/function_abs.png">
</div>
<p>The function <tt class="docutils literal">abs</tt> is <em>pure</em>. Pure functions have the property that applying
them has no effects beyond returning a value. Moreover, a pure function must
always return the same value when called twice with the same arguments.</p>
<p><strong>Non-pure functions.</strong> In addition to returning a value, applying a non-pure
function can generate <em>side effects</em>, which make some change to the state of the
interpreter or computer. A common side effect is to generate additional output
beyond the return value, using the <tt class="docutils literal">print</tt> function.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">1 2 3</span>
</pre></div>

<p>While <tt class="docutils literal">print</tt> and <tt class="docutils literal">abs</tt> may appear to be similar in these examples, they
work in fundamentally different ways. The value that <tt class="docutils literal">print</tt> returns is
always <tt class="docutils literal">None</tt>, a special Python value that represents nothing. The
interactive Python interpreter does not automatically print the value <tt class="docutils literal">None</tt>.
In the case of <tt class="docutils literal">print</tt>, the function itself is printing output as a side
effect of being called.</p>
<div class="figure">
<img alt="" src="../img/function_print.png">
</div>
<p>A nested expression of calls to <tt class="docutils literal">print</tt> highlights the non-pure character of
the function.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nb">print</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">None None</span>
</pre></div>

<p>If you find this output to be unexpected, draw an expression tree to clarify why
evaluating this expression produces this peculiar output.</p>
<p>Be careful with <tt class="docutils literal">print</tt>!  The fact that it returns <tt class="docutils literal">None</tt> means that it
<em>should not</em> be the expression in an assignment statement.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">two</span> <span class="o">=</span> <span class="nb">print</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">two</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>

<p>Pure functions are restricted in that they cannot have side effects or change
behavior over time. Imposing these restrictions yields substantial benefits.
First, pure functions can be composed more reliably into compound call
expressions.  We can see in the non-pure function example above that <tt class="docutils literal">print</tt>
does not return a useful result when used in an operand expression.  On the
other hand, we have seen that functions such as <tt class="docutils literal">max</tt>, <tt class="docutils literal">pow</tt> and <tt class="docutils literal">sqrt</tt>
can be used effectively in nested expressions.</p>
<p>Second, pure functions tend to be simpler to test. A list of arguments will
always lead to the same return value, which can be compared to the expected
return value. Testing is discussed in more detail later in this chapter.</p>
<p>Third, Chapter 4 will illustrate that pure functions are essential for writing
<em>concurrent</em> programs, in which multiple call expressions may be evaluated
simultaneously.</p>
<p>By contrast, Chapter 2 investigates a range of non-pure functions and describes
their uses.</p>
<p>For these reasons, we concentrate heavily on creating and using pure functions
in the remainder of this chapter.  The <tt class="docutils literal">print</tt> function is only used so that
we can see the intermediate results of computations.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/13-defining-new-functions.html">
  		1.3 Defining New Functions
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="defining-new-functions">
<h2>1.3   Defining New Functions</h2>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#aj3uTRrPBrKk').src &amp;&amp; (document.querySelector('#aj3uTRrPBrKk').src = 'http://www.youtube.com/embed/j3uTRrPBrKk?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#aj3uTRrPBrKk').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#aj3uTRrPBrKk').style.cssText = 'display:none'; document.querySelector('#aj3uTRrPBrKk').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="aj3uTRrPBrKk" style="display:none;" width="640"></iframe>
</div>
<p>We have identified in Python some of the elements that must appear in any
powerful programming language:</p>
<ol class="arabic simple">
<li>Numbers and arithmetic operations are <em>primitive</em> built-in data values and
functions.</li>
<li>Nested function application provides a means of <em>combining</em> operations.</li>
<li>Binding names to values provides a limited means of <em>abstraction</em>.</li>
</ol>
<p>Now we will learn about <em>function definitions</em>, a much more powerful abstraction
technique by which a name can be bound to compound operation, which can then be
referred to as a unit.</p>
<p>We begin by examining how to express the idea of <em>squaring</em>. We might say, "To
square something, multiply it by itself." This is expressed in Python as</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>

<p>which defines a new function that has been given the name <tt class="docutils literal">square</tt>.
This user-defined function is not built into the interpreter. It represents the
compound operation of multiplying something by itself. The <tt class="docutils literal">x</tt> in this
definition is called a <em>formal parameter</em>, which provides a name for the thing
to be multiplied. The definition creates this user-defined function and
associates it with the name <tt class="docutils literal">square</tt>.</p>
<p><strong>How to define a function.</strong> Function definitions consist of a <tt class="docutils literal">def</tt>
statement that indicates a <tt class="docutils literal">&lt;name&gt;</tt> and a comma-separated list of named
<tt class="docutils literal">&lt;formal parameters&gt;</tt>, then a <tt class="docutils literal">return</tt> statement, called the function body,
that specifies the <tt class="docutils literal">&lt;return expression&gt;</tt> of the function, which is an
expression to be evaluated whenever the function is applied:</p>
<pre class="literal-block">
def &lt;name&gt;(&lt;formal parameters&gt;):
    return &lt;return expression&gt;
</pre>
<p>The second line <em>must</em> be indented — most programmers use four spaces to indent.
The return expression is not evaluated right away; it is stored as part of the
newly defined function and evaluated only when the function is eventually
applied.</p>
<p>Having defined <tt class="docutils literal">square</tt>, we can apply it with a call expression:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">441</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">49</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">81</span>
</pre></div>

<p>We can also use <tt class="docutils literal">square</tt> as a building block in defining other functions. For
example, we can easily define a function <tt class="docutils literal">sum_squares</tt> that, given any two
numbers as arguments, returns the sum of their squares:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sum_squares</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">square</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sum_squares</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">25</span>
</pre></div>

<p>User-defined functions are used in exactly the same way as built-in functions.
Indeed, one cannot tell from the definition of <tt class="docutils literal">sum_squares</tt> whether
<tt class="docutils literal">square</tt> is built into the interpreter, imported from a module, or defined by
the user.</p>
<p>Both <tt class="docutils literal">def</tt> statements and assignment statements bind names to values, and any
existing bindings are lost.  For example, <tt class="docutils literal">g</tt> below first refers to a function
of no arguments, then a number, and then a different function of two arguments.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">h</span> <span class="o">+</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>

<div class="section" id="environments">
<h3>1.3.1   Environments</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#agyk0Qutui1s').src &amp;&amp; (document.querySelector('#agyk0Qutui1s').src = 'http://www.youtube.com/embed/gyk0Qutui1s?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#agyk0Qutui1s').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#agyk0Qutui1s').style.cssText = 'display:none'; document.querySelector('#agyk0Qutui1s').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="agyk0Qutui1s" style="display:none;" width="640"></iframe>
</div>
<p>Our subset of Python is now complex enough that the meaning of programs is
non-obvious. What if a formal parameter has the same name as a built-in
function?  Can two functions share names without confusion?  To resolve such
questions, we must describe environments in more detail.</p>
<p>An environment in which an expression is evaluated consists of a sequence of
<em>frames</em>, depicted as boxes. Each frame contains <em>bindings</em>, each of which
associates a name with its corresponding value. There is a single <em>global</em>
frame. Assignment and import statements add entries to the first frame of the
current environment. So far, our environment consists only of the global frame.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_0" style="">
from math import pi
tau = 2 * pi
</div>
<script type="text/javascript">
var example_0_trace = {"code": "from math import pi\ntau = 2 * pi", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"pi": 3.1416}, "heap": {}, "line": 2, "ordered_globals": ["pi"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"pi": 3.1416, "tau": 6.2832}, "heap": {}, "line": 2, "ordered_globals": ["pi", "tau"], "stack_to_render": [], "stdout": ""}]}</script><p>This <em>environment diagram</em> shows the bindings of the current environment, along
with the values to which names are bound. The environment diagrams in this text
are interactive: you can step through the lines of the small program on the
left to see the state of the environment evolve on the right. You can also
click on the "Edit code in Online Python Tutor" link to load the example into
the <a class="reference external" href="http://composingprograms.com/tutor.html">Online Python Tutor</a>, a tool
created by <a class="reference external" href="http://www.pgbovine.net/">Philip Guo</a> for generating these
environment diagrams. You are encouraged to create examples yourself and study
the resulting environment diagrams.</p>
<p>Functions appear in environment diagrams as well. An <tt class="docutils literal">import</tt> statement binds
a name to a built-in function. A <tt class="docutils literal">def</tt> statement binds a name to a
user-defined function created by the definition. The resulting environment
after importing <tt class="docutils literal">mul</tt> and defining <tt class="docutils literal">square</tt> appears below:</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="-1" id="example_1" style="">
from operator import mul
def square(x):
    return mul(x, x)
</div>
<script type="text/javascript">
var example_1_trace = {"code": "from operator import mul\ndef square(x):\n    return mul(x, x)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"mul": ["REF", 1]}, "heap": {"1": ["FUNCTION", "mul(...)", null]}, "line": 2, "ordered_globals": ["mul"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 2, "ordered_globals": ["mul", "square"], "stack_to_render": [], "stdout": ""}]}</script><p>Each function is a line that starts with <tt class="docutils literal">func</tt>, followed by the function
name and formal parameters. Built-in functions such as <tt class="docutils literal">mul</tt> do not have
formal parameter names, and so <tt class="docutils literal">...</tt> is always used instead.</p>
<p>The name of a function is repeated twice, once in the frame and again as part of the function itself.
The name appearing in the function is called the <em>intrinsic name</em>. The name in
a frame is a <em>bound name</em>. There is a difference between the two: different
names may refer to the same function, but that function itself has only one
intrinsic name.</p>
<p>The name bound to a function in a frame is the one used during evaluation. The
intrinsic name of a function does not play a role in evaluation. Step through
the example below using the <em>Forward</em> button to see that once the name <tt class="docutils literal">max</tt>
is bound to the value 3, it can no longer be used as a function.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="2" id="example_2" style="">
f = max
max = 3
result = f(2, 3, 4)
max(1, 2)  # Causes an error
</div>
<script type="text/javascript">
var example_2_trace = {"code": "f = max\nmax = 3\nresult = f(2, 3, 4)\nmax(1, 2)  # Causes an error", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"f": ["REF", 1]}, "heap": {"1": ["FUNCTION", "max(...)", null]}, "line": 2, "ordered_globals": ["f"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"f": ["REF", 1], "max": 3}, "heap": {"1": ["FUNCTION", "max(...)", null]}, "line": 3, "ordered_globals": ["f", "max"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"f": ["REF", 1], "max": 3, "result": 4}, "heap": {"1": ["FUNCTION", "max(...)", null]}, "line": 4, "ordered_globals": ["f", "max", "result"], "stack_to_render": [], "stdout": ""}, {"event": "exception", "exception_msg": "TypeError: 'int' object is not callable", "func_name": "<module>", "globals": {"f": ["REF", 1], "max": 3, "result": 4}, "heap": {"1": ["FUNCTION", "max(...)", null]}, "line": 4, "ordered_globals": ["f", "max", "result"], "stack_to_render": [], "stdout": ""}]}</script><p>The error message <tt class="docutils literal">TypeError: 'int' object is not callable</tt> is reporting that
the name <tt class="docutils literal">max</tt> (currently bound to the number 3) is an integer and not a
function.  Therefore, it cannot be used as the operator in a call expression.</p>
<p><strong>Function Signatures.</strong> Functions differ in the number of arguments that they
are allowed to take. To track these requirements, we draw each function in a
way that shows the function name and its formal parameters. The user-defined
function <tt class="docutils literal">square</tt> takes only <tt class="docutils literal">x</tt>; providing more or fewer arguments will
result in an error.  A description of the formal parameters of a function is
called the function's signature.</p>
<p>The function <tt class="docutils literal">max</tt> can take an arbitrary number of arguments. It is rendered
as <tt class="docutils literal"><span class="pre">max(...)</span></tt>. Regardless of the number of arguments taken, all built-in
functions will be rendered as <tt class="docutils literal"><span class="pre">&lt;name&gt;(...)</span></tt>, because these primitive
functions were never explicitly defined.</p>
</div>
<div class="section" id="calling-user-defined-functions">
<h3>1.3.2   Calling User-Defined Functions</h3>
<p>To evaluate a call expression whose operator names a user-defined function, the
Python interpreter follows a computational process. As with any call
expression, the interpreter evaluates the operator and operand expressions, and
then applies the named function to the resulting arguments.</p>
<p>Applying a user-defined function introduces a second <em>local</em> frame, which is
only accessible to that function. To apply a user-defined function to some
arguments:</p>
<ol class="arabic simple">
<li>Bind the arguments to the names of the function's formal parameters in a new
<em>local</em> frame.</li>
<li>Execute the body of the function in the environment that starts with this
frame.</li>
</ol>
<p>The environment in which the body is evaluated consists of two frames: first the
local frame that contains formal parameter bindings, then the global frame that
contains everything else. Each instance of a function application has its own
independent local frame.</p>
<p>To illustrate an example in detail, several steps of the environment diagram
for the same example are depicted below.  After executing the first import
statement, only the name <tt class="docutils literal">mul</tt> is bound in the global frame.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="1" id="example_3" style="">
from operator import mul
def square(x):
    return mul(x, x)
square(-2)
</div>
<script type="text/javascript">
var example_3_trace = {"code": "from operator import mul\ndef square(x):\n    return mul(x, x)\nsquare(-2)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"mul": ["REF", 1]}, "heap": {"1": ["FUNCTION", "mul(...)", null]}, "line": 2, "ordered_globals": ["mul"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 4, "ordered_globals": ["mul", "square"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 2, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 3, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f1"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 3, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"__return__": 4, "x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f1"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 4, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"__return__": 4, "x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f1_z"}], "stdout": ""}]}</script><p>First, the definition statement for the function <tt class="docutils literal">square</tt> is executed.
Notice that the entire <tt class="docutils literal">def</tt> statement is processed in a single step. The
body of a function is not executed until the function is called (not when it is
defined).</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="2" id="example_4" style="">
from operator import mul
def square(x):
    return mul(x, x)
square(-2)
</div>
<script type="text/javascript">
var example_4_trace = {"code": "from operator import mul\ndef square(x):\n    return mul(x, x)\nsquare(-2)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"mul": ["REF", 1]}, "heap": {"1": ["FUNCTION", "mul(...)", null]}, "line": 2, "ordered_globals": ["mul"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 4, "ordered_globals": ["mul", "square"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 2, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 3, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f1"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 3, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"__return__": 4, "x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f1"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 4, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"__return__": 4, "x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f1_z"}], "stdout": ""}]}</script><p>Next, The <tt class="docutils literal">square</tt> function is called with the argument <tt class="docutils literal"><span class="pre">-2</span></tt>, and so a
new frame is created with the formal parameter <tt class="docutils literal">x</tt> bound to the value <tt class="docutils literal"><span class="pre">-2</span></tt>.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="3" id="example_5" style="">
from operator import mul
def square(x):
    return mul(x, x)
square(-2)
</div>
<script type="text/javascript">
var example_5_trace = {"code": "from operator import mul\ndef square(x):\n    return mul(x, x)\nsquare(-2)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"mul": ["REF", 1]}, "heap": {"1": ["FUNCTION", "mul(...)", null]}, "line": 2, "ordered_globals": ["mul"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 4, "ordered_globals": ["mul", "square"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 2, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 3, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f1"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 3, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"__return__": 4, "x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f1"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 4, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"__return__": 4, "x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f1_z"}], "stdout": ""}]}</script><p>Then, the name <tt class="docutils literal">x</tt> is looked up in the current environment, which consists of
the two frames shown.  In both occurrences, <tt class="docutils literal">x</tt> evaluates to <tt class="docutils literal"><span class="pre">-2</span></tt>, and so
the <tt class="docutils literal">square</tt> function returns 4.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="4" id="example_6" style="">
from operator import mul
def square(x):
    return mul(x, x)
square(-2)
</div>
<script type="text/javascript">
var example_6_trace = {"code": "from operator import mul\ndef square(x):\n    return mul(x, x)\nsquare(-2)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"mul": ["REF", 1]}, "heap": {"1": ["FUNCTION", "mul(...)", null]}, "line": 2, "ordered_globals": ["mul"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 4, "ordered_globals": ["mul", "square"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 2, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 3, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f1"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 3, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"__return__": 4, "x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f1"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"mul": ["REF", 1], "square": ["REF", 2]}, "heap": {"1": ["FUNCTION", "mul(...)", null], "2": ["FUNCTION", "square(x)", null]}, "line": 4, "ordered_globals": ["mul", "square"], "stack_to_render": [{"encoded_locals": {"__return__": 4, "x": -2}, "frame_id": 1, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f1_z"}], "stdout": ""}]}</script><p>The "Return value" in the <tt class="docutils literal">square()</tt> frame is not a name binding; instead it
indicates the value returned by the function call that created the frame.</p>
<p>Even in this simple example, two different environments are used.  The
top-level expression <tt class="docutils literal"><span class="pre">square(-2)</span></tt> is evaluated in the global environment,
while the return expression <tt class="docutils literal">mul(x, x)</tt> is evaluated in the environment
created for by calling <tt class="docutils literal">square</tt>. Both <tt class="docutils literal">x</tt> and <tt class="docutils literal">mul</tt> are bound in this
environment, but in different frames.</p>
<p>The order of frames in an environment affects the value returned by looking up a
name in an expression. We stated previously that a name is evaluated to the
value associated with that name in the current environment. We can now be more
precise:</p>
<p><strong>Name Evaluation.</strong> A name evaluates to the value bound to that name in the
earliest frame of the current environment in which that name is found.</p>
<p>Our conceptual framework of environments, names, and functions constitutes a
<em>model of evaluation</em>; while some mechanical details are still unspecified
(e.g., how a binding is implemented), our model does precisely and correctly
describe how the interpreter evaluates call expressions. In Chapter 3 we will
see how this model can serve as a blueprint for implementing a working
interpreter for a programming language.</p>
</div>
<div class="section" id="example-calling-a-user-defined-function">
<h3>1.3.3   Example: Calling a User-Defined Function</h3>
<p>Let us again consider our two simple function definitions and illustrate the
process that evaluates a call expression for a user-defined function.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="3" id="example_7" style="">
from operator import add, mul
def square(x):
    return mul(x, x)

def sum_squares(x, y):
    return add(square(x), square(y))

result = sum_squares(5, 12)
</div>
<script type="text/javascript">
var example_7_trace = {"code": "from operator import add, mul\ndef square(x):\n    return mul(x, x)\n\ndef sum_squares(x, y):\n    return add(square(x), square(y))\n\nresult = sum_squares(5, 12)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null]}, "line": 2, "ordered_globals": ["add", "mul"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null]}, "line": 5, "ordered_globals": ["add", "mul", "square"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 8, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 5, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 6, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 2, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 2, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "return", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 6, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"__return__": 169, "x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3_z"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "result": 169, "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 8, "ordered_globals": ["add", "mul", "square", "sum_squares", "result"], "stack_to_render": [{"encoded_locals": {"__return__": 169, "x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1_z"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3_z"}], "stdout": ""}]}</script><p>Python first evaluates the name <tt class="docutils literal">sum_squares</tt>, which is bound to a
user-defined function in the global frame. The primitive numeric expressions 5
and 12 evaluate to the numbers they represent.</p>
<p>Next, Python applies <tt class="docutils literal">sum_squares</tt>, which introduces a local frame that binds
x to 5 and y to 12.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="4" id="example_8" style="">
from operator import add, mul
def square(x):
    return mul(x, x)

def sum_squares(x, y):
    return add(square(x), square(y))

result = sum_squares(5, 12)
</div>
<script type="text/javascript">
var example_8_trace = {"code": "from operator import add, mul\ndef square(x):\n    return mul(x, x)\n\ndef sum_squares(x, y):\n    return add(square(x), square(y))\n\nresult = sum_squares(5, 12)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null]}, "line": 2, "ordered_globals": ["add", "mul"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null]}, "line": 5, "ordered_globals": ["add", "mul", "square"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 8, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 5, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 6, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 2, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 2, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "return", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 6, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"__return__": 169, "x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3_z"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "result": 169, "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 8, "ordered_globals": ["add", "mul", "square", "sum_squares", "result"], "stack_to_render": [{"encoded_locals": {"__return__": 169, "x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1_z"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3_z"}], "stdout": ""}]}</script><p>The body of <tt class="docutils literal">sum_squares</tt> contains this call expression:</p>
<pre class="literal-block">
  add     (  square(x)  ,  square(y)  )
________     _________     _________
operator     operand 0     operand 1
</pre>
<p>All three subexpressions are evaluated in the current environment, which begins
with the frame labeled <tt class="docutils literal">sum_squares()</tt>.  The operator subexpression <tt class="docutils literal">add</tt>
is a name found in the global frame, bound to the built-in function for
addition. The two operand subexpressions must be evaluated in turn, before
addition is applied.  Both operands are evaluated in the current environment
beginning with the frame labeled <tt class="docutils literal">sum_squares</tt>.</p>
<p>In <tt class="docutils literal">operand 0</tt>, <tt class="docutils literal">square</tt> names a user-defined function in the global frame,
while <tt class="docutils literal">x</tt> names the number 5 in the local frame. Python applies <tt class="docutils literal">square</tt> to
5 by introducing yet another local frame that binds x to 5.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="5" id="example_9" style="">
from operator import add, mul
def square(x):
    return mul(x, x)

def sum_squares(x, y):
    return add(square(x), square(y))

result = sum_squares(5, 12)
</div>
<script type="text/javascript">
var example_9_trace = {"code": "from operator import add, mul\ndef square(x):\n    return mul(x, x)\n\ndef sum_squares(x, y):\n    return add(square(x), square(y))\n\nresult = sum_squares(5, 12)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null]}, "line": 2, "ordered_globals": ["add", "mul"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null]}, "line": 5, "ordered_globals": ["add", "mul", "square"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 8, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 5, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 6, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 2, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 2, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "return", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 6, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"__return__": 169, "x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3_z"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "result": 169, "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 8, "ordered_globals": ["add", "mul", "square", "sum_squares", "result"], "stack_to_render": [{"encoded_locals": {"__return__": 169, "x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1_z"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3_z"}], "stdout": ""}]}</script><p>Using this environment, the expression <tt class="docutils literal">mul(x, x)</tt> evaluates to 25.</p>
<p>Our evaluation procedure now turns to <tt class="docutils literal">operand 1</tt>, for which <tt class="docutils literal">y</tt> names the
number 12. Python evaluates the body of <tt class="docutils literal">square</tt> again, this time introducing
yet another local frame that binds <tt class="docutils literal">x</tt> to 12. Hence, <tt class="docutils literal">operand 1</tt> evaluates
to 144.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="8" id="example_10" style="">
from operator import add, mul
def square(x):
    return mul(x, x)

def sum_squares(x, y):
    return add(square(x), square(y))

result = sum_squares(5, 12)
</div>
<script type="text/javascript">
var example_10_trace = {"code": "from operator import add, mul\ndef square(x):\n    return mul(x, x)\n\ndef sum_squares(x, y):\n    return add(square(x), square(y))\n\nresult = sum_squares(5, 12)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null]}, "line": 2, "ordered_globals": ["add", "mul"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null]}, "line": 5, "ordered_globals": ["add", "mul", "square"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 8, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 5, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 6, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 2, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 2, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "return", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 6, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"__return__": 169, "x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3_z"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "result": 169, "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 8, "ordered_globals": ["add", "mul", "square", "sum_squares", "result"], "stack_to_render": [{"encoded_locals": {"__return__": 169, "x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1_z"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3_z"}], "stdout": ""}]}</script><p>Finally, applying addition to the arguments 25 and 144 yields a final return
value for <tt class="docutils literal">sum_squares</tt>: 169.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="-1" id="example_11" style="">
from operator import add, mul
def square(x):
    return mul(x, x)

def sum_squares(x, y):
    return add(square(x), square(y))

result = sum_squares(5, 12)
</div>
<script type="text/javascript">
var example_11_trace = {"code": "from operator import add, mul\ndef square(x):\n    return mul(x, x)\n\ndef sum_squares(x, y):\n    return add(square(x), square(y))\n\nresult = sum_squares(5, 12)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null]}, "line": 2, "ordered_globals": ["add", "mul"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null]}, "line": 5, "ordered_globals": ["add", "mul", "square"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 8, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 5, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 6, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 2, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2"}], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 2, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 3, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3"}], "stdout": ""}, {"event": "return", "func_name": "sum_squares", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 6, "ordered_globals": ["add", "mul", "square", "sum_squares"], "stack_to_render": [{"encoded_locals": {"__return__": 169, "x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3_z"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"add": ["REF", 1], "mul": ["REF", 2], "result": 169, "square": ["REF", 3], "sum_squares": ["REF", 4]}, "heap": {"1": ["FUNCTION", "add(...)", null], "2": ["FUNCTION", "mul(...)", null], "3": ["FUNCTION", "square(x)", null], "4": ["FUNCTION", "sum_squares(x, y)", null]}, "line": 8, "ordered_globals": ["add", "mul", "square", "sum_squares", "result"], "stack_to_render": [{"encoded_locals": {"__return__": 169, "x": 5, "y": 12}, "frame_id": 1, "func_name": "sum_squares", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "sum_squares_f1_z"}, {"encoded_locals": {"__return__": 25, "x": 5}, "frame_id": 2, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f2_z"}, {"encoded_locals": {"__return__": 144, "x": 12}, "frame_id": 3, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f3_z"}], "stdout": ""}]}</script><p>This example illustrates many of the fundamental ideas we have developed so
far.  Names are bound to values, which are distributed across many independent
local frames, along with a single global frame that contains shared names. A
new local frame is introduced every time a function is called, even if the same
function is called twice.</p>
<p>All of this machinery exists to ensure that names resolve to the correct values
at the correct times during program execution.  This example illustrates why our
model requires the complexity that we have introduced. All three local frames
contain a binding for the name <tt class="docutils literal">x</tt>, but that name is bound to different values
in different frames.  Local frames keep these names separate.</p>
</div>
<div class="section" id="local-names">
<h3>1.3.4   Local Names</h3>
<p>One detail of a function's implementation that should not affect the function's
behavior is the implementer's choice of names for the function's formal
parameters. Thus, the following functions should provide the same behavior:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>

<p>This principle -- that the meaning of a function should be independent of the
parameter names chosen by its author -- has important consequences for
programming languages. The simplest consequence is that the parameter names of a
function must remain local to the body of the function.</p>
<p>If the parameters were not local to the bodies of their respective functions,
then the parameter <tt class="docutils literal">x</tt> in <tt class="docutils literal">square</tt> could be confused with the parameter <tt class="docutils literal">x</tt> in
<tt class="docutils literal">sum_squares</tt>. Critically, this is not the case: the binding for <tt class="docutils literal">x</tt> in
different local frames are unrelated. The model of computation is carefully
designed to ensure this independence.</p>
<p>We say that the <em>scope</em> of a local name is limited to the body of the
user-defined function that defines it. When a name is no longer accessible, it
is out of scope. This scoping behavior isn't a new fact about our model; it is a
consequence of the way environments work.</p>
</div>
<div class="section" id="choosing-names">
<h3>1.3.5   Choosing Names</h3>
<p>The interchangeability of names does not imply that formal parameter names do not
matter at all. On the contrary, well-chosen function and parameter names are
essential for the human interpretability of function definitions!</p>
<p>The following guidelines are adapted from the <a class="reference external" href="http://www.python.org/dev/peps/pep-0008">style guide for Python code</a>,
which serves as a guide for all (non-rebellious) Python programmers. A shared
set of conventions smooths communication among members of a developer
community. As a side effect of following these conventions, you will find that
your code becomes more internally consistent.</p>
<ol class="arabic simple">
<li>Function names are lowercase, with words separated by underscores.
Descriptive names are encouraged.</li>
<li>Function names typically evoke operations applied to arguments by the
interpreter (e.g., <tt class="docutils literal">print</tt>, <tt class="docutils literal">add</tt>, <tt class="docutils literal">square</tt>) or the name of the
quantity that results (e.g., <tt class="docutils literal">max</tt>, <tt class="docutils literal">abs</tt>, <tt class="docutils literal">sum</tt>).</li>
<li>Parameter names are lowercase, with words separated by underscores.
Single-word names are preferred.</li>
<li>Parameter names should evoke the role of the parameter in the function, not
just the kind of argument that is allowed.</li>
<li>Single letter parameter names are acceptable when their role is obvious, but
avoid "l" (lowercase ell), "O" (capital oh), or "I" (capital i) to avoid
confusion with numerals.</li>
</ol>
<p>There are many exceptions to these guidelines, even in the Python standard
library. Like the vocabulary of the English language, Python has inherited
words from a variety of contributors, and the result is not always consistent.</p>
</div>
<div class="section" id="functions-as-abstractions">
<h3>1.3.6   Functions as Abstractions</h3>
<p>Though it is very simple, <tt class="docutils literal">sum_squares</tt> exemplifies the most powerful
property of user-defined functions. The function <tt class="docutils literal">sum_squares</tt> is defined in
terms of the function <tt class="docutils literal">square</tt>, but relies only on the relationship that
<tt class="docutils literal">square</tt> defines between its input arguments and its output values.</p>
<p>We can write <tt class="docutils literal">sum_squares</tt> without concerning ourselves with <em>how</em> to square
a number. The details of how the square is computed can be suppressed, to be
considered at a later time. Indeed, as far as <tt class="docutils literal">sum_squares</tt> is concerned,
<tt class="docutils literal">square</tt> is not a particular function body, but rather an abstraction of a
function, a so-called functional abstraction. At this level of abstraction, any
function that computes the square is equally good.</p>
<p>Thus, considering only the values they return, the following two functions for
squaring a number should be indistinguishable. Each takes a numerical argument
and produces the square of that number as the value.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span>
</pre></div>

<p>In other words, a function definition should be able to suppress details. The
users of the function may not have written the function themselves, but may have
obtained it from another programmer as a "black box". A programmer should not
need to know how the function is implemented in order to use it.  The Python
Library has this property. Many developers use the functions defined there, but
few ever inspect their implementation.</p>
<p><strong>Aspects of a functional abstraction.</strong> To master the use of a functional
abstraction, it is often useful to consider its three core attributes. The
<em>domain</em> of a function is the set of arguments it can take.  The <em>range</em> of a
function is the set of values it can return. The <em>intent</em> of a function is the
relationship it computes between inputs and output (as well as any side effects
it might generate). Understanding functional abstractions via their domain,
range, and intent is critical to using them correctly in a complex program.</p>
<p>For example, any <tt class="docutils literal">square</tt> function that we use to implement <tt class="docutils literal">sum_squares</tt>
should have these attributes:</p>
<ul class="simple">
<li>The <em>domain</em> is any single real number.</li>
<li>The <em>range</em> is any non-negative real number.</li>
<li>The <em>intent</em> is that the output is the square of the input.</li>
</ul>
<p>These attributes do not specify how the intent is carried out; that detail is
abstracted away.</p>
</div>
<div class="section" id="operators">
<h3>1.3.7   Operators</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#agDsdcF1bpBs').src &amp;&amp; (document.querySelector('#agDsdcF1bpBs').src = 'http://www.youtube.com/embed/gDsdcF1bpBs?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#agDsdcF1bpBs').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#agDsdcF1bpBs').style.cssText = 'display:none'; document.querySelector('#agDsdcF1bpBs').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="agDsdcF1bpBs" style="display:none;" width="640"></iframe>
</div>
<p>Mathematical operators (such as <tt class="docutils literal">+</tt> and <tt class="docutils literal">-</tt>) provided our first example of a
method of combination, but we have yet to define an evaluation procedure for
expressions that contain these operators.</p>
<p>Python expressions with infix operators each have their own evaluation procedures,
but you can often think of them as short-hand for call expressions. When you see</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
<span class="go">5</span>
</pre></div>

<p>simply consider it to be short-hand for</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>

<p>Infix notation can be nested, just like call expressions. Python applies the
normal mathematical rules of operator precedence, which dictate how to interpret
a compound expression with multiple operators.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span>
<span class="go">19</span>
</pre></div>

<p>evaluates to the same result as</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">19</span>
</pre></div>

<p>The nesting in the call expression is more explicit than the operator
version, but also harder to read. Python also allows subexpression grouping
with parentheses, to override the normal precedence rules or make the nested
structure of an expression more explicit.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">45</span>
</pre></div>

<p>evaluates to the same result as</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mul</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">45</span>
</pre></div>

<p>When it comes to division, Python provides two infix operators: <tt class="docutils literal">/</tt> and
<tt class="docutils literal">//</tt>. The former is normal division, so that it results in a <em>floating point</em>,
or decimal value, even if the divisor evenly divides the dividend:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">5</span> <span class="o">/</span> <span class="mi">4</span>
<span class="go">1.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">8</span> <span class="o">/</span> <span class="mi">4</span>
<span class="go">2.0</span>
</pre></div>

<p>The <tt class="docutils literal">//</tt> operator, on the other hand, rounds the result down to an integer:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">5</span> <span class="o">//</span> <span class="mi">4</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="mi">5</span> <span class="o">//</span> <span class="mi">4</span>
<span class="go">-2</span>
</pre></div>

<p>These two operators are shorthand for the <tt class="docutils literal">truediv</tt> and <tt class="docutils literal">floordiv</tt>
functions.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">truediv</span><span class="p">,</span> <span class="n">floordiv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">truediv</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">1.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">floordiv</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>

<p>You should feel free to use infix operators and parentheses in your programs.
Idiomatic Python prefers operators over call expressions for simple mathematical
operations.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/14-designing-functions.html">
  		1.4 Designing Functions
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="designing-functions">
<h2>1.4   Designing Functions</h2>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#aFzbVzGnVBB4').src &amp;&amp; (document.querySelector('#aFzbVzGnVBB4').src = 'http://www.youtube.com/embed/FzbVzGnVBB4?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#aFzbVzGnVBB4').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#aFzbVzGnVBB4').style.cssText = 'display:none'; document.querySelector('#aFzbVzGnVBB4').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="aFzbVzGnVBB4" style="display:none;" width="640"></iframe>
</div>
<p>Functions are an essential ingredient of all programs, large and small, and
serve as our primary medium to express computational processes in a programming
language. So far, we have discussed the formal properties of functions and how
they are applied. We now turn to the topic of what makes a good function.
Fundamentally, the qualities of good functions all reinforce the idea that
functions are abstractions.</p>
<ul class="simple">
<li>Each function should have exactly one job. That job should be identifiable
with a short name and characterizable in a single line of text. Functions
that perform multiple jobs in sequence should be divided into multiple
functions.</li>
<li>
<em>Don't repeat yourself</em> is a central tenet of software engineering. The
so-called DRY principle states that multiple fragments of code should not
describe redundant logic. Instead, that logic should be implemented once,
given a name, and applied multiple times. If you find yourself copying and
pasting a block of code, you have probably found an opportunity for functional
abstraction.</li>
<li>Functions should be defined generally. Squaring is not in the Python Library
precisely because it is a special case of the <tt class="docutils literal">pow</tt> function, which raises
numbers to arbitrary powers.</li>
</ul>
<p>These guidelines improve the readability of code, reduce the number of errors,
and often minimize the total amount of code written. Decomposing a complex task
into concise functions is a skill that takes experience to master. Fortunately,
Python provides several features to support your efforts.</p>
<div class="section" id="documentation">
<h3>1.4.1   Documentation</h3>
<p>A function definition will often include documentation describing the function,
called a <em>docstring</em>, which must be indented along with the function body.
Docstrings are conventionally triple quoted. The first line describes the job
of the function in one line. The following lines can describe arguments and
clarify the behavior of the function:</p>
<pre class="literal-block">
&gt;&gt;&gt; def pressure(v, t, n):
        """Compute the pressure in pascals of an ideal gas.

        Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law

        v -- volume of gas, in cubic meters
        t -- absolute temperature in degrees kelvin
        n -- particles of gas
        """
        k = 1.38e-23  # Boltzmann's constant
        return n * k * t / v
</pre>
<p>When you call <tt class="docutils literal">help</tt> with the name of a function as an argument, you see its
docstring (type <tt class="docutils literal">q</tt> to quit Python help).</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">pressure</span><span class="p">)</span>
</pre></div>

<p>When writing Python programs, include docstrings for all but the simplest
functions. Remember, code is written only once, but often read many times. The
Python docs include <a class="reference external" href="http://www.python.org/dev/peps/pep-0257/">docstring guidelines</a> that maintain consistency across
different Python projects.</p>
<p><strong>Comments</strong>. Comments in Python can be attached to the end of a line following
the <tt class="docutils literal">#</tt> symbol.  For example, the comment <tt class="docutils literal">Boltzmann's constant</tt> above
describes <tt class="docutils literal">k</tt>.  These comments don't ever appear in Python's <tt class="docutils literal">help</tt>, and
they are ignored by the interpreter.  They exist for humans alone.</p>
</div>
<div class="section" id="default-argument-values">
<h3>1.4.2   Default Argument Values</h3>
<p>A consequence of defining general functions is the introduction of additional
arguments. Functions with many arguments can be awkward to call and difficult to
read.</p>
<p>In Python, we can provide default values for the arguments of a function. When
calling that function, arguments with default values are optional. If they are
not provided, then the default value is bound to the formal parameter name
instead. For instance, if an application commonly computes pressure for one mole
of particles, this value can be provided as a default:</p>
<pre class="literal-block">
&gt;&gt;&gt; def pressure(v, t, n=6.022e23):
        """Compute the pressure in pascals of an ideal gas.

        v -- volume of gas, in cubic meters
        t -- absolute temperature in degrees kelvin
        n -- particles of gas (default: one mole)
        """
        k = 1.38e-23  # Boltzmann's constant
        return n * k * t / v
</pre>
<p>The <tt class="docutils literal">=</tt> symbol means two different things in this example, depending on the
context in which it is used.    In the <tt class="docutils literal">def</tt> statement header, <tt class="docutils literal">=</tt> does not
perform assignment, but instead indicates a default value to use when the
<tt class="docutils literal">pressure</tt> function is called. By contrast, the assignment statement to <tt class="docutils literal">k</tt>
in the body of the function binds the name <tt class="docutils literal">k</tt> to an approximation of
Boltzmann's constant.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pressure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">273.15</span><span class="p">)</span>
<span class="go">2269.974834</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pressure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">273.15</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="mf">6.022e23</span><span class="p">)</span>
<span class="go">6809.924502</span>
</pre></div>

<p>The <tt class="docutils literal">pressure</tt> function is defined to take three arguments, but only two are
provided in the first call expression above.  In this case, the value for <tt class="docutils literal">n</tt>
is taken from the <tt class="docutils literal">def</tt> statement default. If a third argument is provided,
the default is ignored.</p>
<p>As a guideline, most data values used in a function's body should be expressed
as default values to named arguments, so that they are easy to inspect and can
be changed by the function caller.  Some values that never change, such as the
fundamental constant <tt class="docutils literal">k</tt>, can be bound in the function body or in the global
frame.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/15-control.html">
  		1.5 Control
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="control">
<h2>1.5   Control</h2>
<p>The expressive power of the functions that we can define at this point is very
limited, because we have not introduced a way to make comparisons and to perform
different operations depending on the result of a comparison. <em>Control statements</em>
will give us this ability.  They are statements that control the flow of a
program's execution based on the results of logical comparisons.</p>
<p>Statements differ fundamentally from the expressions that we have studied so
far. They have no value.  Instead of computing something, executing a control
statement determines what the interpreter should do next.</p>
<div class="section" id="statements">
<h3>1.5.1   Statements</h3>
<p>So far, we have primarily considered how to evaluate expressions. However, we
have seen three kinds of statements already: assignment, <tt class="docutils literal">def</tt>, and
<tt class="docutils literal">return</tt> statements. These lines of Python code are not themselves
expressions, although they all contain expressions as components.</p>
<p>Rather than being evaluated, statements are <em>executed</em>. Each statement
describes some change to the interpreter state, and executing a statement
applies that change. As we have seen for <tt class="docutils literal">return</tt> and assignment statements,
executing statements can involve evaluating subexpressions contained within
them.</p>
<p>Expressions can also be executed as statements, in which case they are
evaluated, but their value is discarded. Executing a pure function has no
effect, but executing a non-pure function can cause effects as a consequence of
function application.</p>
<p>Consider, for instance,</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># Watch out! This call doesn't return a value.</span>
</pre></div>

<p>This example is valid Python, but probably not what was intended.  The body of
the function consists of an expression.  An expression by itself is a valid
statement, but the effect of the statement is that the <tt class="docutils literal">mul</tt> function is
called, and the result is discarded.  If you want to do something with the
result of an expression, you need to say so: you might store it with an
assignment statement or return it with a return statement:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>

<p>Sometimes it does make sense to have a function whose body is an expression,
when a non-pure function like <tt class="docutils literal">print</tt> is called.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>

<p>At its highest level, the Python interpreter's job is to execute programs,
composed of statements. However, much of the interesting work of computation
comes from evaluating expressions. Statements govern the relationship among
different expressions in a program and what happens to their results.</p>
</div>
<div class="section" id="compound-statements">
<h3>1.5.2   Compound Statements</h3>
<p>In general, Python code is a sequence of statements. A simple statement is a
single line that doesn't end in a colon. A compound statement is so called
because it is composed of other statements (simple and compound). Compound
statements typically span multiple lines and start with a one-line header ending
in a colon, which identifies the type of statement. Together, a header and an
indented suite of statements is called a clause.  A compound statement consists
of one or more clauses:</p>
<pre class="literal-block">
&lt;header&gt;:
    &lt;statement&gt;
    &lt;statement&gt;
    ...
&lt;separating header&gt;:
    &lt;statement&gt;
    &lt;statement&gt;
    ...
...
</pre>
<p>We can understand the statements we have already introduced in these terms.</p>
<ul class="simple">
<li>Expressions, return statements, and assignment statements are simple statements.</li>
<li>A <tt class="docutils literal">def</tt> statement is a compound statement. The suite that follows the
<tt class="docutils literal">def</tt> header defines the function body.</li>
</ul>
<p>Specialized evaluation rules for each kind of header dictate when and if the
statements in its suite are executed. We say that the header controls its suite.
For example, in the case of <tt class="docutils literal">def</tt> statements, we saw that the return
expression is not evaluated immediately, but instead stored for later use when
the defined function is eventually called.</p>
<p>We can also understand multi-line programs now.</p>
<ul class="simple">
<li>To execute a sequence of statements, execute the first statement. If that
statement does not redirect control, then proceed to execute the rest of the
sequence of statements, if any remain.</li>
</ul>
<p>This definition exposes the essential structure of a recursively defined
<em>sequence</em>: a sequence can be decomposed into its first element and the rest of
its elements. The "rest" of a sequence of statements is itself a sequence of
statements!  Thus, we can recursively apply this execution rule. This view of
sequences as recursive data structures will appear again in later chapters.</p>
<p>The important consequence of this rule is that statements are executed in order,
but later statements may never be reached, because of redirected control.</p>
<p><strong>Practical Guidance.</strong> When indenting a suite, all lines must be indented the
same amount and in the same way (use spaces, not tabs).  Any variation in
indentation will cause an error.</p>
</div>
<div class="section" id="defining-functions-ii-local-assignment">
<h3>1.5.3   Defining Functions II: Local Assignment</h3>
<p>Originally, we stated that the body of a user-defined function consisted only
of a <tt class="docutils literal">return</tt> statement with a single return expression. In fact, functions
can define a sequence of operations that extends beyond a single expression.</p>
<p>Whenever a user-defined function is applied, the sequence of clauses in the
suite of its definition is executed in a local environment — an environment
starting with a local frame created by calling that function. A <tt class="docutils literal">return</tt>
statement redirects control: the process of function application terminates
whenever the first <tt class="docutils literal">return</tt> statement is executed, and the value of the
<tt class="docutils literal">return</tt> expression is the returned value of the function being applied.</p>
<p>Assignment statements can appear within a function body. For instance, this
function returns the absolute difference between two quantities as a percentage
of the first, using a two-step calculation:</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="-1" id="example_12" style="">
def percent_difference(x, y):
    difference = abs(x-y)
    return 100 * difference / x
result = percent_difference(40, 50)
</div>
<script type="text/javascript">
var example_12_trace = {"code": "def percent_difference(x, y):\n    difference = abs(x-y)\n    return 100 * difference / x\nresult = percent_difference(40, 50)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"percent_difference": ["REF", 1]}, "heap": {"1": ["FUNCTION", "percent_difference(x, y)", null]}, "line": 4, "ordered_globals": ["percent_difference"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "percent_difference", "globals": {"percent_difference": ["REF", 1]}, "heap": {"1": ["FUNCTION", "percent_difference(x, y)", null]}, "line": 1, "ordered_globals": ["percent_difference"], "stack_to_render": [{"encoded_locals": {"x": 40, "y": 50}, "frame_id": 1, "func_name": "percent_difference", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "percent_difference_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "percent_difference", "globals": {"percent_difference": ["REF", 1]}, "heap": {"1": ["FUNCTION", "percent_difference(x, y)", null]}, "line": 2, "ordered_globals": ["percent_difference"], "stack_to_render": [{"encoded_locals": {"x": 40, "y": 50}, "frame_id": 1, "func_name": "percent_difference", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "percent_difference_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "percent_difference", "globals": {"percent_difference": ["REF", 1]}, "heap": {"1": ["FUNCTION", "percent_difference(x, y)", null]}, "line": 3, "ordered_globals": ["percent_difference"], "stack_to_render": [{"encoded_locals": {"difference": 10, "x": 40, "y": 50}, "frame_id": 1, "func_name": "percent_difference", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "difference"], "parent_frame_id_list": [], "unique_hash": "percent_difference_f1"}], "stdout": ""}, {"event": "return", "func_name": "percent_difference", "globals": {"percent_difference": ["REF", 1]}, "heap": {"1": ["FUNCTION", "percent_difference(x, y)", null]}, "line": 3, "ordered_globals": ["percent_difference"], "stack_to_render": [{"encoded_locals": {"__return__": ["SPECIAL_FLOAT", "25.0"], "difference": 10, "x": 40, "y": 50}, "frame_id": 1, "func_name": "percent_difference", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "difference", "__return__"], "parent_frame_id_list": [], "unique_hash": "percent_difference_f1"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"percent_difference": ["REF", 1], "result": ["SPECIAL_FLOAT", "25.0"]}, "heap": {"1": ["FUNCTION", "percent_difference(x, y)", null]}, "line": 4, "ordered_globals": ["percent_difference", "result"], "stack_to_render": [{"encoded_locals": {"__return__": ["SPECIAL_FLOAT", "25.0"], "difference": 10, "x": 40, "y": 50}, "frame_id": 1, "func_name": "percent_difference", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "y", "difference", "__return__"], "parent_frame_id_list": [], "unique_hash": "percent_difference_f1_z"}], "stdout": ""}]}</script><p>The effect of an assignment statement is to bind a name to a value in the
<em>first</em> frame of the current environment. As a consequence, assignment
statements within a function body cannot affect the global frame.  The fact
that functions can only manipulate their local environment is critical to
creating <em>modular</em> programs, in which pure functions interact only via the
values they
take and return.</p>
<p>Of course, the <tt class="docutils literal">percent_difference</tt> function could be written as a single
expression, as shown below, but the return expression is more complex.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">percent_difference</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="mi">100</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">percent_difference</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="go">25.0</span>
</pre></div>

<p>So far, local assignment hasn't increased the expressive power of our function
definitions. It will do so, when combined with other control statements. In
addition, local assignment also plays a critical role in clarifying the meaning
of complex expressions by assigning names to intermediate quantities.</p>
</div>
<div class="section" id="conditional-statements">
<h3>1.5.4   Conditional Statements</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#adijoBZH44kU').src &amp;&amp; (document.querySelector('#adijoBZH44kU').src = 'http://www.youtube.com/embed/dijoBZH44kU?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#adijoBZH44kU').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#adijoBZH44kU').style.cssText = 'display:none'; document.querySelector('#adijoBZH44kU').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="adijoBZH44kU" style="display:none;" width="640"></iframe>
</div>
<p>Python has a built-in function for computing absolute values.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>

<p>We would like to be able to implement such a function ourselves, but we have no
obvious way to define a function that has a comparison and a choice. We would
like to express that if <tt class="docutils literal">x</tt> is positive, <tt class="docutils literal">abs(x)</tt> returns <tt class="docutils literal">x</tt>.
Furthermore, if <tt class="docutils literal">x</tt> is 0, <tt class="docutils literal">abs(x)</tt> returns 0. Otherwise, <tt class="docutils literal">abs(x)</tt> returns
<tt class="docutils literal"><span class="pre">-x</span></tt>. In Python, we can express this choice with a conditional statement.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="-1" id="example_13" style="">
def absolute_value(x):
    """Compute abs(x)."""
    if x &gt; 0:
        return x
    elif x == 0:
        return 0
    else:
        return -x

result = absolute_value(-2)
</div>
<script type="text/javascript">
var example_13_trace = {"code": "def absolute_value(x):\n    \"\"\"Compute abs(x).\"\"\"\n    if x > 0:\n        return x\n    elif x == 0:\n        return 0\n    else:\n        return -x\n\nresult = absolute_value(-2)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"absolute_value": ["REF", 1]}, "heap": {"1": ["FUNCTION", "absolute_value(x)", null]}, "line": 10, "ordered_globals": ["absolute_value"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "absolute_value", "globals": {"absolute_value": ["REF", 1]}, "heap": {"1": ["FUNCTION", "absolute_value(x)", null]}, "line": 1, "ordered_globals": ["absolute_value"], "stack_to_render": [{"encoded_locals": {"x": -2}, "frame_id": 1, "func_name": "absolute_value", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "absolute_value_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "absolute_value", "globals": {"absolute_value": ["REF", 1]}, "heap": {"1": ["FUNCTION", "absolute_value(x)", null]}, "line": 3, "ordered_globals": ["absolute_value"], "stack_to_render": [{"encoded_locals": {"x": -2}, "frame_id": 1, "func_name": "absolute_value", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "absolute_value_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "absolute_value", "globals": {"absolute_value": ["REF", 1]}, "heap": {"1": ["FUNCTION", "absolute_value(x)", null]}, "line": 5, "ordered_globals": ["absolute_value"], "stack_to_render": [{"encoded_locals": {"x": -2}, "frame_id": 1, "func_name": "absolute_value", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "absolute_value_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "absolute_value", "globals": {"absolute_value": ["REF", 1]}, "heap": {"1": ["FUNCTION", "absolute_value(x)", null]}, "line": 8, "ordered_globals": ["absolute_value"], "stack_to_render": [{"encoded_locals": {"x": -2}, "frame_id": 1, "func_name": "absolute_value", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "absolute_value_f1"}], "stdout": ""}, {"event": "return", "func_name": "absolute_value", "globals": {"absolute_value": ["REF", 1]}, "heap": {"1": ["FUNCTION", "absolute_value(x)", null]}, "line": 8, "ordered_globals": ["absolute_value"], "stack_to_render": [{"encoded_locals": {"__return__": 2, "x": -2}, "frame_id": 1, "func_name": "absolute_value", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "absolute_value_f1"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"absolute_value": ["REF", 1], "result": 2}, "heap": {"1": ["FUNCTION", "absolute_value(x)", null]}, "line": 10, "ordered_globals": ["absolute_value", "result"], "stack_to_render": [{"encoded_locals": {"__return__": 2, "x": -2}, "frame_id": 1, "func_name": "absolute_value", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "absolute_value_f1_z"}], "stdout": ""}]}</script><p>This implementation of <tt class="docutils literal">absolute_value</tt> raises several important issues:</p>
<p><strong>Conditional statements</strong>. A conditional statement in Python consists of a
series of headers and suites: a required <tt class="docutils literal">if</tt> clause, an optional sequence of
<tt class="docutils literal">elif</tt> clauses, and finally an optional <tt class="docutils literal">else</tt> clause:</p>
<pre class="literal-block">
if &lt;expression&gt;:
    &lt;suite&gt;
elif &lt;expression&gt;:
    &lt;suite&gt;
else:
    &lt;suite&gt;
</pre>
<p>When executing a conditional statement, each clause is considered in order. The
computational process of executing a conditional clause follows.</p>
<ol class="arabic simple">
<li>Evaluate the header's expression.</li>
<li>If it is a true value, execute the suite. Then, skip over all subsequent
clauses in the conditional statement.</li>
</ol>
<p>If the <tt class="docutils literal">else</tt> clause is reached (which only happens if all <tt class="docutils literal">if</tt> and <tt class="docutils literal">elif</tt>
expressions evaluate to false values), its suite is executed.</p>
<p><strong>Boolean contexts</strong>. Above, the execution procedures mention "a false value"
and "a true value." The expressions inside the header statements of conditional
blocks are said to be in <em>boolean contexts</em>: their truth values matter to
control flow, but otherwise their values are not assigned or returned.  Python
includes several false values, including 0, <tt class="docutils literal">None</tt>, and the <em>boolean</em> value
<tt class="docutils literal">False</tt>.  All other numbers are true values. In Chapter 2, we will see that
every built-in kind of data in Python has both true and false values.</p>
<p><strong>Boolean values</strong>. Python has two boolean values, called <tt class="docutils literal">True</tt> and
<tt class="docutils literal">False</tt>. Boolean values represent truth values in logical expressions.  The
built-in comparison operations, <tt class="docutils literal">&gt;, &lt;, &gt;=, &lt;=, ==, !=</tt>, return these values.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="o">&lt;</span> <span class="mi">2</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">5</span> <span class="o">&gt;=</span> <span class="mi">5</span>
<span class="go">True</span>
</pre></div>

<p>This second example reads "5 is greater than or equal to 5", and corresponds to
the function <tt class="docutils literal">ge</tt> in the <tt class="docutils literal">operator</tt> module.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="o">==</span> <span class="o">-</span><span class="mi">0</span>
<span class="go">True</span>
</pre></div>

<p>This final example reads "0 equals -0", and corresponds to <tt class="docutils literal">eq</tt> in the
<tt class="docutils literal">operator</tt> module. Notice that Python distinguishes assignment (<tt class="docutils literal">=</tt>) from
equality comparison (<tt class="docutils literal">==</tt>), a convention shared across many programming
languages.</p>
<p><strong>Boolean operators</strong>. Three basic logical operators are also built into Python:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kc">True</span> <span class="ow">and</span> <span class="kc">False</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kc">True</span> <span class="ow">or</span> <span class="kc">False</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="ow">not</span> <span class="kc">False</span>
<span class="go">True</span>
</pre></div>

<p>Logical expressions have corresponding evaluation procedures. These procedures
exploit the fact that the truth value of a logical expression can sometimes be
determined without evaluating all of its subexpressions, a feature called
<em>short-circuiting</em>.</p>
<p>To evaluate the expression <tt class="docutils literal">&lt;left&gt; and &lt;right&gt;</tt>:</p>
<ol class="arabic simple">
<li>Evaluate the subexpression <tt class="docutils literal">&lt;left&gt;</tt>.</li>
<li>If the result is a false value <tt class="docutils literal">v</tt>, then the expression evaluates to <tt class="docutils literal">v</tt>.</li>
<li>Otherwise, the expression evaluates to the value of the subexpression
<tt class="docutils literal">&lt;right&gt;</tt>.</li>
</ol>
<p>To evaluate the expression <tt class="docutils literal">&lt;left&gt; or &lt;right&gt;</tt>:</p>
<ol class="arabic simple">
<li>Evaluate the subexpression <tt class="docutils literal">&lt;left&gt;</tt>.</li>
<li>If the result is a true value <tt class="docutils literal">v</tt>, then the expression evaluates to <tt class="docutils literal">v</tt>.</li>
<li>Otherwise, the expression evaluates to the value of the subexpression
<tt class="docutils literal">&lt;right&gt;</tt>.</li>
</ol>
<p>To evaluate the expression <tt class="docutils literal">not &lt;exp&gt;</tt>:</p>
<ol class="arabic simple">
<li>Evaluate <tt class="docutils literal">&lt;exp&gt;</tt>; The value is <tt class="docutils literal">True</tt> if the result is a false value, and
<tt class="docutils literal">False</tt> otherwise.</li>
</ol>
<p>These values, rules, and operators provide us with a way to combine the results
of comparisons.  Functions that perform comparisons and return boolean values
typically begin with <tt class="docutils literal">is</tt>, not followed by an underscore (e.g., <tt class="docutils literal">isfinite</tt>,
<tt class="docutils literal">isdigit</tt>, <tt class="docutils literal">isinstance</tt>, etc.).</p>
</div>
<div class="section" id="iteration">
<h3>1.5.5   Iteration</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#ax23Rw591l-s').src &amp;&amp; (document.querySelector('#ax23Rw591l-s').src = 'http://www.youtube.com/embed/x23Rw591l-s?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#ax23Rw591l-s').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#ax23Rw591l-s').style.cssText = 'display:none'; document.querySelector('#ax23Rw591l-s').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="ax23Rw591l-s" style="display:none;" width="640"></iframe>
</div>
<p>In addition to selecting which statements to execute, control statements are
used to express repetition. If each line of code we wrote were only executed once,
programming would be a very unproductive exercise. Only through repeated
execution of statements do we unlock the full potential of computers. We have
already seen one form of repetition: a function can be applied many times,
although it is only defined once. Iterative control structures are another
mechanism for executing the same statements many times.</p>
<p>Consider the sequence of Fibonacci numbers, in which each number is the sum of
the preceding two:</p>
<pre class="literal-block">
0, 1, 1, 2, 3, 5, 8, 13, 21, ...
</pre>
<p>Each value is constructed by repeatedly applying the sum-previous-two rule. The
first and second are fixed to 0 and 1.  For instance, the eighth Fibonacci
number is 13.</p>
<p>We can use a <tt class="docutils literal">while</tt> statement to enumerate <tt class="docutils literal">n</tt> Fibonacci numbers.  We need
to track how many values we've created (<tt class="docutils literal">k</tt>), along with the kth value
(<tt class="docutils literal">curr</tt>) and its predecessor (<tt class="docutils literal">pred</tt>). Step through this function and
observe how the Fibonacci numbers evolve one by one, bound to <tt class="docutils literal">curr</tt>.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="1" id="example_14" style="">
def fib(n):
    """Compute the nth Fibonacci number, for n &gt;= 2."""
    pred, curr = 0, 1   # Fibonacci numbers 1 and 2
    k = 2               # Which Fib number is curr?
    while k &lt; n:
        pred, curr = curr, pred + curr
        k = k + 1
    return curr

result = fib(8)
</div>
<script type="text/javascript">
var example_14_trace = {"code": "def fib(n):\n    \"\"\"Compute the nth Fibonacci number, for n >= 2.\"\"\"\n    pred, curr = 0, 1   # Fibonacci numbers 1 and 2\n    k = 2               # Which Fib number is curr?\n    while k < n:\n        pred, curr = curr, pred + curr\n        k = k + 1\n    return curr\n\nresult = fib(8)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 10, "ordered_globals": ["fib"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 1, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 8}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 3, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 8}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 4, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 1, "n": 8, "pred": 0}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 5, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 1, "k": 2, "n": 8, "pred": 0}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 6, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 1, "k": 2, "n": 8, "pred": 0}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 7, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 1, "k": 2, "n": 8, "pred": 1}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 5, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 1, "k": 3, "n": 8, "pred": 1}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 6, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 1, "k": 3, "n": 8, "pred": 1}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 7, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 2, "k": 3, "n": 8, "pred": 1}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 5, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 2, "k": 4, "n": 8, "pred": 1}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 6, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 2, "k": 4, "n": 8, "pred": 1}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 7, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 3, "k": 4, "n": 8, "pred": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 5, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 3, "k": 5, "n": 8, "pred": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 6, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 3, "k": 5, "n": 8, "pred": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 7, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 5, "k": 5, "n": 8, "pred": 3}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 5, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 5, "k": 6, "n": 8, "pred": 3}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 6, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 5, "k": 6, "n": 8, "pred": 3}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 7, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 8, "k": 6, "n": 8, "pred": 5}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 5, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 8, "k": 7, "n": 8, "pred": 5}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 6, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 8, "k": 7, "n": 8, "pred": 5}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 7, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 13, "k": 7, "n": 8, "pred": 8}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 5, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 13, "k": 8, "n": 8, "pred": 8}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 8, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"curr": 13, "k": 8, "n": 8, "pred": 8}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "return", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 8, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"__return__": 13, "curr": 13, "k": 8, "n": 8, "pred": 8}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "pred", "curr", "k", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"fib": ["REF", 1], "result": 13}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 10, "ordered_globals": ["fib", "result"], "stack_to_render": [], "stdout": ""}]}</script><p>Remember that commas seperate multiple names and values in an assignment
statement.  The line:</p>
<pre class="literal-block">
pred, curr = curr, pred + curr
</pre>
<p>has the effect of rebinding the name <tt class="docutils literal">pred</tt> to the value of <tt class="docutils literal">curr</tt>, and
simultaneously rebinding <tt class="docutils literal">curr</tt> to the value of <tt class="docutils literal">pred + curr</tt>.  All of the
expressions to the right of <tt class="docutils literal">=</tt> are evaluated before any rebinding takes
place.</p>
<p>This order of events -- evaluating everything on the right of <tt class="docutils literal">=</tt> before
updating any bindings on the left -- is essential for correctness of this
function.</p>
<p>A <tt class="docutils literal">while</tt> clause contains a header expression followed by a suite:</p>
<pre class="literal-block">
while &lt;expression&gt;:
    &lt;suite&gt;
</pre>
<p>To execute a <tt class="docutils literal">while</tt> clause:</p>
<ol class="arabic simple">
<li>Evaluate the header's expression.</li>
<li>If it is a true value, execute the suite, then return to step 1.</li>
</ol>
<p>In step 2, the entire suite of the <tt class="docutils literal">while</tt> clause is executed before the
header expression is evaluated again.</p>
<p>In order to prevent the suite of a <tt class="docutils literal">while</tt> clause from being executed
indefinitely, the suite should always change some binding in each pass.</p>
<p>A <tt class="docutils literal">while</tt> statement that does not terminate is called an infinite loop.
Press <tt class="docutils literal"><span class="pre">&lt;Control&gt;-C</span></tt> to force Python to stop looping.</p>
</div>
<div class="section" id="testing">
<h3>1.5.6   Testing</h3>
<p><em>Testing</em> a function is the act of verifying that the function's behavior
matches expectations. Our language of functions is now sufficiently complex
that we need to start testing our implementations.</p>
<p>A <em>test</em> is a mechanism for systematically performing this verification.  Tests
typically take the form of another function that contains one or more sample
calls to the function being tested. The returned value is then verified against
an expected result. Unlike most functions, which are meant to be general, tests
involve selecting and validating calls with specific argument values.  Tests
also serve as documentation: they demonstrate how to call a function and what
argument values are appropriate.</p>
<p><strong>Assertions.</strong>  Programmers use <tt class="docutils literal">assert</tt> statements to verify expectations,
such as the output of a function being tested. An <tt class="docutils literal">assert</tt> statement has an
expression in a boolean context, followed by a quoted line of text (single or
double quotes are both fine, but be consistent) that will be displayed if the
expression evaluates to a false value.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">fib</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">13</span><span class="p">,</span> <span class="s1">'The 8th Fibonacci number should be 13'</span>
</pre></div>

<p>When the expression being asserted evaluates to a true value, executing an
assert statement has no effect. When it is a false value, <tt class="docutils literal">assert</tt> causes an
error that halts execution.</p>
<p>A test function for <tt class="docutils literal">fib</tt> should test several arguments, including extreme
values of <tt class="docutils literal">n</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fib_test</span><span class="p">():</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">fib</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'The 2nd Fibonacci number should be 1'</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">fib</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'The 3rd Fibonacci number should be 1'</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">fib</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7778742049</span><span class="p">,</span> <span class="s1">'Error at the 50th Fibonacci number'</span>
</pre></div>

<p>When writing Python in files, rather than directly into the interpreter, tests
are typically written in the same file or a neighboring file with the suffix
<tt class="docutils literal">_test.py</tt>.</p>
<p><strong>Doctests.</strong> Python provides a convenient method for placing simple tests
directly in the docstring of a function. The first line of a docstring should
contain a one-line description of the function, followed by a blank line.  A
detailed description of arguments and behavior may follow. In addition, the
docstring may include a sample interactive session that calls the function:</p>
<pre class="literal-block">
&gt;&gt;&gt; def sum_naturals(n):
        """Return the sum of the first n natural numbers.

        &gt;&gt;&gt; sum_naturals(10)
        55
        &gt;&gt;&gt; sum_naturals(100)
        5050
        """
        total, k = 0, 1
        while k &lt;= n:
            total, k = total + k, k + 1
        return total
</pre>
<p>Then, the interaction can be verified via the <a class="reference external" href="http://docs.python.org/py3k/library/doctest.html">doctest module</a>. Below, the
<tt class="docutils literal">globals</tt> function returns a representation of the global environment, which
the interpreter needs in order to evaluate expressions.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">doctest</span> <span class="k">import</span> <span class="n">testmod</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">testmod</span><span class="p">()</span>
<span class="go">TestResults(failed=0, attempted=2)</span>
</pre></div>

<p>To verify the doctest interactions for only a single function, we use a
<tt class="docutils literal">doctest</tt> function called <tt class="docutils literal">run_docstring_examples</tt>.  This function is
(unfortunately) a bit complicated to call.  Its first argument is the function
to test.  The second should always be the result of the expression
<tt class="docutils literal">globals()</tt>, a built-in function that returns the global environment.  The
third argument is <tt class="docutils literal">True</tt> to indicate that we would like "verbose" output: a
catalog of all tests run.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">doctest</span> <span class="k">import</span> <span class="n">run_docstring_examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">run_docstring_examples</span><span class="p">(</span><span class="n">sum_naturals</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">Finding tests in NoName</span>
<span class="go">Trying:</span>
<span class="gp">    </span><span class="n">sum_naturals</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">Expecting:</span>
<span class="gp">    </span><span class="mi">55</span>
<span class="go">ok</span>
<span class="go">Trying:</span>
<span class="gp">    </span><span class="n">sum_naturals</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">Expecting:</span>
<span class="gp">    </span><span class="mi">5050</span>
<span class="go">ok</span>
</pre></div>

<p>When the return value of a function does not match the expected result, the
<tt class="docutils literal">run_docstring_examples</tt> function will report this problem as a test failure.</p>
<p>When writing Python in files, all doctests in a file can be run by starting
Python with the doctest command line option:</p>
<pre class="literal-block">
python3 -m doctest &lt;python_source_file&gt;
</pre>
<p>The key to effective testing is to write (and run) tests immediately after
implementing new functions. It is even good practice to write some tests before
you implement, in order to have some example inputs and outputs in your mind.
A test that applies a single function is called a <em>unit test</em>.  Exhaustive unit
testing is a hallmark of good program design.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/16-higher-order-functions.html">
  		1.6 Higher-Order Functions
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="higher-order-functions">
<h2>1.6   Higher-Order Functions</h2>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#aUlXvz-34Me0').src &amp;&amp; (document.querySelector('#aUlXvz-34Me0').src = 'http://www.youtube.com/embed/UlXvz-34Me0?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#aUlXvz-34Me0').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#aUlXvz-34Me0').style.cssText = 'display:none'; document.querySelector('#aUlXvz-34Me0').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="aUlXvz-34Me0" style="display:none;" width="640"></iframe>
</div>
<p>We have seen that functions are a method of abstraction that describe compound
operations independent of the particular values of their arguments. That is, in
<tt class="docutils literal">square</tt>,</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
</pre></div>

<p>we are not talking about the square of a particular number, but rather about a
method for obtaining the square of any number. Of course, we could get along
without ever defining this function, by always writing expressions such as</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">5</span> <span class="o">*</span> <span class="mi">5</span>
<span class="go">25</span>
</pre></div>

<p>and never mentioning <tt class="docutils literal">square</tt> explicitly. This practice would suffice for
simple computations such as <tt class="docutils literal">square</tt>, but would become arduous for more
complex examples such as <tt class="docutils literal">abs</tt> or <tt class="docutils literal">fib</tt>. In general, lacking function
definition would put us at the disadvantage of forcing us to work always at the
level of the particular operations that happen to be primitives in the language
(multiplication, in this case) rather than in terms of higher-level operations.
Our programs would be able to compute squares, but our language would lack the
ability to express the concept of squaring.</p>
<p>One of the things we should demand from a powerful programming language is the
ability to build abstractions by assigning names to common patterns and then to
work in terms of the names directly.  Functions provide this ability.  As we
will see in the following examples, there are common programming patterns that
recur in code, but are used with a number of different functions. These
patterns can also be abstracted, by giving them names.</p>
<p>To express certain general patterns as named concepts, we will need to construct
functions that can accept other functions as arguments or return functions as
values. Functions that manipulate functions are called higher-order functions.
This section shows how higher-order functions can serve as powerful abstraction
mechanisms, vastly increasing the expressive power of our language.</p>
<div class="section" id="functions-as-arguments">
<h3>1.6.1   Functions as Arguments</h3>
<p>Consider the following three functions, which all compute summations. The first,
<tt class="docutils literal">sum_naturals</tt>, computes the sum of natural numbers up to <tt class="docutils literal">n</tt>:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sum_naturals</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">total</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">total</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">total</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sum_naturals</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">5050</span>
</pre></div>

<p>The second, <tt class="docutils literal">sum_cubes</tt>, computes the sum of the cubes of natural numbers up
to <tt class="docutils literal">n</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sum_cubes</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">total</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">total</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">total</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sum_cubes</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">25502500</span>
</pre></div>

<p>The third, <tt class="docutils literal">pi_sum</tt>, computes the sum of terms in the series</p>
<div class="figure">
<img alt="" src="../img/pi_sum.png">
</div>
<p>which converges to pi very slowly.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pi_sum</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">total</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">total</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">/</span> <span class="p">((</span><span class="mi">4</span><span class="o">*</span><span class="n">k</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">total</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi_sum</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">3.1365926848388144</span>
</pre></div>

<p>These three functions clearly share a common underlying pattern. They are for
the most part identical, differing only in name and the function of <tt class="docutils literal">k</tt> used
to compute the term to be added. We could generate each of the functions by
filling in slots in the same template:</p>
<pre class="literal-block">
def &lt;name&gt;(n):
    total, k = 0, 1
    while k &lt;= n:
        total, k = total + &lt;term&gt;(k), k + 1
    return total
</pre>
<p>The presence of such a common pattern is strong evidence that there is a useful
abstraction waiting to be brought to the surface. Each of these functions is a
summation of terms. As program designers, we would like our language to be
powerful enough so that we can write a function that expresses the concept of
summation itself rather than only functions that compute particular sums. We
can do so readily in Python by taking the common template shown above and
transforming the "slots" into formal parameters:</p>
<p>In the example below, <tt class="docutils literal">summation</tt> takes as its two arguments the upper bound
<tt class="docutils literal">n</tt> together with the function <tt class="docutils literal">term</tt> that computes the kth term. We can use
<tt class="docutils literal">summation</tt> just as we would any function, and it expresses summations
succinctly.  Take the time to step through this example, and notice how binding
<tt class="docutils literal">cube</tt> to the local names <tt class="docutils literal">term</tt> ensures that the result <tt class="docutils literal">1*1*1 + 2*2*2 +
3*3*3 = 36</tt> is computed correctly. In this example, frames which are no longer
needed are removed to save space.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="3" id="example_15" style="">
def summation(n, term):
    total, k = 0, 1
    while k &lt;= n:
        total, k = total + term(k), k + 1
    return total

def cube(x):
    return x*x*x

def sum_cubes(n):
    return summation(n, cube)

result = sum_cubes(3)
</div>
<script type="text/javascript">
var example_15_trace = {"code": "def summation(n, term):\n    total, k = 0, 1\n    while k <= n:\n        total, k = total + term(k), k + 1\n    return total\n\ndef cube(x):\n    return x*x*x\n\ndef sum_cubes(n):\n    return summation(n, cube)\n\nresult = sum_cubes(3)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null]}, "line": 7, "ordered_globals": ["summation"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"cube": ["REF", 2], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null]}, "line": 10, "ordered_globals": ["summation", "cube"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 13, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "sum_cubes", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 10, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "sum_cubes", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 11, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}], "stdout": ""}, {"event": "call", "func_name": "summation", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 1, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"n": 3, "term": ["REF", 2]}, "frame_id": 2, "func_name": "summation", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "summation", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 2, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"n": 3, "term": ["REF", 2]}, "frame_id": 2, "func_name": "summation", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "summation", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 3, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 1, "n": 3, "term": ["REF", 2], "total": 0}, "frame_id": 2, "func_name": "summation", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "summation", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 4, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 1, "n": 3, "term": ["REF", 2], "total": 0}, "frame_id": 2, "func_name": "summation", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}], "stdout": ""}, {"event": "call", "func_name": "cube", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 7, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 1, "n": 3, "term": ["REF", 2], "total": 0}, "frame_id": 2, "func_name": "summation", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 3, "func_name": "cube", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "cube_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "cube", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 8, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 1, "n": 3, "term": ["REF", 2], "total": 0}, "frame_id": 2, "func_name": "summation", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 3, "func_name": "cube", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "cube_f3"}], "stdout": ""}, {"event": "return", "func_name": "cube", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 8, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 1, "n": 3, "term": ["REF", 2], "total": 0}, "frame_id": 2, "func_name": "summation", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}, {"encoded_locals": {"__return__": 1, "x": 1}, "frame_id": 3, "func_name": "cube", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "cube_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "summation", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 3, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 2, "n": 3, "term": ["REF", 2], "total": 1}, "frame_id": 2, "func_name": "summation", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "summation", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 4, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 2, "n": 3, "term": ["REF", 2], "total": 1}, "frame_id": 2, "func_name": "summation", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}], "stdout": ""}, {"event": "call", "func_name": "cube", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 7, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 2, "n": 3, "term": ["REF", 2], "total": 1}, "frame_id": 2, "func_name": "summation", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}, {"encoded_locals": {"x": 2}, "frame_id": 4, "func_name": "cube", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "cube_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "cube", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 8, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 2, "n": 3, "term": ["REF", 2], "total": 1}, "frame_id": 2, "func_name": "summation", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}, {"encoded_locals": {"x": 2}, "frame_id": 4, "func_name": "cube", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "cube_f4"}], "stdout": ""}, {"event": "return", "func_name": "cube", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 8, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 2, "n": 3, "term": ["REF", 2], "total": 1}, "frame_id": 2, "func_name": "summation", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}, {"encoded_locals": {"__return__": 8, "x": 2}, "frame_id": 4, "func_name": "cube", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "cube_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "summation", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 3, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 3, "n": 3, "term": ["REF", 2], "total": 9}, "frame_id": 2, "func_name": "summation", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "summation", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 4, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 3, "n": 3, "term": ["REF", 2], "total": 9}, "frame_id": 2, "func_name": "summation", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}], "stdout": ""}, {"event": "call", "func_name": "cube", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 7, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 3, "n": 3, "term": ["REF", 2], "total": 9}, "frame_id": 2, "func_name": "summation", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}, {"encoded_locals": {"x": 3}, "frame_id": 5, "func_name": "cube", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "cube_f5"}], "stdout": ""}, {"event": "step_line", "func_name": "cube", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 8, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 3, "n": 3, "term": ["REF", 2], "total": 9}, "frame_id": 2, "func_name": "summation", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}, {"encoded_locals": {"x": 3}, "frame_id": 5, "func_name": "cube", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "cube_f5"}], "stdout": ""}, {"event": "return", "func_name": "cube", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 8, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 3, "n": 3, "term": ["REF", 2], "total": 9}, "frame_id": 2, "func_name": "summation", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}, {"encoded_locals": {"__return__": 27, "x": 3}, "frame_id": 5, "func_name": "cube", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "cube_f5"}], "stdout": ""}, {"event": "step_line", "func_name": "summation", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 3, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 4, "n": 3, "term": ["REF", 2], "total": 36}, "frame_id": 2, "func_name": "summation", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "summation", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 5, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"k": 4, "n": 3, "term": ["REF", 2], "total": 36}, "frame_id": 2, "func_name": "summation", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}], "stdout": ""}, {"event": "return", "func_name": "summation", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 5, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}, {"encoded_locals": {"__return__": 36, "k": 4, "n": 3, "term": ["REF", 2], "total": 36}, "frame_id": 2, "func_name": "summation", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "term", "total", "k", "__return__"], "parent_frame_id_list": [], "unique_hash": "summation_f2"}], "stdout": ""}, {"event": "return", "func_name": "sum_cubes", "globals": {"cube": ["REF", 2], "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 11, "ordered_globals": ["summation", "cube", "sum_cubes"], "stack_to_render": [{"encoded_locals": {"__return__": 36, "n": 3}, "frame_id": 1, "func_name": "sum_cubes", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "sum_cubes_f1"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"cube": ["REF", 2], "result": 36, "sum_cubes": ["REF", 3], "summation": ["REF", 1]}, "heap": {"1": ["FUNCTION", "summation(n, term)", null], "2": ["FUNCTION", "cube(x)", null], "3": ["FUNCTION", "sum_cubes(n)", null]}, "line": 13, "ordered_globals": ["summation", "cube", "sum_cubes", "result"], "stack_to_render": [], "stdout": ""}]}</script><p>Using an <tt class="docutils literal">identity</tt> function that returns its argument, we can also sum
natural numbers using exactly the same <tt class="docutils literal">summation</tt> function.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">summation</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">total</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">total</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="n">term</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">total</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">x</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sum_naturals</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">summation</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">identity</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sum_naturals</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">55</span>
</pre></div>

<p>The <tt class="docutils literal">summation</tt> function can also be called directly, without definining
another function for a specific sequence.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">summation</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">square</span><span class="p">)</span>
<span class="go">385</span>
</pre></div>

<p>We can define <tt class="docutils literal">pi_sum</tt> using our <tt class="docutils literal">summation</tt> abstraction by defining a
function <tt class="docutils literal">pi_term</tt> to compute each term.  We pass the argument <tt class="docutils literal">1e6</tt>, a
shorthand for <tt class="docutils literal">1 * 10^6 = 1000000</tt>, to generate a close approximation to pi.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pi_term</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="mi">8</span> <span class="o">/</span> <span class="p">((</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pi_sum</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">summation</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">pi_term</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi_sum</span><span class="p">(</span><span class="mf">1e6</span><span class="p">)</span>
<span class="go">3.141592153589902</span>
</pre></div>

</div>
<div class="section" id="functions-as-general-methods">
<h3>1.6.2   Functions as General Methods</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#a71Vp90zsSds').src &amp;&amp; (document.querySelector('#a71Vp90zsSds').src = 'http://www.youtube.com/embed/71Vp90zsSds?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#a71Vp90zsSds').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#a71Vp90zsSds').style.cssText = 'display:none'; document.querySelector('#a71Vp90zsSds').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="a71Vp90zsSds" style="display:none;" width="640"></iframe>
</div>
<p>We introduced user-defined functions as a mechanism for abstracting patterns of
numerical operations so as to make them independent of the particular numbers
involved. With higher-order functions, we begin to see a more powerful kind of
abstraction: some functions express general methods of computation, independent
of the particular functions they call.</p>
<p>Despite this conceptual extension of what a function means, our environment
model of how to evaluate a call expression extends gracefully to the case of
higher-order functions, without change. When a user-defined function is applied
to some arguments, the formal parameters are bound to the values of those
arguments (which may be functions) in a new local frame.</p>
<p>Consider the following example, which implements a general method for iterative
improvement and uses it to compute the <a class="reference external" href="http://www.geom.uiuc.edu/~demo5337/s97b/art.htm">golden ratio</a>. The golden ratio, often
called "phi", is a number near 1.6 that appears frequently in nature, art, and
architecture.</p>
<p>An iterative improvement algorithm begins with a <tt class="docutils literal">guess</tt> of a solution to an
equation. It repeatedly applies an <tt class="docutils literal">update</tt> function to improve that guess,
and applies a <tt class="docutils literal">close</tt> comparison to check whether the current <tt class="docutils literal">guess</tt> is
"close enough" to be considered correct.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">improve</span><span class="p">(</span><span class="n">update</span><span class="p">,</span> <span class="n">close</span><span class="p">,</span> <span class="n">guess</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="ow">not</span> <span class="n">close</span><span class="p">(</span><span class="n">guess</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">guess</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">guess</span>
</pre></div>

<p>This <tt class="docutils literal">improve</tt> function is a general expression of repetitive refinement.  It
doesn't specify what problem is being solved: those details are left to the
<tt class="docutils literal">update</tt> and <tt class="docutils literal">close</tt> functions passed in as arguments.</p>
<p>Among the well-known properties of the golden ratio are that it can be computed
by repeatedly summing the inverse of any positive number with 1, and that it is
one less than its square. We can express these properties as functions to be
used with <tt class="docutils literal">improve</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">golden_update</span><span class="p">(</span><span class="n">guess</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">guess</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square_close_to_successor</span><span class="p">(</span><span class="n">guess</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">approx_eq</span><span class="p">(</span><span class="n">guess</span> <span class="o">*</span> <span class="n">guess</span><span class="p">,</span> <span class="n">guess</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

<p>Above, we introduce a call to <tt class="docutils literal">approx_eq</tt> that is meant to return <tt class="docutils literal">True</tt> if
its arguments are approximately equal to each other. To implement,
<tt class="docutils literal">approx_eq</tt>, we can compare the absolute value of the difference between
two numbers to a small tolerance value.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">approx_eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span>
</pre></div>

<p>Calling <tt class="docutils literal">improve</tt> with the arguments <tt class="docutils literal">golden_update</tt> and
<tt class="docutils literal">square_close_to_successor</tt> will compute a finite approximation to the golden
ratio.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">improve</span><span class="p">(</span><span class="n">golden_update</span><span class="p">,</span> <span class="n">square_close_to_successor</span><span class="p">)</span>
<span class="go">1.6180339887498951</span>
</pre></div>

<p>By tracing through the steps of evaluation, we can see how this result is
computed. First, a local frame for <tt class="docutils literal">improve</tt> is constructed with bindings for
<tt class="docutils literal">update</tt>, <tt class="docutils literal">close</tt>, and <tt class="docutils literal">guess</tt>. In the body of <tt class="docutils literal">improve</tt>, the name
<tt class="docutils literal">close</tt> is bound to <tt class="docutils literal">square_close_to_successor</tt>, which is called on the
initial value of <tt class="docutils literal">guess</tt>.  Trace through the rest of the steps to see the
computational process that evolves to compute the golden ratio.</p>
<div class="example" data-output="False" data-showallframelabels="False" data-step="6" id="example_16" style="">
def improve(update, close, guess=1):
    while not close(guess):
        guess = update(guess)
    return guess

def golden_update(guess):
    return 1/guess + 1

def square_close_to_successor(guess):
    return approx_eq(guess * guess,
                     guess + 1)

def approx_eq(x, y, tolerance=1e-3):
    return abs(x - y) &lt; tolerance

phi = improve(golden_update,
              square_close_to_successor)
</div>
<script type="text/javascript">
var example_16_trace = {"code": "def improve(update, close, guess=1):\n    while not close(guess):\n        guess = update(guess)\n    return guess\n\ndef golden_update(guess):\n    return 1/guess + 1\n\ndef square_close_to_successor(guess):\n    return approx_eq(guess * guess,\n                     guess + 1)\n\ndef approx_eq(x, y, tolerance=1e-3):\n    return abs(x - y) < tolerance\n\nphi = improve(golden_update,\n              square_close_to_successor)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"improve": ["REF", 1]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null]}, "line": 6, "ordered_globals": ["improve"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"golden_update": ["REF", 2], "improve": ["REF", 1]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null]}, "line": 9, "ordered_globals": ["improve", "golden_update"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null]}, "line": 13, "ordered_globals": ["improve", "golden_update", "square_close_to_successor"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 16, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 17, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 1, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 2, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 9, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1}, "frame_id": 2, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 10, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1}, "frame_id": 2, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1}, "frame_id": 2, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f2"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 13, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1}, "frame_id": 2, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f2"}, {"encoded_locals": {"tolerance": 0.001, "x": 1, "y": 2}, "frame_id": 3, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1}, "frame_id": 2, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f2"}, {"encoded_locals": {"tolerance": 0.001, "x": 1, "y": 2}, "frame_id": 3, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f3"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1}, "frame_id": 2, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f2"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 1, "y": 2}, "frame_id": 3, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f3"}], "stdout": ""}, {"event": "return", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": false, "guess": 1}, "frame_id": 2, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 3, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 6, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1}, "frame_id": 4, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1}, "frame_id": 4, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f4"}], "stdout": ""}, {"event": "return", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": ["SPECIAL_FLOAT", "2.0"], "guess": 1}, "frame_id": 4, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "golden_update_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 2, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": ["SPECIAL_FLOAT", "2.0"], "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 9, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": ["SPECIAL_FLOAT", "2.0"], "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": ["SPECIAL_FLOAT", "2.0"]}, "frame_id": 5, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f5"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 10, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": ["SPECIAL_FLOAT", "2.0"], "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": ["SPECIAL_FLOAT", "2.0"]}, "frame_id": 5, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f5"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": ["SPECIAL_FLOAT", "2.0"], "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": ["SPECIAL_FLOAT", "2.0"]}, "frame_id": 5, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f5"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 13, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": ["SPECIAL_FLOAT", "2.0"], "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": ["SPECIAL_FLOAT", "2.0"]}, "frame_id": 5, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f5"}, {"encoded_locals": {"tolerance": 0.001, "x": ["SPECIAL_FLOAT", "4.0"], "y": ["SPECIAL_FLOAT", "3.0"]}, "frame_id": 6, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f6"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": ["SPECIAL_FLOAT", "2.0"], "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": ["SPECIAL_FLOAT", "2.0"]}, "frame_id": 5, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f5"}, {"encoded_locals": {"tolerance": 0.001, "x": ["SPECIAL_FLOAT", "4.0"], "y": ["SPECIAL_FLOAT", "3.0"]}, "frame_id": 6, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f6"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": ["SPECIAL_FLOAT", "2.0"], "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": ["SPECIAL_FLOAT", "2.0"]}, "frame_id": 5, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f5"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": ["SPECIAL_FLOAT", "4.0"], "y": ["SPECIAL_FLOAT", "3.0"]}, "frame_id": 6, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f6"}], "stdout": ""}, {"event": "return", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": ["SPECIAL_FLOAT", "2.0"], "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": false, "guess": ["SPECIAL_FLOAT", "2.0"]}, "frame_id": 5, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f5"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 3, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": ["SPECIAL_FLOAT", "2.0"], "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 6, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": ["SPECIAL_FLOAT", "2.0"], "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": ["SPECIAL_FLOAT", "2.0"]}, "frame_id": 7, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f7"}], "stdout": ""}, {"event": "step_line", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": ["SPECIAL_FLOAT", "2.0"], "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": ["SPECIAL_FLOAT", "2.0"]}, "frame_id": 7, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f7"}], "stdout": ""}, {"event": "return", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": ["SPECIAL_FLOAT", "2.0"], "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": 1.5, "guess": ["SPECIAL_FLOAT", "2.0"]}, "frame_id": 7, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "golden_update_f7"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 2, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.5, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 9, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.5, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.5}, "frame_id": 8, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f8"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 10, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.5, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.5}, "frame_id": 8, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f8"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.5, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.5}, "frame_id": 8, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f8"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 13, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.5, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.5}, "frame_id": 8, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f8"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.25, "y": 2.5}, "frame_id": 9, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f9"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.5, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.5}, "frame_id": 8, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f8"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.25, "y": 2.5}, "frame_id": 9, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f9"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.5, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.5}, "frame_id": 8, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f8"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 2.25, "y": 2.5}, "frame_id": 9, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f9"}], "stdout": ""}, {"event": "return", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.5, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": false, "guess": 1.5}, "frame_id": 8, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f8"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 3, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.5, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 6, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.5, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.5}, "frame_id": 10, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f10"}], "stdout": ""}, {"event": "step_line", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.5, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.5}, "frame_id": 10, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f10"}], "stdout": ""}, {"event": "return", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.5, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": 1.6667, "guess": 1.5}, "frame_id": 10, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "golden_update_f10"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 2, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6667, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 9, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6667, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6667}, "frame_id": 11, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f11"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 10, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6667, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6667}, "frame_id": 11, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f11"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6667, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6667}, "frame_id": 11, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f11"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 13, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6667, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6667}, "frame_id": 11, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f11"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.7778, "y": 2.6667}, "frame_id": 12, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f12"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6667, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6667}, "frame_id": 11, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f11"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.7778, "y": 2.6667}, "frame_id": 12, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f12"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6667, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6667}, "frame_id": 11, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f11"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 2.7778, "y": 2.6667}, "frame_id": 12, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f12"}], "stdout": ""}, {"event": "return", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6667, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": false, "guess": 1.6667}, "frame_id": 11, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f11"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 3, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6667, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 6, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6667, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6667}, "frame_id": 13, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f13"}], "stdout": ""}, {"event": "step_line", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6667, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6667}, "frame_id": 13, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f13"}], "stdout": ""}, {"event": "return", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6667, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": 1.6, "guess": 1.6667}, "frame_id": 13, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "golden_update_f13"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 2, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 9, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6}, "frame_id": 14, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f14"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 10, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6}, "frame_id": 14, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f14"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6}, "frame_id": 14, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f14"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 13, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6}, "frame_id": 14, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f14"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.56, "y": 2.6}, "frame_id": 15, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f15"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6}, "frame_id": 14, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f14"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.56, "y": 2.6}, "frame_id": 15, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f15"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6}, "frame_id": 14, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f14"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 2.56, "y": 2.6}, "frame_id": 15, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f15"}], "stdout": ""}, {"event": "return", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": false, "guess": 1.6}, "frame_id": 14, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f14"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 3, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 6, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6}, "frame_id": 16, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f16"}], "stdout": ""}, {"event": "step_line", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6}, "frame_id": 16, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f16"}], "stdout": ""}, {"event": "return", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": 1.625, "guess": 1.6}, "frame_id": 16, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "golden_update_f16"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 2, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.625, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 9, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.625, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.625}, "frame_id": 17, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f17"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 10, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.625, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.625}, "frame_id": 17, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f17"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.625, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.625}, "frame_id": 17, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f17"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 13, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.625, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.625}, "frame_id": 17, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f17"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.6406, "y": 2.625}, "frame_id": 18, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f18"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.625, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.625}, "frame_id": 17, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f17"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.6406, "y": 2.625}, "frame_id": 18, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f18"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.625, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.625}, "frame_id": 17, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f17"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 2.6406, "y": 2.625}, "frame_id": 18, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f18"}], "stdout": ""}, {"event": "return", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.625, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": false, "guess": 1.625}, "frame_id": 17, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f17"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 3, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.625, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 6, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.625, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.625}, "frame_id": 19, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f19"}], "stdout": ""}, {"event": "step_line", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.625, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.625}, "frame_id": 19, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f19"}], "stdout": ""}, {"event": "return", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.625, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": 1.6154, "guess": 1.625}, "frame_id": 19, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "golden_update_f19"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 2, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6154, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 9, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6154, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6154}, "frame_id": 20, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f20"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 10, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6154, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6154}, "frame_id": 20, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f20"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6154, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6154}, "frame_id": 20, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f20"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 13, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6154, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6154}, "frame_id": 20, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f20"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.6095, "y": 2.6154}, "frame_id": 21, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f21"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6154, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6154}, "frame_id": 20, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f20"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.6095, "y": 2.6154}, "frame_id": 21, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f21"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6154, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6154}, "frame_id": 20, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f20"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 2.6095, "y": 2.6154}, "frame_id": 21, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f21"}], "stdout": ""}, {"event": "return", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6154, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": false, "guess": 1.6154}, "frame_id": 20, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f20"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 3, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6154, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 6, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6154, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6154}, "frame_id": 22, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f22"}], "stdout": ""}, {"event": "step_line", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6154, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6154}, "frame_id": 22, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f22"}], "stdout": ""}, {"event": "return", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6154, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": 1.619, "guess": 1.6154}, "frame_id": 22, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "golden_update_f22"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 2, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.619, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 9, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.619, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.619}, "frame_id": 23, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f23"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 10, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.619, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.619}, "frame_id": 23, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f23"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.619, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.619}, "frame_id": 23, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f23"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 13, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.619, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.619}, "frame_id": 23, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f23"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.6213, "y": 2.619}, "frame_id": 24, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f24"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.619, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.619}, "frame_id": 23, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f23"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.6213, "y": 2.619}, "frame_id": 24, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f24"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.619, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.619}, "frame_id": 23, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f23"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 2.6213, "y": 2.619}, "frame_id": 24, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f24"}], "stdout": ""}, {"event": "return", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.619, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": false, "guess": 1.619}, "frame_id": 23, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f23"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 3, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.619, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 6, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.619, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.619}, "frame_id": 25, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f25"}], "stdout": ""}, {"event": "step_line", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.619, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.619}, "frame_id": 25, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "golden_update_f25"}], "stdout": ""}, {"event": "return", "func_name": "golden_update", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 7, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.619, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": 1.6176, "guess": 1.619}, "frame_id": 25, "func_name": "golden_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "golden_update_f25"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 2, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6176, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "call", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 9, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6176, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6176}, "frame_id": 26, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f26"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 10, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6176, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6176}, "frame_id": 26, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f26"}], "stdout": ""}, {"event": "step_line", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6176, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6176}, "frame_id": 26, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f26"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 13, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6176, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6176}, "frame_id": 26, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f26"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.6168, "y": 2.6176}, "frame_id": 27, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f27"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6176, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6176}, "frame_id": 26, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f26"}, {"encoded_locals": {"tolerance": 0.001, "x": 2.6168, "y": 2.6176}, "frame_id": 27, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f27"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 14, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6176, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"guess": 1.6176}, "frame_id": 26, "func_name": "square_close_to_successor", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f26"}, {"encoded_locals": {"__return__": true, "tolerance": 0.001, "x": 2.6168, "y": 2.6176}, "frame_id": 27, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f27"}], "stdout": ""}, {"event": "return", "func_name": "square_close_to_successor", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 11, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6176, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}, {"encoded_locals": {"__return__": true, "guess": 1.6176}, "frame_id": 26, "func_name": "square_close_to_successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_close_to_successor_f26"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 4, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"close": ["REF", 3], "guess": 1.6176, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "return", "func_name": "improve", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 4, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq"], "stack_to_render": [{"encoded_locals": {"__return__": 1.6176, "close": ["REF", 3], "guess": 1.6176, "update": ["REF", 2]}, "frame_id": 1, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "improve_f1"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"approx_eq": ["REF", 4], "golden_update": ["REF", 2], "improve": ["REF", 1], "phi": 1.6176, "square_close_to_successor": ["REF", 3]}, "heap": {"1": ["FUNCTION", "improve(update, close, guess)", null], "2": ["FUNCTION", "golden_update(guess)", null], "3": ["FUNCTION", "square_close_to_successor(guess)", null], "4": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 17, "ordered_globals": ["improve", "golden_update", "square_close_to_successor", "approx_eq", "phi"], "stack_to_render": [], "stdout": ""}]}</script><p>This example illustrates two related big ideas in computer science. First,
naming and functions allow us to abstract away a vast amount of complexity.
While each function definition has been trivial, the computational process set
in motion by our evaluation procedure is quite intricate. Second, it is only by
virtue of the fact that we have an extremely general evaluation procedure for
the Python language that small components can be composed into complex
processes. Understanding the procedure of interpreting programs allows us to
validate and inspect the process we have created.</p>
<p>As always, our new general method <tt class="docutils literal">improve</tt> needs a test to check its
correctness. The golden ratio can provide such a test, because it also has an
exact closed-form solution, which we can compare to this iterative result.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">improve_test</span><span class="p">():</span>
<span class="gp">    </span>    <span class="n">approx_phi</span> <span class="o">=</span> <span class="n">improve</span><span class="p">(</span><span class="n">golden_update</span><span class="p">,</span> <span class="n">square_close_to_successor</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">approx_eq</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">approx_phi</span><span class="p">),</span> <span class="s1">'phi differs from its approximation'</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">improve_test</span><span class="p">()</span>
</pre></div>

<p>For this test, no news is good news: <tt class="docutils literal">improve_test</tt> returns <tt class="docutils literal">None</tt> after its
<tt class="docutils literal">assert</tt> statement is executed successfully.</p>
</div>
<div class="section" id="defining-functions-iii-nested-definitions">
<h3>1.6.3   Defining Functions III: Nested Definitions</h3>
<p>The above examples demonstrate how the ability to pass functions as arguments
significantly enhances the expressive power of our programming language. Each
general concept or equation maps onto its own short function. One negative
consequence of this approach is that the global frame becomes cluttered with
names of small functions, which must all be unique. Another problem is that we
are constrained by particular function signatures: the <tt class="docutils literal">update</tt> argument to
<tt class="docutils literal">improve</tt> must take exactly one argument. Nested function definitions address
both of these problems, but require us to enrich our environment model.</p>
<p>Let's consider a new problem: computing the square root of a number. In
programming languages, "square root" is often abbreviated as <tt class="docutils literal">sqrt</tt>. Repeated
application of the following update converges to the square root of <tt class="docutils literal">a</tt>:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sqrt_update</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">average</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
</pre></div>

<p>This two-argument update function is incompatible with <tt class="docutils literal">improve</tt> (it takes
two arguments, not one), and it provides only a single update, while we really
care about taking square roots by repeated updates. The solution to both of
these issues is to place function definitions inside the body of other
definitions.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">sqrt_update</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">average</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">sqrt_close</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">approx_eq</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">improve</span><span class="p">(</span><span class="n">sqrt_update</span><span class="p">,</span> <span class="n">sqrt_close</span><span class="p">)</span>
</pre></div>

<p>Like local assignment, local <tt class="docutils literal">def</tt> statements only affect the current local
frame. These functions are only in scope while <tt class="docutils literal">sqrt</tt> is being evaluated.
Consistent with our evaluation procedure, these local <tt class="docutils literal">def</tt> statements don't
even get evaluated until <tt class="docutils literal">sqrt</tt> is called.</p>
<p><strong>Lexical scope.</strong> Locally defined functions also have access to the name
bindings in the scope in which they are defined. In this example,
<tt class="docutils literal">sqrt_update</tt> refers to the name <tt class="docutils literal">a</tt>, which is a formal parameter of its
enclosing function <tt class="docutils literal">sqrt</tt>. This discipline of sharing names among nested
definitions is called <em>lexical scoping</em>. Critically, the inner functions have
access to the names in the environment where they are defined (not where they
are called).</p>
<p>We require two extensions to our environment model to enable lexical scoping.</p>
<ol class="arabic simple">
<li>Each user-defined function has a parent environment: the environment in
which it was defined.</li>
<li>When a user-defined function is called, its local frame extends its parent
environment.</li>
</ol>
<p>Previous to <tt class="docutils literal">sqrt</tt>, all functions were defined in the global environment,
and so they all had the same parent: the global environment.  By contrast, when
Python evaluates the first two clauses of <tt class="docutils literal">sqrt</tt>, it create functions that
are associated with a local environment. In the call</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span>
<span class="go">16.0</span>
</pre></div>

<p>the environment first adds a local frame for <tt class="docutils literal">sqrt</tt> and evaluates the
<tt class="docutils literal">def</tt> statements for <tt class="docutils literal">sqrt_update</tt> and <tt class="docutils literal">sqrt_close</tt>.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="7" id="example_17" style="">
def average(x, y):
    return (x + y)/2

def improve(update, close, guess=1):
    while not close(guess):
        guess = update(guess)
    return guess

def approx_eq(x, y, tolerance=1e-3):
    return abs(x - y) &lt; tolerance

def sqrt(a):
    def sqrt_update(x):
        return average(x, a/x)
    def sqrt_close(x):
        return approx_eq(x * x, a)
    return improve(sqrt_update, sqrt_close)

result = sqrt(256)
</div>
<script type="text/javascript">
var example_17_trace = {"code": "def average(x, y):\n    return (x + y)/2\n\ndef improve(update, close, guess=1):\n    while not close(guess):\n        guess = update(guess)\n    return guess\n\ndef approx_eq(x, y, tolerance=1e-3):\n    return abs(x - y) < tolerance\n\ndef sqrt(a):\n    def sqrt_update(x):\n        return average(x, a/x)\n    def sqrt_close(x):\n        return approx_eq(x * x, a)\n    return improve(sqrt_update, sqrt_close)\n\nresult = sqrt(256)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"average": ["REF", 1]}, "heap": {"1": ["FUNCTION", "average(x, y)", null]}, "line": 4, "ordered_globals": ["average"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"average": ["REF", 1], "improve": ["REF", 2]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null]}, "line": 9, "ordered_globals": ["average", "improve"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 12, "ordered_globals": ["average", "improve", "approx_eq"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null]}, "line": 19, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "sqrt", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null]}, "line": 12, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["a"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["a"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 17, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}], "stdout": ""}, {"event": "call", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 4, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 3, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 3, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f3"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 3, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f3"}, {"encoded_locals": {"tolerance": 0.001, "x": 1, "y": 256}, "frame_id": 4, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 3, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f3"}, {"encoded_locals": {"tolerance": 0.001, "x": 1, "y": 256}, "frame_id": 4, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f4"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 3, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f3"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 1, "y": 256}, "frame_id": 4, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f4"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 1}, "frame_id": 3, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 5, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f5"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 5, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f5"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 5, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f5"}, {"encoded_locals": {"x": 1, "y": ["SPECIAL_FLOAT", "256.0"]}, "frame_id": 6, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f6"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 5, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f5"}, {"encoded_locals": {"x": 1, "y": ["SPECIAL_FLOAT", "256.0"]}, "frame_id": 6, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f6"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 5, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f5"}, {"encoded_locals": {"__return__": 128.5, "x": 1, "y": ["SPECIAL_FLOAT", "256.0"]}, "frame_id": 6, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f6"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 128.5, "x": 1}, "frame_id": 5, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f5"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 7, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f7"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 7, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f7"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 7, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f7"}, {"encoded_locals": {"tolerance": 0.001, "x": 16512.25, "y": 256}, "frame_id": 8, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f8"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 7, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f7"}, {"encoded_locals": {"tolerance": 0.001, "x": 16512.25, "y": 256}, "frame_id": 8, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f8"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 7, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f7"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 16512.25, "y": 256}, "frame_id": 8, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f8"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 128.5}, "frame_id": 7, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f7"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 9, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f9"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 9, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f9"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 9, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f9"}, {"encoded_locals": {"x": 128.5, "y": 1.9922}, "frame_id": 10, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f10"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 9, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f9"}, {"encoded_locals": {"x": 128.5, "y": 1.9922}, "frame_id": 10, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f10"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 9, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f9"}, {"encoded_locals": {"__return__": 65.2461, "x": 128.5, "y": 1.9922}, "frame_id": 10, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f10"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 65.2461, "x": 128.5}, "frame_id": 9, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f9"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 11, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f11"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 11, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f11"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 11, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f11"}, {"encoded_locals": {"tolerance": 0.001, "x": 4257.0547, "y": 256}, "frame_id": 12, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f12"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 11, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f11"}, {"encoded_locals": {"tolerance": 0.001, "x": 4257.0547, "y": 256}, "frame_id": 12, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f12"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 11, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f11"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 4257.0547, "y": 256}, "frame_id": 12, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f12"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 65.2461}, "frame_id": 11, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f11"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 13, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f13"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 13, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f13"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 13, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f13"}, {"encoded_locals": {"x": 65.2461, "y": 3.9236}, "frame_id": 14, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f14"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 13, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f13"}, {"encoded_locals": {"x": 65.2461, "y": 3.9236}, "frame_id": 14, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f14"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 13, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f13"}, {"encoded_locals": {"__return__": 34.5849, "x": 65.2461, "y": 3.9236}, "frame_id": 14, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f14"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 34.5849, "x": 65.2461}, "frame_id": 13, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f13"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 15, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f15"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 15, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f15"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 15, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f15"}, {"encoded_locals": {"tolerance": 0.001, "x": 1196.1124, "y": 256}, "frame_id": 16, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f16"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 15, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f15"}, {"encoded_locals": {"tolerance": 0.001, "x": 1196.1124, "y": 256}, "frame_id": 16, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f16"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 15, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f15"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 1196.1124, "y": 256}, "frame_id": 16, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f16"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 34.5849}, "frame_id": 15, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f15"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 17, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f17"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 17, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f17"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 17, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f17"}, {"encoded_locals": {"x": 34.5849, "y": 7.4021}, "frame_id": 18, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f18"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 17, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f17"}, {"encoded_locals": {"x": 34.5849, "y": 7.4021}, "frame_id": 18, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f18"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 17, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f17"}, {"encoded_locals": {"__return__": 20.9935, "x": 34.5849, "y": 7.4021}, "frame_id": 18, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f18"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 20.9935, "x": 34.5849}, "frame_id": 17, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f17"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 19, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f19"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 19, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f19"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 19, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f19"}, {"encoded_locals": {"tolerance": 0.001, "x": 440.7258, "y": 256}, "frame_id": 20, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f20"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 19, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f19"}, {"encoded_locals": {"tolerance": 0.001, "x": 440.7258, "y": 256}, "frame_id": 20, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f20"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 19, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f19"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 440.7258, "y": 256}, "frame_id": 20, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f20"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 20.9935}, "frame_id": 19, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f19"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 21, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f21"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 21, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f21"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 21, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f21"}, {"encoded_locals": {"x": 20.9935, "y": 12.1943}, "frame_id": 22, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f22"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 21, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f21"}, {"encoded_locals": {"x": 20.9935, "y": 12.1943}, "frame_id": 22, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f22"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 21, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f21"}, {"encoded_locals": {"__return__": 16.5939, "x": 20.9935, "y": 12.1943}, "frame_id": 22, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f22"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 16.5939, "x": 20.9935}, "frame_id": 21, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f21"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 23, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f23"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 23, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f23"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 23, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f23"}, {"encoded_locals": {"tolerance": 0.001, "x": 275.3565, "y": 256}, "frame_id": 24, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f24"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 23, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f23"}, {"encoded_locals": {"tolerance": 0.001, "x": 275.3565, "y": 256}, "frame_id": 24, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f24"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 23, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f23"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 275.3565, "y": 256}, "frame_id": 24, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f24"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 16.5939}, "frame_id": 23, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f23"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 25, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f25"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 25, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f25"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 25, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f25"}, {"encoded_locals": {"x": 16.5939, "y": 15.4274}, "frame_id": 26, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f26"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 25, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f25"}, {"encoded_locals": {"x": 16.5939, "y": 15.4274}, "frame_id": 26, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f26"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 25, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f25"}, {"encoded_locals": {"__return__": 16.0106, "x": 16.5939, "y": 15.4274}, "frame_id": 26, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f26"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 16.0106, "x": 16.5939}, "frame_id": 25, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f25"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 27, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f27"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 27, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f27"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 27, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f27"}, {"encoded_locals": {"tolerance": 0.001, "x": 256.3402, "y": 256}, "frame_id": 28, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f28"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 27, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f27"}, {"encoded_locals": {"tolerance": 0.001, "x": 256.3402, "y": 256}, "frame_id": 28, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f28"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 27, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f27"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 256.3402, "y": 256}, "frame_id": 28, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f28"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 16.0106}, "frame_id": 27, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f27"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 29, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f29"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 29, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f29"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 29, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f29"}, {"encoded_locals": {"x": 16.0106, "y": 15.9894}, "frame_id": 30, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f30"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 29, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f29"}, {"encoded_locals": {"x": 16.0106, "y": 15.9894}, "frame_id": 30, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f30"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 29, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f29"}, {"encoded_locals": {"__return__": 16.0, "x": 16.0106, "y": 15.9894}, "frame_id": 30, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f30"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 16.0, "x": 16.0106}, "frame_id": 29, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f29"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0}, "frame_id": 31, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f31"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0}, "frame_id": 31, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f31"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0}, "frame_id": 31, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f31"}, {"encoded_locals": {"tolerance": 0.001, "x": 256.0001, "y": 256}, "frame_id": 32, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f32"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0}, "frame_id": 31, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f31"}, {"encoded_locals": {"tolerance": 0.001, "x": 256.0001, "y": 256}, "frame_id": 32, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f32"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0}, "frame_id": 31, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f31"}, {"encoded_locals": {"__return__": true, "tolerance": 0.001, "x": 256.0001, "y": 256}, "frame_id": 32, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f32"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": true, "x": 16.0}, "frame_id": 31, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f31"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 7, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "return", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 7, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"__return__": 16.0, "close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "return", "func_name": "sqrt", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 17, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"__return__": 16.0, "a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close", "__return__"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "result": 16.0, "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 19, "ordered_globals": ["average", "improve", "approx_eq", "sqrt", "result"], "stack_to_render": [{"encoded_locals": {"__return__": 16.0, "a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["a", "sqrt_update", "sqrt_close", "__return__"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p_z"}], "stdout": ""}]}</script><p>Function values each have a new annotation that we will include in environment
diagrams from now on, a <em>parent</em>.  The parent of a function value is the first
frame of the environment in which that function was defined.  Functions without
parent annotations were defined in the global environment.  When a user-defined
function is called, the frame created has the same parent as that function.</p>
<p>Subsequently, the name <tt class="docutils literal">sqrt_update</tt> resolves to this newly defined function,
which is passed as an argument to <tt class="docutils literal">improve</tt>. Within the body of
<tt class="docutils literal">improve</tt>, we must apply our <tt class="docutils literal">update</tt> function (bound to <tt class="docutils literal">sqrt_update</tt>)
to the initial guess <tt class="docutils literal">x</tt> of 1. This final application creates an environment
for <tt class="docutils literal">sqrt_update</tt> that begins with a local frame containing only <tt class="docutils literal">x</tt>,
but with the parent frame <tt class="docutils literal">sqrt</tt> still containing a binding for <tt class="docutils literal">a</tt>.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="14" id="example_18" style="">
def average(x, y):
    return (x + y)/2

def improve(update, close, guess=1):
    while not close(guess):
        guess = update(guess)
    return guess

def approx_eq(x, y, tolerance=1e-3):
    return abs(x - y) &lt; tolerance

def sqrt(a):
    def sqrt_update(x):
        return average(x, a/x)
    def sqrt_close(x):
        return approx_eq(x * x, a)
    return improve(sqrt_update, sqrt_close)

result = sqrt(256)
</div>
<script type="text/javascript">
var example_18_trace = {"code": "def average(x, y):\n    return (x + y)/2\n\ndef improve(update, close, guess=1):\n    while not close(guess):\n        guess = update(guess)\n    return guess\n\ndef approx_eq(x, y, tolerance=1e-3):\n    return abs(x - y) < tolerance\n\ndef sqrt(a):\n    def sqrt_update(x):\n        return average(x, a/x)\n    def sqrt_close(x):\n        return approx_eq(x * x, a)\n    return improve(sqrt_update, sqrt_close)\n\nresult = sqrt(256)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"average": ["REF", 1]}, "heap": {"1": ["FUNCTION", "average(x, y)", null]}, "line": 4, "ordered_globals": ["average"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"average": ["REF", 1], "improve": ["REF", 2]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null]}, "line": 9, "ordered_globals": ["average", "improve"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null]}, "line": 12, "ordered_globals": ["average", "improve", "approx_eq"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null]}, "line": 19, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "sqrt", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null]}, "line": 12, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["a"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["a"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 17, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}], "stdout": ""}, {"event": "call", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 4, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 3, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 3, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f3"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 3, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f3"}, {"encoded_locals": {"tolerance": 0.001, "x": 1, "y": 256}, "frame_id": 4, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 3, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f3"}, {"encoded_locals": {"tolerance": 0.001, "x": 1, "y": 256}, "frame_id": 4, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f4"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 3, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f3"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 1, "y": 256}, "frame_id": 4, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f4"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 1}, "frame_id": 3, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 5, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f5"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 5, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f5"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 5, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f5"}, {"encoded_locals": {"x": 1, "y": ["SPECIAL_FLOAT", "256.0"]}, "frame_id": 6, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f6"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 5, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f5"}, {"encoded_locals": {"x": 1, "y": ["SPECIAL_FLOAT", "256.0"]}, "frame_id": 6, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f6"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 1}, "frame_id": 5, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f5"}, {"encoded_locals": {"__return__": 128.5, "x": 1, "y": ["SPECIAL_FLOAT", "256.0"]}, "frame_id": 6, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f6"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 1, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 128.5, "x": 1}, "frame_id": 5, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f5"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 7, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f7"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 7, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f7"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 7, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f7"}, {"encoded_locals": {"tolerance": 0.001, "x": 16512.25, "y": 256}, "frame_id": 8, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f8"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 7, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f7"}, {"encoded_locals": {"tolerance": 0.001, "x": 16512.25, "y": 256}, "frame_id": 8, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f8"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 7, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f7"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 16512.25, "y": 256}, "frame_id": 8, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f8"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 128.5}, "frame_id": 7, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f7"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 9, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f9"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 9, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f9"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 9, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f9"}, {"encoded_locals": {"x": 128.5, "y": 1.9922}, "frame_id": 10, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f10"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 9, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f9"}, {"encoded_locals": {"x": 128.5, "y": 1.9922}, "frame_id": 10, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f10"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 128.5}, "frame_id": 9, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f9"}, {"encoded_locals": {"__return__": 65.2461, "x": 128.5, "y": 1.9922}, "frame_id": 10, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f10"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 128.5, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 65.2461, "x": 128.5}, "frame_id": 9, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f9"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 11, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f11"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 11, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f11"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 11, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f11"}, {"encoded_locals": {"tolerance": 0.001, "x": 4257.0547, "y": 256}, "frame_id": 12, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f12"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 11, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f11"}, {"encoded_locals": {"tolerance": 0.001, "x": 4257.0547, "y": 256}, "frame_id": 12, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f12"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 11, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f11"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 4257.0547, "y": 256}, "frame_id": 12, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f12"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 65.2461}, "frame_id": 11, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f11"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 13, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f13"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 13, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f13"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 13, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f13"}, {"encoded_locals": {"x": 65.2461, "y": 3.9236}, "frame_id": 14, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f14"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 13, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f13"}, {"encoded_locals": {"x": 65.2461, "y": 3.9236}, "frame_id": 14, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f14"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 65.2461}, "frame_id": 13, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f13"}, {"encoded_locals": {"__return__": 34.5849, "x": 65.2461, "y": 3.9236}, "frame_id": 14, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f14"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 65.2461, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 34.5849, "x": 65.2461}, "frame_id": 13, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f13"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 15, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f15"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 15, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f15"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 15, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f15"}, {"encoded_locals": {"tolerance": 0.001, "x": 1196.1124, "y": 256}, "frame_id": 16, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f16"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 15, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f15"}, {"encoded_locals": {"tolerance": 0.001, "x": 1196.1124, "y": 256}, "frame_id": 16, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f16"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 15, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f15"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 1196.1124, "y": 256}, "frame_id": 16, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f16"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 34.5849}, "frame_id": 15, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f15"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 17, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f17"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 17, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f17"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 17, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f17"}, {"encoded_locals": {"x": 34.5849, "y": 7.4021}, "frame_id": 18, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f18"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 17, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f17"}, {"encoded_locals": {"x": 34.5849, "y": 7.4021}, "frame_id": 18, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f18"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 34.5849}, "frame_id": 17, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f17"}, {"encoded_locals": {"__return__": 20.9935, "x": 34.5849, "y": 7.4021}, "frame_id": 18, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f18"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 34.5849, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 20.9935, "x": 34.5849}, "frame_id": 17, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f17"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 19, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f19"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 19, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f19"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 19, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f19"}, {"encoded_locals": {"tolerance": 0.001, "x": 440.7258, "y": 256}, "frame_id": 20, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f20"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 19, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f19"}, {"encoded_locals": {"tolerance": 0.001, "x": 440.7258, "y": 256}, "frame_id": 20, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f20"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 19, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f19"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 440.7258, "y": 256}, "frame_id": 20, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f20"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 20.9935}, "frame_id": 19, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f19"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 21, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f21"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 21, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f21"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 21, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f21"}, {"encoded_locals": {"x": 20.9935, "y": 12.1943}, "frame_id": 22, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f22"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 21, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f21"}, {"encoded_locals": {"x": 20.9935, "y": 12.1943}, "frame_id": 22, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f22"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 20.9935}, "frame_id": 21, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f21"}, {"encoded_locals": {"__return__": 16.5939, "x": 20.9935, "y": 12.1943}, "frame_id": 22, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f22"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 20.9935, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 16.5939, "x": 20.9935}, "frame_id": 21, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f21"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 23, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f23"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 23, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f23"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 23, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f23"}, {"encoded_locals": {"tolerance": 0.001, "x": 275.3565, "y": 256}, "frame_id": 24, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f24"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 23, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f23"}, {"encoded_locals": {"tolerance": 0.001, "x": 275.3565, "y": 256}, "frame_id": 24, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f24"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 23, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f23"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 275.3565, "y": 256}, "frame_id": 24, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f24"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 16.5939}, "frame_id": 23, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f23"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 25, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f25"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 25, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f25"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 25, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f25"}, {"encoded_locals": {"x": 16.5939, "y": 15.4274}, "frame_id": 26, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f26"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 25, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f25"}, {"encoded_locals": {"x": 16.5939, "y": 15.4274}, "frame_id": 26, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f26"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.5939}, "frame_id": 25, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f25"}, {"encoded_locals": {"__return__": 16.0106, "x": 16.5939, "y": 15.4274}, "frame_id": 26, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f26"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.5939, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 16.0106, "x": 16.5939}, "frame_id": 25, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f25"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 27, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f27"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 27, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f27"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 27, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f27"}, {"encoded_locals": {"tolerance": 0.001, "x": 256.3402, "y": 256}, "frame_id": 28, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f28"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 27, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f27"}, {"encoded_locals": {"tolerance": 0.001, "x": 256.3402, "y": 256}, "frame_id": 28, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f28"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 27, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f27"}, {"encoded_locals": {"__return__": false, "tolerance": 0.001, "x": 256.3402, "y": 256}, "frame_id": 28, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f28"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": false, "x": 16.0106}, "frame_id": 27, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f27"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 6, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 13, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 29, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f29"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 29, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f29"}], "stdout": ""}, {"event": "call", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 1, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 29, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f29"}, {"encoded_locals": {"x": 16.0106, "y": 15.9894}, "frame_id": 30, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f30"}], "stdout": ""}, {"event": "step_line", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 29, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f29"}, {"encoded_locals": {"x": 16.0106, "y": 15.9894}, "frame_id": 30, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y"], "parent_frame_id_list": [], "unique_hash": "average_f30"}], "stdout": ""}, {"event": "return", "func_name": "average", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 2, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0106}, "frame_id": 29, "func_name": "sqrt_update", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f29"}, {"encoded_locals": {"__return__": 16.0, "x": 16.0106, "y": 15.9894}, "frame_id": 30, "func_name": "average", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "__return__"], "parent_frame_id_list": [], "unique_hash": "average_f30"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_update", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 14, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0106, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": 16.0, "x": 16.0106}, "frame_id": 29, "func_name": "sqrt_update", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_update_f29"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 5, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "call", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 15, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0}, "frame_id": 31, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f31"}], "stdout": ""}, {"event": "step_line", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0}, "frame_id": 31, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f31"}], "stdout": ""}, {"event": "call", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 9, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0}, "frame_id": 31, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f31"}, {"encoded_locals": {"tolerance": 0.001, "x": 256.0001, "y": 256}, "frame_id": 32, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f32"}], "stdout": ""}, {"event": "step_line", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0}, "frame_id": 31, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f31"}, {"encoded_locals": {"tolerance": 0.001, "x": 256.0001, "y": 256}, "frame_id": 32, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f32"}], "stdout": ""}, {"event": "return", "func_name": "approx_eq", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 10, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"x": 16.0}, "frame_id": 31, "func_name": "sqrt_close", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f31"}, {"encoded_locals": {"__return__": true, "tolerance": 0.001, "x": 256.0001, "y": 256}, "frame_id": 32, "func_name": "approx_eq", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "y", "tolerance", "__return__"], "parent_frame_id_list": [], "unique_hash": "approx_eq_f32"}], "stdout": ""}, {"event": "return", "func_name": "sqrt_close", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 16, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}, {"encoded_locals": {"__return__": true, "x": 16.0}, "frame_id": 31, "func_name": "sqrt_close", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "sqrt_close_f31"}], "stdout": ""}, {"event": "step_line", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 7, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "return", "func_name": "improve", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 7, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}, {"encoded_locals": {"__return__": 16.0, "close": ["REF", 6], "guess": 16.0, "update": ["REF", 5]}, "frame_id": 2, "func_name": "improve", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["update", "close", "guess", "__return__"], "parent_frame_id_list": [], "unique_hash": "improve_f2"}], "stdout": ""}, {"event": "return", "func_name": "sqrt", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 17, "ordered_globals": ["average", "improve", "approx_eq", "sqrt"], "stack_to_render": [{"encoded_locals": {"__return__": 16.0, "a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["a", "sqrt_update", "sqrt_close", "__return__"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"approx_eq": ["REF", 3], "average": ["REF", 1], "improve": ["REF", 2], "result": 16.0, "sqrt": ["REF", 4]}, "heap": {"1": ["FUNCTION", "average(x, y)", null], "2": ["FUNCTION", "improve(update, close, guess)", null], "3": ["FUNCTION", "approx_eq(x, y, tolerance)", null], "4": ["FUNCTION", "sqrt(a)", null], "5": ["FUNCTION", "sqrt_update(x)", 1], "6": ["FUNCTION", "sqrt_close(x)", 1]}, "line": 19, "ordered_globals": ["average", "improve", "approx_eq", "sqrt", "result"], "stack_to_render": [{"encoded_locals": {"__return__": 16.0, "a": 256, "sqrt_close": ["REF", 6], "sqrt_update": ["REF", 5]}, "frame_id": 1, "func_name": "sqrt", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["a", "sqrt_update", "sqrt_close", "__return__"], "parent_frame_id_list": [], "unique_hash": "sqrt_f1_p_z"}], "stdout": ""}]}</script><p>The most critical part of this evaluation procedure is the transfer of the
parent for <tt class="docutils literal">sqrt_update</tt> to the frame created by calling <tt class="docutils literal">sqrt_update</tt>.
This frame is also annotated with <tt class="docutils literal">[parent=f1]</tt>.</p>
<p><strong>Extended Environments</strong>. An environment can consist of an arbitrarily long
chain of frames, which always concludes with the global frame. Previous to this
<tt class="docutils literal">sqrt</tt> example, environments had at most two frames: a local frame and the
global frame.  By calling functions that were defined within other functions,
via nested <tt class="docutils literal">def</tt> statements, we can create longer chains.  The environment
for this call to <tt class="docutils literal">sqrt_update</tt> consists of three frames: the local
<tt class="docutils literal">sqrt_update</tt> frame, the <tt class="docutils literal">sqrt</tt> frame in which <tt class="docutils literal">sqrt_update</tt> was defined
(labeled <tt class="docutils literal">f1</tt>), and the global frame.</p>
<p>The return expression in the body of <tt class="docutils literal">sqrt_update</tt> can resolve a value for
<tt class="docutils literal">a</tt> by following this chain of frames. Looking up a name finds the
first value bound to that name in the current environment. Python checks first
in the <tt class="docutils literal">sqrt_update</tt> frame -- no <tt class="docutils literal">a</tt> exists.  Python checks next in the
parent frame, <tt class="docutils literal">f1</tt>, and finds a binding for <tt class="docutils literal">a</tt> to 256.</p>
<p>Hence, we realize two key advantages of lexical scoping in Python.</p>
<ul class="simple">
<li>The names of a local function do not interfere with names external to the
function in which it is defined, because the local function name will be bound
in the current local environment in which it was defined, rather than the
global environment.</li>
<li>A local function can access the environment of the enclosing function,
because the body of the local function is evaluated in an environment that
extends the evaluation environment in which it was defined.</li>
</ul>
<p>The <tt class="docutils literal">sqrt_update</tt> function carries with it some data: the value for <tt class="docutils literal">a</tt>
referenced in the environment in which it was defined. Because they "enclose"
information in this way, locally defined functions are often called <em>closures</em>.</p>
</div>
<div class="section" id="functions-as-returned-values">
<h3>1.6.4   Functions as Returned Values</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#aQ9ztlG4ezVs').src &amp;&amp; (document.querySelector('#aQ9ztlG4ezVs').src = 'http://www.youtube.com/embed/Q9ztlG4ezVs?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#aQ9ztlG4ezVs').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#aQ9ztlG4ezVs').style.cssText = 'display:none'; document.querySelector('#aQ9ztlG4ezVs').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="aQ9ztlG4ezVs" style="display:none;" width="640"></iframe>
</div>
<p>We can achieve even more expressive power in our programs by creating functions
whose returned values are themselves functions. An important feature of
lexically scoped programming languages is that locally defined functions
maintain their parent environment when they are returned.  The following
example illustrates the utility of this feature.</p>
<p>Once many simple functions are defined, function <em>composition</em> is a natural
method of combination to include in our programming language. That is, given
two functions <tt class="docutils literal">f(x)</tt> and <tt class="docutils literal">g(x)</tt>, we might want to define <tt class="docutils literal">h(x) =
f(g(x))</tt>. We can define function composition using our existing tools:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compose1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">h</span>
</pre></div>

<p>The environment diagram for this example shows how the names <tt class="docutils literal">f</tt> and <tt class="docutils literal">g</tt>
are resolved correctly, even in the presence of conflicting names.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_19" style="">
def square(x):
    return x * x

def successor(x):
    return x + 1

def compose1(f, g):
    def h(x):
        return f(g(x))
    return h

def f(x):
    """Never called."""
    return -x

square_successor = compose1(square, successor)
result = square_successor(12)
</div>
<script type="text/javascript">
var example_19_trace = {"code": "def square(x):\n    return x * x\n\ndef successor(x):\n    return x + 1\n\ndef compose1(f, g):\n    def h(x):\n        return f(g(x))\n    return h\n\ndef f(x):\n    \"\"\"Never called.\"\"\"\n    return -x\n\nsquare_successor = compose1(square, successor)\nresult = square_successor(12)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"square": ["REF", 1]}, "heap": {"1": ["FUNCTION", "square(x)", null]}, "line": 4, "ordered_globals": ["square"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"square": ["REF", 1], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null]}, "line": 7, "ordered_globals": ["square", "successor"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"compose1": ["REF", 3], "square": ["REF", 1], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null]}, "line": 12, "ordered_globals": ["square", "successor", "compose1"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null]}, "line": 16, "ordered_globals": ["square", "successor", "compose1", "f"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "compose1", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null]}, "line": 7, "ordered_globals": ["square", "successor", "compose1", "f"], "stack_to_render": [{"encoded_locals": {"f": ["REF", 1], "g": ["REF", 2]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["f", "g"], "parent_frame_id_list": [], "unique_hash": "compose1_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "compose1", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null]}, "line": 8, "ordered_globals": ["square", "successor", "compose1", "f"], "stack_to_render": [{"encoded_locals": {"f": ["REF", 1], "g": ["REF", 2]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["f", "g"], "parent_frame_id_list": [], "unique_hash": "compose1_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "compose1", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 10, "ordered_globals": ["square", "successor", "compose1", "f"], "stack_to_render": [{"encoded_locals": {"f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["f", "g", "h"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p"}], "stdout": ""}, {"event": "return", "func_name": "compose1", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 10, "ordered_globals": ["square", "successor", "compose1", "f"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 5], "f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["f", "g", "h", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "square_successor": ["REF", 5], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 17, "ordered_globals": ["square", "successor", "compose1", "f", "square_successor"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 5], "f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "h", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}], "stdout": ""}, {"event": "call", "func_name": "h", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "square_successor": ["REF", 5], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 8, "ordered_globals": ["square", "successor", "compose1", "f", "square_successor"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 5], "f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "h", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "h", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "h_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "h", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "square_successor": ["REF", 5], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 9, "ordered_globals": ["square", "successor", "compose1", "f", "square_successor"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 5], "f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "h", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "h", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "h_f2"}], "stdout": ""}, {"event": "call", "func_name": "successor", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "square_successor": ["REF", 5], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 4, "ordered_globals": ["square", "successor", "compose1", "f", "square_successor"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 5], "f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "h", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "h", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "h_f2"}, {"encoded_locals": {"x": 12}, "frame_id": 3, "func_name": "successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "successor_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "successor", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "square_successor": ["REF", 5], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 5, "ordered_globals": ["square", "successor", "compose1", "f", "square_successor"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 5], "f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "h", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "h", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "h_f2"}, {"encoded_locals": {"x": 12}, "frame_id": 3, "func_name": "successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "successor_f3"}], "stdout": ""}, {"event": "return", "func_name": "successor", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "square_successor": ["REF", 5], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 5, "ordered_globals": ["square", "successor", "compose1", "f", "square_successor"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 5], "f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "h", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "h", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "h_f2"}, {"encoded_locals": {"__return__": 13, "x": 12}, "frame_id": 3, "func_name": "successor", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "successor_f3"}], "stdout": ""}, {"event": "call", "func_name": "square", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "square_successor": ["REF", 5], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 1, "ordered_globals": ["square", "successor", "compose1", "f", "square_successor"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 5], "f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "h", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "h", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "h_f2"}, {"encoded_locals": {"__return__": 13, "x": 12}, "frame_id": 3, "func_name": "successor", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "successor_f3_z"}, {"encoded_locals": {"x": 13}, "frame_id": 4, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "square", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "square_successor": ["REF", 5], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 2, "ordered_globals": ["square", "successor", "compose1", "f", "square_successor"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 5], "f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "h", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "h", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "h_f2"}, {"encoded_locals": {"__return__": 13, "x": 12}, "frame_id": 3, "func_name": "successor", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "successor_f3_z"}, {"encoded_locals": {"x": 13}, "frame_id": 4, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "square_f4"}], "stdout": ""}, {"event": "return", "func_name": "square", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "square_successor": ["REF", 5], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 2, "ordered_globals": ["square", "successor", "compose1", "f", "square_successor"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 5], "f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "h", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "h", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "h_f2"}, {"encoded_locals": {"__return__": 13, "x": 12}, "frame_id": 3, "func_name": "successor", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "successor_f3_z"}, {"encoded_locals": {"__return__": 169, "x": 13}, "frame_id": 4, "func_name": "square", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f4"}], "stdout": ""}, {"event": "return", "func_name": "h", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "square": ["REF", 1], "square_successor": ["REF", 5], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 9, "ordered_globals": ["square", "successor", "compose1", "f", "square_successor"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 5], "f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "h", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"__return__": 169, "x": 12}, "frame_id": 2, "func_name": "h", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "h_f2"}, {"encoded_locals": {"__return__": 13, "x": 12}, "frame_id": 3, "func_name": "successor", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "successor_f3_z"}, {"encoded_locals": {"__return__": 169, "x": 13}, "frame_id": 4, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f4_z"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"compose1": ["REF", 3], "f": ["REF", 4], "result": 169, "square": ["REF", 1], "square_successor": ["REF", 5], "successor": ["REF", 2]}, "heap": {"1": ["FUNCTION", "square(x)", null], "2": ["FUNCTION", "successor(x)", null], "3": ["FUNCTION", "compose1(f, g)", null], "4": ["FUNCTION", "f(x)", null], "5": ["FUNCTION", "h(x)", 1]}, "line": 17, "ordered_globals": ["square", "successor", "compose1", "f", "square_successor", "result"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 5], "f": ["REF", 1], "g": ["REF", 2], "h": ["REF", 5]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "h", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"__return__": 169, "x": 12}, "frame_id": 2, "func_name": "h", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "h_f2_z"}, {"encoded_locals": {"__return__": 13, "x": 12}, "frame_id": 3, "func_name": "successor", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "successor_f3_z"}, {"encoded_locals": {"__return__": 169, "x": 13}, "frame_id": 4, "func_name": "square", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "square_f4_z"}], "stdout": ""}]}</script><p>The 1 in <tt class="docutils literal">compose1</tt> is meant to signify that the composed functions all
take a single argument. This naming convention is not enforced by the
interpreter; the 1 is just part of the function name.</p>
<p>At this point, we begin to observe the benefits of our effort to define
precisely the environment model of computation. No modification to our
environment model is required to explain our ability to return functions in
this way.</p>
</div>
<div class="section" id="example-newton-s-method">
<h3>1.6.5   Example: Newton's Method</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#azJlcbEOw1VU').src &amp;&amp; (document.querySelector('#azJlcbEOw1VU').src = 'http://www.youtube.com/embed/zJlcbEOw1VU?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#azJlcbEOw1VU').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#azJlcbEOw1VU').style.cssText = 'display:none'; document.querySelector('#azJlcbEOw1VU').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="azJlcbEOw1VU" style="display:none;" width="640"></iframe>
</div>
<p>This extended example shows how function return values and local definitions can
work together to express general ideas concisely. We will implement an algorithm
that is used broadly in machine learning, scientific computing, hardware design,
and optimization.</p>
<p>Newton's method is a classic iterative approach to finding the arguments of a
mathematical function that yield a return value of 0. These values are called
the <em>zeros</em> of the function. Finding a zero of a function is often equivalent
to solving some other problem of interest, such as computing a square root.</p>
<p>A motivating comment before we proceed: it is easy to take for granted the fact
that we know how to compute square roots. Not just Python, but your phone, web
browser, or pocket calculator can do so for you. However, part of learning
computer science is understanding how quantities like these can be computed, and
the general approach presented here is applicable to solving a large class of
equations beyond those built into Python.</p>
<p>Newton's method is an iterative improvement algorithm: it improves a guess of
the zero for any function that is <em>differentiable</em>, which means that it can be
approximated by a straight line at any point.  Newton's method follows these
linear approximations to find function zeros.</p>
<p>Imagine a line through the point <span class="rawlatex">$(x, f(x))$</span> that has the same slope
as the curve for function <span class="rawlatex">$f(x)$</span> at that point. Such a line is
called the <em>tangent</em>, and its slope is called the <em>derivative</em> of
<span class="rawlatex">$f$</span> at <span class="rawlatex">$x$</span>.</p>
<p>This line's slope is the ratio of the change in function value to the change in
function argument. Hence, translating <span class="rawlatex">$x$</span> by <span class="rawlatex">$f(x)$</span>
divided by the slope will give the argument value at which this tangent line
touches 0.</p>
<div class="figure">
<img alt="" src="../img/newton.png">
</div>
<p>A <tt class="docutils literal">newton_update</tt> expresses the computational process of following this
tangent line to 0, for a function <tt class="docutils literal">f</tt> and its derivative <tt class="docutils literal">df</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">newton_update</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">df</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">update</span>
</pre></div>

<p>Finally, we can define the <tt class="docutils literal">find_root</tt> function in terms of <tt class="docutils literal">newton_update</tt>,
our <tt class="docutils literal">improve</tt> algorithm, and a comparison to see if <span class="rawlatex">$f(x)$</span> is near
0.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">find_zero</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">near_zero</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">approx_eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">improve</span><span class="p">(</span><span class="n">newton_update</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="n">near_zero</span><span class="p">)</span>
</pre></div>

<p><strong>Computing Roots.</strong> Using Newton's method, we can compute roots of arbitrary
degree <span class="rawlatex">$n$</span>. The degree <span class="rawlatex">$n$</span> root of <span class="rawlatex">$a$</span> is
<span class="rawlatex">$x$</span> such that <span class="rawlatex">$x \cdot x \cdot x \dots x = a$</span> with
<span class="rawlatex">$x$</span> repeated <span class="rawlatex">$n$</span> times. For example,</p>
<ul class="simple">
<li>The square (second) root of 64 is 8, because
<span class="rawlatex">$8 \cdot 8 = 64$</span>.</li>
<li>The cube (third) root of 64 is 4, because
<span class="rawlatex">$4 \cdot 4 \cdot 4 = 64$</span>.</li>
<li>The sixth root of 64 is 2, because
<span class="rawlatex">$2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 = 64$</span>.</li>
</ul>
<p>We can compute roots using Newton's method with the following observations:</p>
<ul class="simple">
<li>The square root of 64 (written <span class="rawlatex">$\sqrt{64}$</span>) is the value
<span class="rawlatex">$x$</span> such that <span class="rawlatex">$x^2 - 64 = 0$</span>
</li>
<li>More generally, the degree <span class="rawlatex">$n$</span> root of <span class="rawlatex">$a$</span> (written
<span class="rawlatex">$\sqrt[n]{a}$</span>) is the value <span class="rawlatex">$x$</span> such that
<span class="rawlatex">$x^n - a = 0$</span>
</li>
</ul>
<p>If we can find a zero of this last equation, then we can compute degree
<span class="rawlatex">$n$</span> roots. By plotting the curves for <span class="rawlatex">$n$</span> equal to 2, 3,
and 6 and <span class="rawlatex">$a$</span> equal to 64, we can visualize this relationship.</p>
<div class="figure">
<img alt="" src="../img/curves.png">
</div>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#aOtNBPOKpB30').src &amp;&amp; (document.querySelector('#aOtNBPOKpB30').src = 'http://www.youtube.com/embed/OtNBPOKpB30?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#aOtNBPOKpB30').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#aOtNBPOKpB30').style.cssText = 'display:none'; document.querySelector('#aOtNBPOKpB30').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="aOtNBPOKpB30" style="display:none;" width="640"></iframe>
</div>
<p>We first implement <tt class="docutils literal">square_root</tt> by defining <tt class="docutils literal">f</tt> and its derivative <tt class="docutils literal">df</tt>.
We use from calculus the fact that the derivative of <span class="rawlatex">$f(x) = x^2 -
a$</span> is the linear function <span class="rawlatex">$df(x) = 2x$</span>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square_root_newton</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">a</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">df</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">find_zero</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square_root_newton</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="go">8.0</span>
</pre></div>

<p>Generalizing to roots of arbitrary degree <span class="rawlatex">$n$</span>, we compute
<span class="rawlatex">$f(x) = x^n - a$</span> and its derivative <span class="rawlatex">$df(x) = n \cdot
x^{n-1}$</span>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return x * x * x * ... * x for x repeated n times."""</span>
<span class="gp">    </span>    <span class="n">product</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">product</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">product</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">product</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">nth_root_of_a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">df</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">find_zero</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nth_root_of_a</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="go">8.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nth_root_of_a</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nth_root_of_a</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="go">2.0</span>
</pre></div>

<p>The approximation error in all of these computations can be reduced by changing
the <tt class="docutils literal">tolerance</tt> in <tt class="docutils literal">approx_eq</tt> to a smaller number.</p>
<p>As you experiment with Newton's method, be aware that it will not always
converge. The initial guess of <tt class="docutils literal">improve</tt> must be sufficiently close to the
zero, and various conditions about the function must be met. Despite this
shortcoming, Newton's method is a powerful general computational method for
solving differentiable equations. Very fast algorithms for logarithms and large
integer division employ variants of the technique in modern computers.</p>
</div>
<div class="section" id="currying">
<h3>1.6.6   Currying</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#a6HMa5hfhRVc').src &amp;&amp; (document.querySelector('#a6HMa5hfhRVc').src = 'http://www.youtube.com/embed/6HMa5hfhRVc?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#a6HMa5hfhRVc').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#a6HMa5hfhRVc').style.cssText = 'display:none'; document.querySelector('#a6HMa5hfhRVc').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="a6HMa5hfhRVc" style="display:none;" width="640"></iframe>
</div>
<p>We can use higher-order functions to convert a function that takes multiple
arguments into a chain of functions that each take a single argument. More
specifically, given a function <tt class="docutils literal">f(x, y)</tt>, we can define a function <tt class="docutils literal">g</tt> such
that <tt class="docutils literal"><span class="pre">g(x)(y)</span></tt> is equivalent to <tt class="docutils literal">f(x, y)</tt>. Here, <tt class="docutils literal">g</tt> is a higher-order
function that takes in a single argument <tt class="docutils literal">x</tt> and returns another function
that takes in a single argument <tt class="docutils literal">y</tt>. This transformation is called <em>currying</em>.</p>
<p>As an example, we can define a curried version of the <tt class="docutils literal">pow</tt> function:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">curried_pow</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">h</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">curried_pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">8</span>
</pre></div>

<p>Some programming languages, such as Haskell, only allow functions that take a
single argument, so the programmer must curry all multi-argument procedures. In
more general languages such as Python, currying is useful when we require a
function that takes in only a single argument. For example, the <em>map</em> pattern
applies a single-argument function to a sequence of values. In later chapters,
we will see more general examples of the map pattern, but for now, we can
implement the pattern in a function:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">map_to_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
<span class="gp">    </span>        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>
<span class="gp">    </span>        <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>

<p>We can use <tt class="docutils literal">map_to_range</tt> and <tt class="docutils literal">curried_pow</tt> to compute the first ten powers
of two, rather than specifically writing a function to do so:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">map_to_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">curried_pow</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">4</span>
<span class="go">8</span>
<span class="go">16</span>
<span class="go">32</span>
<span class="go">64</span>
<span class="go">128</span>
<span class="go">256</span>
<span class="go">512</span>
</pre></div>

<p>We can similarly use the same two functions to compute powers of other numbers.
Currying allows us to do so without writing a specific function for each number
whose powers we wish to compute.</p>
<p>In the above examples, we manually performed the currying transformation on the
<tt class="docutils literal">pow</tt> function to obtain <tt class="docutils literal">curried_pow</tt>. Instead, we can define functions to
automate currying, as well as the inverse <em>uncurrying</em> transformation:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">curry2</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a curried version of the given two-argument function."""</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">h</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">g</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">uncurry2</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a two-argument version of the given curried function."""</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">f</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pow_curried</span> <span class="o">=</span> <span class="n">curry2</span><span class="p">(</span><span class="nb">pow</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pow_curried</span><span class="p">(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">map_to_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">pow_curried</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">4</span>
<span class="go">8</span>
<span class="go">16</span>
<span class="go">32</span>
<span class="go">64</span>
<span class="go">128</span>
<span class="go">256</span>
<span class="go">512</span>
</pre></div>

<p>The <tt class="docutils literal">curry2</tt> function takes in a two-argument function <tt class="docutils literal">f</tt> and returns a
single-argument function <tt class="docutils literal">g</tt>. When <tt class="docutils literal">g</tt> is applied to an argument <tt class="docutils literal">x</tt>, it
returns a single-argument function <tt class="docutils literal">h</tt>. When <tt class="docutils literal">h</tt> is applied to <tt class="docutils literal">y</tt>, it
calls <tt class="docutils literal">f(x, y)</tt>. Thus, <tt class="docutils literal"><span class="pre">curry2(f)(x)(y)</span></tt> is equivalent to <tt class="docutils literal">f(x, y)</tt>. The
<tt class="docutils literal">uncurry2</tt> function reverses the currying transformation, so that
<tt class="docutils literal">uncurry2(curry2(f))</tt> is equivalent to <tt class="docutils literal">f</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">uncurry2</span><span class="p">(</span><span class="n">pow_curried</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">32</span>
</pre></div>

</div>
<div class="section" id="lambda-expressions">
<h3>1.6.7   Lambda Expressions</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#avCeNq_P3akI').src &amp;&amp; (document.querySelector('#avCeNq_P3akI').src = 'http://www.youtube.com/embed/vCeNq_P3akI?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#avCeNq_P3akI').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#avCeNq_P3akI').style.cssText = 'display:none'; document.querySelector('#avCeNq_P3akI').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="avCeNq_P3akI" style="display:none;" width="640"></iframe>
</div>
<p>So far, each time we have wanted to define a new function, we needed to give it
a name.  But for other types of expressions, we don't need to associate
intermediate values with a name. That is, we can compute <tt class="docutils literal">a*b + c*d</tt> without
having to name the subexpressions <tt class="docutils literal">a*b</tt> or <tt class="docutils literal">c*d</tt>, or the full expression.
In Python, we can create function values on the fly using <tt class="docutils literal">lambda</tt>
expressions, which evaluate to unnamed functions. A lambda expression evaluates
to a function that has a single return expression as its body. Assignment and
control statements are not allowed.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compose1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>

<p>We can understand the structure of a <tt class="docutils literal">lambda</tt> expression by constructing a
corresponding English sentence:</p>
<pre class="literal-block">
     lambda            x            :          f(g(x))
"A function that    takes x    and returns     f(g(x))"
</pre>
<p>The result of a lambda expression is called a lambda function.  It has no
intrinsic name (and so Python prints <tt class="docutils literal">&lt;lambda&gt;</tt> for the name), but otherwise
it behaves like any other function.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;function &lt;lambda&gt; at 0xf3f490&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">144</span>
</pre></div>

<p>In an environment diagram, the result of a lambda expression is a function as
well, named with the greek letter λ (lambda).  Our compose example can be
expressed quite compactly with lambda expressions.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_20" style="">
def compose1(f, g):
    return lambda x: f(g(x))

f = compose1(lambda x: x * x,
             lambda y: y + 1)
result = f(12)
</div>
<script type="text/javascript">
var example_20_trace = {"code": "def compose1(f, g):\n    return lambda x: f(g(x))\n\nf = compose1(lambda x: x * x,\n             lambda y: y + 1)\nresult = f(12)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"compose1": ["REF", 1]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null]}, "line": 4, "ordered_globals": ["compose1"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"compose1": ["REF", 1]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null]}, "line": 5, "ordered_globals": ["compose1"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "compose1", "globals": {"compose1": ["REF", 1]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null]}, "line": 1, "ordered_globals": ["compose1"], "stack_to_render": [{"encoded_locals": {"f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["f", "g"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "compose1", "globals": {"compose1": ["REF", 1]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null]}, "line": 2, "ordered_globals": ["compose1"], "stack_to_render": [{"encoded_locals": {"f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["f", "g"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p"}], "stdout": ""}, {"event": "return", "func_name": "compose1", "globals": {"compose1": ["REF", 1]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null], "4": ["FUNCTION", "<lambda>(x) <line 2>", 1]}, "line": 2, "ordered_globals": ["compose1"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 4], "f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["f", "g", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"compose1": ["REF", 1], "f": ["REF", 4]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null], "4": ["FUNCTION", "<lambda>(x) <line 2>", 1]}, "line": 6, "ordered_globals": ["compose1", "f"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 4], "f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}], "stdout": ""}, {"event": "call", "func_name": "<lambda>", "globals": {"compose1": ["REF", 1], "f": ["REF", 4]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null], "4": ["FUNCTION", "<lambda>(x) <line 2>", 1]}, "line": 2, "ordered_globals": ["compose1", "f"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 4], "f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "<lambda> <line 2>", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "<lambda> <line 2>_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "<lambda>", "globals": {"compose1": ["REF", 1], "f": ["REF", 4]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null], "4": ["FUNCTION", "<lambda>(x) <line 2>", 1]}, "line": 2, "ordered_globals": ["compose1", "f"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 4], "f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "<lambda> <line 2>", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "<lambda> <line 2>_f2"}], "stdout": ""}, {"event": "call", "func_name": "<lambda>", "globals": {"compose1": ["REF", 1], "f": ["REF", 4]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null], "4": ["FUNCTION", "<lambda>(x) <line 2>", 1]}, "line": 5, "ordered_globals": ["compose1", "f"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 4], "f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "<lambda> <line 2>", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "<lambda> <line 2>_f2"}, {"encoded_locals": {"y": 12}, "frame_id": 3, "func_name": "<lambda> <line 5>", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["y"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 5>_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "<lambda>", "globals": {"compose1": ["REF", 1], "f": ["REF", 4]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null], "4": ["FUNCTION", "<lambda>(x) <line 2>", 1]}, "line": 5, "ordered_globals": ["compose1", "f"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 4], "f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "<lambda> <line 2>", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "<lambda> <line 2>_f2"}, {"encoded_locals": {"y": 12}, "frame_id": 3, "func_name": "<lambda> <line 5>", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["y"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 5>_f3"}], "stdout": ""}, {"event": "return", "func_name": "<lambda>", "globals": {"compose1": ["REF", 1], "f": ["REF", 4]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null], "4": ["FUNCTION", "<lambda>(x) <line 2>", 1]}, "line": 5, "ordered_globals": ["compose1", "f"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 4], "f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "<lambda> <line 2>", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "<lambda> <line 2>_f2"}, {"encoded_locals": {"__return__": 13, "y": 12}, "frame_id": 3, "func_name": "<lambda> <line 5>", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["y", "__return__"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 5>_f3"}], "stdout": ""}, {"event": "call", "func_name": "<lambda>", "globals": {"compose1": ["REF", 1], "f": ["REF", 4]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null], "4": ["FUNCTION", "<lambda>(x) <line 2>", 1]}, "line": 4, "ordered_globals": ["compose1", "f"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 4], "f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "<lambda> <line 2>", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "<lambda> <line 2>_f2"}, {"encoded_locals": {"__return__": 13, "y": 12}, "frame_id": 3, "func_name": "<lambda> <line 5>", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["y", "__return__"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 5>_f3_z"}, {"encoded_locals": {"x": 13}, "frame_id": 4, "func_name": "<lambda> <line 4>", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 4>_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "<lambda>", "globals": {"compose1": ["REF", 1], "f": ["REF", 4]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null], "4": ["FUNCTION", "<lambda>(x) <line 2>", 1]}, "line": 4, "ordered_globals": ["compose1", "f"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 4], "f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "<lambda> <line 2>", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "<lambda> <line 2>_f2"}, {"encoded_locals": {"__return__": 13, "y": 12}, "frame_id": 3, "func_name": "<lambda> <line 5>", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["y", "__return__"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 5>_f3_z"}, {"encoded_locals": {"x": 13}, "frame_id": 4, "func_name": "<lambda> <line 4>", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 4>_f4"}], "stdout": ""}, {"event": "return", "func_name": "<lambda>", "globals": {"compose1": ["REF", 1], "f": ["REF", 4]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null], "4": ["FUNCTION", "<lambda>(x) <line 2>", 1]}, "line": 4, "ordered_globals": ["compose1", "f"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 4], "f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"x": 12}, "frame_id": 2, "func_name": "<lambda> <line 2>", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x"], "parent_frame_id_list": [1], "unique_hash": "<lambda> <line 2>_f2"}, {"encoded_locals": {"__return__": 13, "y": 12}, "frame_id": 3, "func_name": "<lambda> <line 5>", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["y", "__return__"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 5>_f3_z"}, {"encoded_locals": {"__return__": 169, "x": 13}, "frame_id": 4, "func_name": "<lambda> <line 4>", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 4>_f4"}], "stdout": ""}, {"event": "return", "func_name": "<lambda>", "globals": {"compose1": ["REF", 1], "f": ["REF", 4]}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null], "4": ["FUNCTION", "<lambda>(x) <line 2>", 1]}, "line": 2, "ordered_globals": ["compose1", "f"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 4], "f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"__return__": 169, "x": 12}, "frame_id": 2, "func_name": "<lambda> <line 2>", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "<lambda> <line 2>_f2"}, {"encoded_locals": {"__return__": 13, "y": 12}, "frame_id": 3, "func_name": "<lambda> <line 5>", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["y", "__return__"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 5>_f3_z"}, {"encoded_locals": {"__return__": 169, "x": 13}, "frame_id": 4, "func_name": "<lambda> <line 4>", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 4>_f4_z"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"compose1": ["REF", 1], "f": ["REF", 4], "result": 169}, "heap": {"1": ["FUNCTION", "compose1(f, g)", null], "2": ["FUNCTION", "<lambda>(x) <line 4>", null], "3": ["FUNCTION", "<lambda>(y) <line 5>", null], "4": ["FUNCTION", "<lambda>(x) <line 2>", 1]}, "line": 6, "ordered_globals": ["compose1", "f", "result"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 4], "f": ["REF", 2], "g": ["REF", 3]}, "frame_id": 1, "func_name": "compose1", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["f", "g", "__return__"], "parent_frame_id_list": [], "unique_hash": "compose1_f1_p_z"}, {"encoded_locals": {"__return__": 169, "x": 12}, "frame_id": 2, "func_name": "<lambda> <line 2>", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [1], "unique_hash": "<lambda> <line 2>_f2_z"}, {"encoded_locals": {"__return__": 13, "y": 12}, "frame_id": 3, "func_name": "<lambda> <line 5>", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["y", "__return__"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 5>_f3_z"}, {"encoded_locals": {"__return__": 169, "x": 13}, "frame_id": 4, "func_name": "<lambda> <line 4>", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["x", "__return__"], "parent_frame_id_list": [], "unique_hash": "<lambda> <line 4>_f4_z"}], "stdout": ""}]}</script><p>Some programmers find that using unnamed functions from lambda expressions
to be shorter and more direct. However, compound <tt class="docutils literal">lambda</tt> expressions are
notoriously illegible, despite their brevity.  The following definition is
correct, but many programmers have trouble understanding it quickly.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">compose1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>

<p>In general, Python style prefers explicit <tt class="docutils literal">def</tt> statements to lambda
expressions, but allows them in cases where a simple function is needed as an
argument or return value.</p>
<p>Such stylistic rules are merely guidelines; you can program any way you wish.
However, as you write programs, think about the audience of people who might
read your program one day.  When you can make your program easier to
understand, you do those people a favor.</p>
<p>The term <em>lambda</em> is a historical accident resulting from the incompatibility of
written mathematical notation and the constraints of early type-setting
systems.</p>
<blockquote class="epigraph">
<p>It may seem perverse to use lambda to introduce a procedure/function.
The notation goes back to Alonzo Church, who in the 1930's started with a
"hat" symbol; he wrote the square function as "ŷ . y × y". But frustrated
typographers moved the hat to the left of the parameter and changed it to a
capital lambda: "Λy . y × y"; from there the capital lambda was changed to
lowercase, and now we see "λy . y × y" in math books and
<tt class="docutils literal">(lambda (y) (* y y))</tt> in Lisp.</p>
<p class="attribution">—Peter Norvig (norvig.com/lispy2.html)</p>
</blockquote>
<p>Despite their unusual etymology, <tt class="docutils literal">lambda</tt> expressions and the corresponding
formal language for function application, the <em>lambda calculus</em>, are fundamental
computer science concepts shared far beyond the Python programming community.
We will revisit this topic when we study the design of interpreters in Chapter
3.</p>
</div>
<div class="section" id="abstractions-and-first-class-functions">
<h3>1.6.8   Abstractions and First-Class Functions</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#abi_2gAetCiI').src &amp;&amp; (document.querySelector('#abi_2gAetCiI').src = 'http://www.youtube.com/embed/bi_2gAetCiI?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#abi_2gAetCiI').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#abi_2gAetCiI').style.cssText = 'display:none'; document.querySelector('#abi_2gAetCiI').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="abi_2gAetCiI" style="display:none;" width="640"></iframe>
</div>
<p>We began this section with the observation that user-defined functions are a
crucial abstraction mechanism, because they permit us to express general methods
of computing as explicit elements in our programming language. Now we've seen
how higher-order functions permit us to manipulate these general methods to
create further abstractions.</p>
<p>As programmers, we should be alert to opportunities to identify the underlying
abstractions in our programs, build upon them, and generalize them to
create more powerful abstractions. This is not to say that one should always
write programs in the most abstract way possible; expert programmers know how to
choose the level of abstraction appropriate to their task. But it is important
to be able to think in terms of these abstractions, so that we can be ready to
apply them in new contexts. The significance of higher-order functions is that
they enable us to represent these abstractions explicitly as elements in our
programming language, so that they can be handled just like other computational
elements.</p>
<p>In general, programming languages impose restrictions on the ways in which
computational elements can be manipulated. Elements with the fewest restrictions
are said to have first-class status. Some of the "rights and privileges" of
first-class elements are:</p>
<ol class="arabic simple">
<li>They may be bound to names.</li>
<li>They may be passed as arguments to functions.</li>
<li>They may be returned as the results of functions.</li>
<li>They may be included in data structures.</li>
</ol>
<p>Python awards functions full first-class status, and the resulting gain in
expressive power is enormous.</p>
</div>
<div class="section" id="function-decorators">
<h3>1.6.9   Function Decorators</h3>
<div align="center" class="youtube">
<b>Video:</b>
<a onclick="!document.querySelector('#ath_SlHfhlBo').src &amp;&amp; (document.querySelector('#ath_SlHfhlBo').src = 'http://www.youtube.com/embed/th_SlHfhlBo?rel=0&amp;showinfo=0&amp;enablejsapi=1'); document.querySelector('#ath_SlHfhlBo').style.cssText = 'display:block';">Show</a>
<a onclick="document.querySelector('#ath_SlHfhlBo').style.cssText = 'display:none'; document.querySelector('#ath_SlHfhlBo').contentWindow.postMessage('{&quot;event&quot;:&quot;command&quot;,&quot;func&quot;:&quot;pauseVideo&quot;,&quot;args&quot;:&quot;&quot;}', '*');">Hide</a><iframe allowfullscreen="" frameborder="0" height="360" id="ath_SlHfhlBo" style="display:none;" width="640"></iframe>
</div>
<p>Python provides special syntax to apply higher-order functions as part of
executing a <tt class="docutils literal">def</tt> statement, called a decorator. Perhaps the most common
example is a trace.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">'-&gt; '</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="s1">'('</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">')'</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@trace</span>
<span class="gp">    </span><span class="k">def</span> <span class="nf">triple</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">triple</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">-&gt;  &lt;function triple at 0x102a39848&gt; ( 12 )</span>
<span class="go">36</span>
</pre></div>

<p>In this example, A higher-order function <tt class="docutils literal">trace</tt> is defined, which returns a
function that precedes a call to its argument with a <tt class="docutils literal">print</tt> statement that
outputs the argument. The <tt class="docutils literal">def</tt> statement for <tt class="docutils literal">triple</tt> has an
annotation, <tt class="docutils literal">@trace</tt>, which affects the execution rule for <tt class="docutils literal">def</tt>. As
usual, the function <tt class="docutils literal">triple</tt> is created. However, the name <tt class="docutils literal">triple</tt> is not
bound to this function. Instead, the name <tt class="docutils literal">triple</tt> is bound to the returned
function value of calling <tt class="docutils literal">trace</tt> on the newly defined <tt class="docutils literal">triple</tt> function.
In code, this decorator is equivalent to:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">triple</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">triple</span> <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">triple</span><span class="p">)</span>
</pre></div>

<p>In the projects associated with this text, decorators are used for tracing, as
well as selecting which functions to call when a program is run from the
command line.</p>
<p><strong>Extra for experts.</strong> The decorator symbol <tt class="docutils literal">@</tt> may also be followed by a call
expression. The expression following <tt class="docutils literal">@</tt> is evaluated first (just as the name
<tt class="docutils literal">trace</tt> was evaluated above), the <tt class="docutils literal">def</tt> statement second, and finally the
result of evaluating the decorator expression is applied to the newly defined
function, and the result is bound to the name in the <tt class="docutils literal">def</tt> statement. A
<a class="reference external" href="http://programmingbits.pythonblogs.com/27_programmingbits/archive/50_function_decorators.html">short tutorial on decorators</a>
by Ariel Ortiz gives further examples for interested students.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/17-recursive-functions.html">
  		1.7 Recursive Functions
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
	<h1>Chapter 2: Building Abstractions with Data</h1>
  <div class="section" id="introduction">
<h2>2.1   Introduction</h2>
<p>We concentrated in Chapter 1 on computational processes and on the role of
functions in program design. We saw how to use primitive data (numbers) and
primitive operations (arithmetic), how to form compound functions
through composition and control, and how to create functional abstractions by
giving names to processes. We also saw that higher-order functions enhance the
power of our language by enabling us to manipulate, and thereby to reason, in
terms of general methods of computation. This is much of the essence of
programming.</p>
<p>This chapter focuses on data.  The techniques we investigate here will allow us
to represent and manipulate information about many different domains.  Due to
the explosive growth of the Internet, a vast amount of structured information
is freely available to all of us online, and computation can be applied to a
vast range of different problems. Effective use of built-in and user-defined
data types are fundamental to data processing applications.</p>
<div class="section" id="native-data-types">
<h3>2.1.1   Native Data Types</h3>
<p>Every value in Python has a <em>class</em> that determines what type of value it is.
Values that share a class also share behavior. For example, the integers
<tt class="docutils literal">1</tt> and <tt class="docutils literal">2</tt> are both instances of the <tt class="docutils literal">int</tt> class. These two values can
be treated similarly. For example, they can both be negated or added to another
integer. The built-in <tt class="docutils literal">type</tt> function allows us to inspect the class of any
value.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&lt;class 'int'&gt;</span>
</pre></div>

<p>The values we have used so far are instances of a small number of <em>native</em> data
types that are built into the Python language. Native data types have the
following properties:</p>
<ol class="arabic simple">
<li>There are expressions that evaluate to values of native types, called
<em>literals</em>.</li>
<li>There are built-in functions and operators to manipulate values of native
types.</li>
</ol>
<p>The <tt class="docutils literal">int</tt> class is the native data type used to represent integers. Integer
literals (sequences of adjacent numerals) evaluate to <tt class="docutils literal">int</tt> values, and
mathematical operators manipulate these values.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">12</span> <span class="o">+</span> <span class="mi">3000000000000000000000000</span>
<span class="go">3000000000000000000000012</span>
</pre></div>

<p>Python includes three native numeric types: integers (<tt class="docutils literal">int</tt>), real numbers
(<tt class="docutils literal">float</tt>), and complex numbers (<tt class="docutils literal">complex</tt>).</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
<span class="go">&lt;class 'float'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">&lt;class 'complex'&gt;</span>
</pre></div>

<p><strong>Floats.</strong> The name <tt class="docutils literal">float</tt> comes from the way in which real numbers are
represented in Python and many other programming languages: a "floating point"
representation.  While the details of how numbers are represented is not a
topic for this text, some high-level differences between <tt class="docutils literal">int</tt> and <tt class="docutils literal">float</tt>
objects are important to know.  In particular, <tt class="docutils literal">int</tt> objects represent
integers exactly, without any approximation or limits on their size.  On the
other hand, <tt class="docutils literal">float</tt> objects can represent a wide range of fractional numbers,
but not all numbers can be represented exactly, and there are minimum and
maximum values. Therefore, <tt class="docutils literal">float</tt> values should be treated as approximations
to real values. These approximations have only a finite amount of precision.
Combining <tt class="docutils literal">float</tt> values can lead to approximation errors; both of the
following expressions would evaluate to <tt class="docutils literal">7</tt> if not for approximation.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">7</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span>
<span class="go">7.0</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">*</span> <span class="mi">3</span>
<span class="go">6.999999999999999</span>
</pre></div>

<p>Although <tt class="docutils literal">int</tt> values are combined above, dividing one <tt class="docutils literal">int</tt> by another
yields a <tt class="docutils literal">float</tt> value: a truncated finite approximation to the actual ratio
of the two integers divided.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&lt;class 'float'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="go">0.3333333333333333</span>
</pre></div>

<p>Problems with this approximation appear when we conduct equality tests.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span> <span class="o">==</span> <span class="mf">0.333333333333333312345</span>  <span class="c1"># Beware of float approximation</span>
<span class="go">True</span>
</pre></div>

<p>These subtle differences between the <tt class="docutils literal">int</tt> and <tt class="docutils literal">float</tt> class have
wide-ranging consequences for writing programs, and so they are details that
must be memorized by programmers. Fortunately, there are only a handful of
native data types, limiting the amount of memorization required to become
proficient in a programming language. Moreover, these same details are
consistent across many programming languages, enforced by community guidelines
such as the
<a class="reference external" href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754 floating point standard</a>.</p>
<p><strong>Non-numeric types.</strong> Values can represent many other types of data, such as
sounds, images, locations, web addresses, network connections, and more. A few
are represented by native data types, such as the <tt class="docutils literal">bool</tt> class for values
<tt class="docutils literal">True</tt> and <tt class="docutils literal">False</tt>. The type for most values must be defined by
programmers using the means of combination and abstraction that we will
develop in this chapter.</p>
<p>The following sections introduce more of Python's native data types, focusing
on the role they play in creating useful data abstractions. For those
interested in further details, a chapter on <a class="reference external" href="http://getpython3.com/diveintopython3/native-datatypes.html">native data types</a> in the online
book Dive Into Python 3 gives a pragmatic overview of all Python's native data
types and how to manipulate them, including numerous usage examples and
practical tips.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/22-data-abstraction.html">
  		2.2 Data Abstraction
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="data-abstraction">
<h2>2.2   Data Abstraction</h2>
<p>As we consider the wide set of things in the world that we would like to
represent in our programs, we find that most of them have compound structure.
For example, a geographic position has latitude and longitude coordinates.  To
represent positions, we would like our programming language to have the
capacity to couple together a latitude and longitude to form a pair, a
<em>compound data</em> value that our programs can manipulate as a single conceptual
unit, but which also has two parts that can be considered individually.</p>
<p>The use of compound data enables us to increase the modularity of our programs.
If we can manipulate geographic positions as whole values, then we can shield
parts of our program that compute using positions from the details of how those
positions are represented. The general technique of isolating the parts of a
program that deal with how data are represented from the parts that deal with
how data are manipulated is a powerful design methodology called <em>data
abstraction</em>. Data abstraction makes programs much easier to design, maintain,
and modify.</p>
<p>Data abstraction is similar in character to functional abstraction.  When we
create a functional abstraction, the details of how a function is implemented
can be suppressed, and the particular function itself can be replaced by any
other function with the same overall behavior.  In other words, we can make an
abstraction that separates the way the function is used from the details of how
the function is implemented.  Analogously, data abstraction isolates how a
compound data value is used from the details of how it is constructed.</p>
<p>The basic idea of data abstraction is to structure programs so that they
operate on abstract data. That is, our programs should use data in such a way
as to make as few assumptions about the data as possible. At the same time, a
concrete data representation is defined as an independent part of the program.</p>
<p>These two parts of a program, the part that operates on abstract data and the
part that defines a concrete representation, are connected by a small set of
functions that implement abstract data in terms of the concrete representation.
To illustrate this technique, we will consider how to design a set of functions
for manipulating rational numbers.</p>
<div class="section" id="example-rational-numbers">
<h3>2.2.1   Example: Rational Numbers</h3>
<p>A rational number is a ratio of integers, and rational numbers constitute an
important sub-class of real numbers.  A rational number such as <tt class="docutils literal">1/3</tt> or
<tt class="docutils literal">17/29</tt> is typically written as:</p>
<pre class="literal-block">
&lt;numerator&gt;/&lt;denominator&gt;
</pre>
<p>where both the <tt class="docutils literal">&lt;numerator&gt;</tt> and <tt class="docutils literal">&lt;denominator&gt;</tt> are placeholders for
integer values.  Both parts are needed to exactly characterize the value of the
rational number. Actually dividing integers produces a <tt class="docutils literal">float</tt> approximation,
losing the exact precision of integers.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="go">0.3333333333333333</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span> <span class="o">==</span> <span class="mf">0.333333333333333300000</span>  <span class="c1"># Dividing integers yields an approximation</span>
<span class="go">True</span>
</pre></div>

<p>However, we can create an exact representation for rational numbers by
combining together the numerator and denominator.</p>
<p>We know from using functional abstractions that we can start programming
productively before we have an implementation of some parts of our program.
Let us begin by assuming that we already have a way of constructing a rational
number from a numerator and a denominator. We also assume that, given a
rational number, we have a way of selecting its numerator and its denominator
component. Let us further assume that the constructor and selectors are
available as the following three functions:</p>
<ul class="simple">
<li>
<tt class="docutils literal">rational(n, d)</tt> returns the rational number with numerator <tt class="docutils literal">n</tt> and
denominator <tt class="docutils literal">d</tt>.</li>
<li>
<tt class="docutils literal">numer(x)</tt> returns the numerator of the rational number <tt class="docutils literal">x</tt>.</li>
<li>
<tt class="docutils literal">denom(x)</tt> returns the denominator of the rational number <tt class="docutils literal">x</tt>.</li>
</ul>
<p>We are using here a powerful strategy for designing programs: <em>wishful
thinking</em>. We haven't yet said how a rational number is represented, or how the
functions <tt class="docutils literal">numer</tt>, <tt class="docutils literal">denom</tt>, and <tt class="docutils literal">rational</tt> should be implemented. Even
so, if we did define these three functions, we could then add, multiply, print,
and test equality of rational numbers:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add_rationals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">nx</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">numer</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">denom</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">ny</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">numer</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">denom</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">rational</span><span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">+</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mul_rationals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">rational</span><span class="p">(</span><span class="n">numer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">numer</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">denom</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_rational</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="n">numer</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">'/'</span><span class="p">,</span> <span class="n">denom</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rationals_are_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">numer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">numer</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

<p>Now we have the operations on rational numbers defined in terms of the selector
functions <tt class="docutils literal">numer</tt> and <tt class="docutils literal">denom</tt>, and the constructor function <tt class="docutils literal">rational</tt>,
but we haven't yet defined these functions. What we need is some way to glue
together a numerator and a denominator into a compound value.</p>
</div>
<div class="section" id="pairs">
<h3>2.2.2   Pairs</h3>
<p>To enable us to implement the concrete level of our data abstraction, Python
provides a compound structure called a <tt class="docutils literal">list</tt>, which can be constructed by
placing expressions within square brackets separated by commas. Such an
expression is called a list literal.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="go">[10, 20]</span>
</pre></div>

<p>The elements of a list can be accessed in two ways.  The first way is via our
familiar method of multiple assignment, which unpacks a list into its elements
and binds each element to a different name.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span>
<span class="go">[10, 20]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pair</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">20</span>
</pre></div>

<p>A second method for accessing the elements in a list is by the element
selection operator, also expressed using square brackets. Unlike a list
literal, a square-brackets expression directly following another expression
does not evaluate to a <tt class="docutils literal">list</tt> value, but instead selects an element from the
value of the preceding expression.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">20</span>
</pre></div>

<p>Lists in Python (and sequences in most other programming languages) are
0-indexed, meaning that the index 0 selects the first element, index 1
selects the second, and so on.  One intuition that supports this indexing
convention is that the index represents how far an element is offset from the
beginning of the list.</p>
<p>The equivalent function for the element selection operator is called
<tt class="docutils literal">getitem</tt>, and it also uses 0-indexed positions to select elements from a
list.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">getitem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getitem</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getitem</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">20</span>
</pre></div>

<p>Two-element lists are not the only method of representing pairs in Python.
Any way of bundling two values together into one can be considered a pair.
Lists are a common method to do so. Lists can also contain more than two
elements, as we will explore later in the chapter.</p>
<p><strong>Representing Rational Numbers.</strong> We can now represent a rational number as a
pair of two integers: a numerator and a denominator.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rational</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">numer</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">denom</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>

<p>Together with the arithmetic operations we defined earlier, we can manipulate
rational numbers with the functions we have defined.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">half</span> <span class="o">=</span> <span class="n">rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_rational</span><span class="p">(</span><span class="n">half</span><span class="p">)</span>
<span class="go">1 / 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">third</span> <span class="o">=</span> <span class="n">rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_rational</span><span class="p">(</span><span class="n">mul_rationals</span><span class="p">(</span><span class="n">half</span><span class="p">,</span> <span class="n">third</span><span class="p">))</span>
<span class="go">1 / 6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_rational</span><span class="p">(</span><span class="n">add_rationals</span><span class="p">(</span><span class="n">third</span><span class="p">,</span> <span class="n">third</span><span class="p">))</span>
<span class="go">6 / 9</span>
</pre></div>

<p>As the example above shows, our rational number implementation does not reduce
rational numbers to lowest terms. We can remedy this flaw by changing the
implementation of <tt class="docutils literal">rational</tt>. If we have a function for computing the
greatest common denominator of two integers, we can use it to reduce the
numerator and the denominator to lowest terms before constructing the pair.  As
with many useful tools, such a function already exists in the Python Library.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">gcd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rational</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">g</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="n">g</span><span class="p">,</span> <span class="n">d</span><span class="o">//</span><span class="n">g</span><span class="p">)</span>
</pre></div>

<p>The floor division operator, <tt class="docutils literal">//</tt>, expresses integer division, which rounds
down the fractional part of the result of division.  Since we know that <tt class="docutils literal">g</tt>
divides both <tt class="docutils literal">n</tt> and <tt class="docutils literal">d</tt> evenly, integer division is exact in this case.
This revised <tt class="docutils literal">rational</tt> implementation ensures that rationals are expressed
in lowest terms.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_rational</span><span class="p">(</span><span class="n">add_rationals</span><span class="p">(</span><span class="n">third</span><span class="p">,</span> <span class="n">third</span><span class="p">))</span>
<span class="go">2 / 3</span>
</pre></div>

<p>This improvement was accomplished by changing the constructor without changing
any of the functions that implement the actual arithmetic operations.</p>
</div>
<div class="section" id="abstraction-barriers">
<h3>2.2.3   Abstraction Barriers</h3>
<p>Before continuing with more examples of compound data and data abstraction, let
us consider some of the issues raised by the rational number example. We
defined operations in terms of a constructor <tt class="docutils literal">rational</tt> and selectors
<tt class="docutils literal">numer</tt> and <tt class="docutils literal">denom</tt>. In general, the underlying idea of data abstraction is
to identify a basic set of operations in terms of which all manipulations of
values of some kind will be expressed, and then to use only those operations in
manipulating the data. By restricting the use of operations in this way, it is
much easier to change the representation of abstract data without changing the
behavior of a program.</p>
<p>For rational numbers, different parts of the program manipulate rational
numbers using different operations, as described in this table.</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%">
<col width="19%">
<col width="47%">
</colgroup>
<thead valign="bottom">
<tr>
<th class="head"><strong>Parts of the program that...</strong></th>
<th class="head"><strong>Treat rationals as...</strong></th>
<th class="head"><strong>Using only...</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td>Use rational numbers to perform computation</td>
<td>whole data values</td>
<td><tt class="docutils literal">add_rational, mul_rational, rationals_are_equal, print_rational</tt></td>
</tr>
<tr>
<td>Create rationals or implement rational operations</td>
<td>numerators and denominators</td>
<td><tt class="docutils literal">rational, numer, denom</tt></td>
</tr>
<tr>
<td>Implement selectors and constructor for rationals</td>
<td>two-element lists</td>
<td>list literals and element selection</td>
</tr>
</tbody>
</table>
<p>In each layer above, the functions in the final column enforce an abstraction
barrier. These functions are called by a higher level and implemented using a
lower level of abstraction.</p>
<p>An abstraction barrier violation occurs whenever a part of the program that
can use a higher level function instead uses a function in a lower level. For
example, a function that computes the square of a rational number is best
implemented in terms of <tt class="docutils literal">mul_rational</tt>, which does not assume anything about
the implementation of a rational number.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square_rational</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">mul_rational</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>

<p>Referring directly to numerators and denominators would violate one abstraction
barrier.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square_rational_violating_once</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">rational</span><span class="p">(</span><span class="n">numer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">numer</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">denom</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>

<p>Assuming that rationals are represented as two-element lists would violate two
abstraction barriers.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square_rational_violating_twice</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
</pre></div>

<p>Abstraction barriers make programs easier to maintain and to modify. The fewer
functions that depend on a particular representation, the fewer changes are
required when one wants to change that representation. All of these
implementations of <tt class="docutils literal">square_rational</tt> have the correct behavior, but only the
first is robust to future changes. The <tt class="docutils literal">square_rational</tt> function would not
require updating even if we altered the representation of rational numbers. By
contrast, <tt class="docutils literal">square_rational_violating_once</tt> would need to be changed whenever
the selector or constructor signatures changed, and
<tt class="docutils literal">square_rational_violating_twice</tt> would require updating whenever the
implementation of rational numbers changed.</p>
</div>
<div class="section" id="the-properties-of-data">
<h3>2.2.4   The Properties of Data</h3>
<p>Abstraction barriers shape the way in which we think about data. A valid
representation of a rational number is not restricted to any particular
implementation (such as a two-element list); it is a value returned by
<tt class="docutils literal">rational</tt> that can be passed to <tt class="docutils literal">numer</tt>, and <tt class="docutils literal">denom</tt>.
In addition, the appropriate relationship must hold among the constructor and
selectors. That is, if we construct a rational number <tt class="docutils literal">x</tt> from integers <tt class="docutils literal">n</tt>
and <tt class="docutils literal">d</tt>, then it should be the case that <tt class="docutils literal"><span class="pre">numer(x)/denom(x)</span></tt> is equal to
<tt class="docutils literal">n/d</tt>.</p>
<p>In general, we can express abstract data using a collection of selectors and
constructors, together with some behavior conditions.  As long as the behavior
conditions are met (such as the division property above), the selectors and
constructors constitute a valid representation of a kind of data. The
implementation details below an abstraction barrier may change, but if the
behavior does not, then the data abstraction remains valid, and any program
written using this data abstraction will remain correct.</p>
<p>This point of view can be applied broadly, including to the pair values
that we used to implement rational numbers. We never actually said much about
what a pair was, only that the language supplied the means to create and
manipulate lists with two elements. The behavior we require to implement
a pair is that it glues two values together. Stated as a behavior condition,</p>
<ul class="simple">
<li>If a pair <tt class="docutils literal">p</tt> was constructed from values <tt class="docutils literal">x</tt> and <tt class="docutils literal">y</tt>, then
<tt class="docutils literal">select(p, 0)</tt> returns <tt class="docutils literal">x</tt>, and <tt class="docutils literal">select(p, 1)</tt> returns
<tt class="docutils literal">y</tt>.</li>
</ul>
<p>We don't actually need the <tt class="docutils literal">list</tt> type to create pairs. Instead, we can
implement two functions <tt class="docutils literal">pair</tt> and <tt class="docutils literal">select</tt> that fulfill this description
just as well as a two-element list.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pair</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a function that represents a pair."""</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">x</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">y</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">get</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return the element at index i of pair p."""</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">p</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>

<p>With this implementation, we can create and manipulate pairs.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">pair</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">select</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">select</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">14</span>
</pre></div>

<p>This use of higher-order functions corresponds to nothing like our intuitive
notion of what data should be. Nevertheless, these functions suffice to
represent pairs in our programs. Functions are sufficient to represent compound
data.</p>
<p>The point of exhibiting the functional representation of a pair is not that
Python actually works this way (lists are implemented more directly, for
efficiency reasons) but that it could work this way. The functional
representation, although obscure, is a perfectly adequate way to represent
pairs, since it fulfills the only conditions that pairs need to fulfill. The
practice of data abstraction allows us to switch among representations easily.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/23-sequences.html">
  		2.3 Sequences
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="sequences">
<h2>2.3   Sequences</h2>
<p>A sequence is an ordered collection of values. The sequence is a powerful,
fundamental abstraction in computer science. Sequences are not instances of a
particular built-in type or abstract data representation, but instead a
collection of behaviors that are shared among several different types of data.
That is, there are many kinds of sequences, but they all share common behavior.
In particular,</p>
<p><strong>Length.</strong> A sequence has a finite length. An empty sequence has length 0.</p>
<p><strong>Element selection.</strong> A sequence has an element corresponding to any
non-negative integer index less than its length, starting at 0 for the first
element.</p>
<p>Python includes several native data types that are sequences, the most
important of which is the <tt class="docutils literal">list</tt>.</p>
<div class="section" id="lists">
<h3>2.3.1   Lists</h3>
<p>A <tt class="docutils literal">list</tt> value is a sequence that can have arbitrary length.  Lists have a
large set of built-in behaviors, along with specific syntax to express those
behaviors. We have already seen the list literal, which evaluates to a <tt class="docutils literal">list</tt>
instance, as well as an element selection expression that evaluates to a value
in the list. The built-in <tt class="docutils literal">len</tt> function returns the length of a sequence.
Below, <tt class="docutils literal">digits</tt> is a list with four elements. The element at index 3 is 8.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">digits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">digits</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">8</span>
</pre></div>

<p>Additionally, lists can be added together and multiplied by integers.  For
sequences, addition and multiplication do not add or multiply elements, but
instead combine and replicate the sequences themselves. That is, the <tt class="docutils literal">add</tt>
function in the <tt class="docutils literal">operator</tt> module (and the <tt class="docutils literal">+</tt> operator) yields a list that
is the concatenation of the added arguments.  The <tt class="docutils literal">mul</tt> function in
<tt class="docutils literal">operator</tt> (and the <tt class="docutils literal">*</tt> operator) can take a list and an integer <tt class="docutils literal">k</tt> to
return the list that consists of <tt class="docutils literal">k</tt> repetitions of the original list.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="n">digits</span> <span class="o">*</span> <span class="mi">2</span>
<span class="go">[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]</span>
</pre></div>

<p>Any values can be included in a list, including another list. Element selection
can be applied multiple times in order to select a deeply nested element in a
list containing lists.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[30, 40]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="go">30</span>
</pre></div>

</div>
<div class="section" id="sequence-iteration">
<h3>2.3.2   Sequence Iteration</h3>
<p>In many cases, we would like to iterate over the elements of a sequence and
perform some computation for each element in turn.  This pattern is so common
that Python has an additional control statement to process sequential data: the
<tt class="docutils literal">for</tt> statement.</p>
<p>Consider the problem of counting how many times a value appears in a sequence.
We can implement a function to compute this count using a <tt class="docutils literal">while</tt> loop.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Count the number of occurrences of value in sequence s."""</span>
<span class="gp">    </span>    <span class="n">total</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">total</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">    </span>        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">total</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">(</span><span class="n">digits</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>

<p>The Python <tt class="docutils literal">for</tt> statement can simplify this function body by iterating over
the element values directly without introducing the name <tt class="docutils literal">index</tt> at all.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Count the number of occurrences of value in sequence s."""</span>
<span class="gp">    </span>    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">total</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">total</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">(</span><span class="n">digits</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>

<p>A <tt class="docutils literal">for</tt> statement consists of a single clause with the form:</p>
<pre class="literal-block">
for &lt;name&gt; in &lt;expression&gt;:
    &lt;suite&gt;
</pre>
<p>A <tt class="docutils literal">for</tt> statement is executed by the following procedure:</p>
<ol class="arabic simple">
<li>Evaluate the header <tt class="docutils literal">&lt;expression&gt;</tt>, which must yield an iterable value.</li>
<li>For each element value in that iterable value, in order:<ol class="upperalpha">
<li>Bind <tt class="docutils literal">&lt;name&gt;</tt> to that value in the current frame.</li>
<li>Execute the <tt class="docutils literal">&lt;suite&gt;</tt>.</li>
</ol>
</li>
</ol>
<p>This execution procedure refers to <em>iterable values</em>. Lists are a type of
sequence, and sequences are iterable values. Their elements are considered
in their sequential order.  Python includes other iterable types, but we will
focus on sequences for now; the general definition of the term "iterable"
appears in the section on iterators in Chapter 4.</p>
<p>An important consequence of this evaluation procedure is that <tt class="docutils literal">&lt;name&gt;</tt> will be
bound to the last element of the sequence after the <tt class="docutils literal">for</tt> statement is
executed.  The <tt class="docutils literal">for</tt> loop introduces yet another way in which the
environment can be updated by a statement.</p>
<p><strong>Sequence unpacking.</strong> A common pattern in programs is to have a sequence of
elements that are themselves sequences, but all of a fixed length. A <tt class="docutils literal">for</tt>
statement may include multiple names in its header to "unpack" each element
sequence into its respective elements.  For example, we may have a list of
two-element lists.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
</pre></div>

<p>and wish to find the number of these pairs that have the same first and second
element.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">same_count</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>

<p>The following <tt class="docutils literal">for</tt> statement with two names in its header will bind each name
<tt class="docutils literal">x</tt> and <tt class="docutils literal">y</tt> to the first and second elements in each pair, respectively.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">same_count</span> <span class="o">=</span> <span class="n">same_count</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">same_count</span>
<span class="go">2</span>
</pre></div>

<p>This pattern of binding multiple names to multiple values in a fixed-length
sequence is called <em>sequence unpacking</em>; it is the same pattern that we see in
assignment statements that bind multiple names to multiple values.</p>
<p><strong>Ranges.</strong> A <tt class="docutils literal">range</tt> is another built-in type of sequence in Python, which
represents a range of integers.  Ranges are created with <tt class="docutils literal">range</tt>, which takes
two integer arguments: the first number and one beyond the last number in the
desired range.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c1"># Includes 1, but not 10</span>
<span class="go">range(1, 10)</span>
</pre></div>

<p>Calling the <tt class="docutils literal">list</tt> constructor on a range evaluates to a list with the same
elements as the range, so that the elements can be easily inspected.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">[5, 6, 7]</span>
</pre></div>

<p>If only one argument is given, it is interpreted as one beyond the last value
for a range that starts at 0.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3]</span>
</pre></div>

<p>Ranges commonly appear as the expression in a <tt class="docutils literal">for</tt> header to specify the
number of times that the suite should be executed: A common convention is to
use a single underscore character for the name in the <tt class="docutils literal">for</tt> header if the
name is unused in the suite:</p>
<pre class="literal-block">
&gt;&gt;&gt; for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!
</pre>
<p>This underscore is just another name in the environment as far as the
interpreter is concerned, but has a conventional meaning among programmers that
indicates the name will not appear in any future expressions.</p>
</div>
<div class="section" id="sequence-processing">
<h3>2.3.3   Sequence Processing</h3>
<p>Sequences are such a common form of compound data that whole programs are often
organized around this single abstraction.  Modular components that have
sequences as both inputs and outputs can be mixed and matched to perform data
processing. Complex components can be defined by chaining together a pipeline
of sequence processing operations, each of which is simple and focused.</p>
<p><strong>List Comprehensions.</strong> Many sequence processing operations can be expressed
by evaluating a fixed expression for each element in a sequence and collecting
the resulting values in a result sequence. In Python, a list comprehension is
an expression that performs such a computation.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">odds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">odds</span><span class="p">]</span>
<span class="go">[2, 4, 6, 8, 10]</span>
</pre></div>

<p>The <tt class="docutils literal">for</tt> keyword above is not part of a <tt class="docutils literal">for</tt> statement, but instead part
of a list comprehension because it is contained within square brackets.
The sub-expression <tt class="docutils literal">x+1</tt> is evaluated with <tt class="docutils literal">x</tt> bound to each element of
<tt class="docutils literal">odds</tt> in turn, and the resulting values are collected into a list.</p>
<p>Another common sequence processing operation is to select a subset of values
that satisfy some condition. List comprehensions can also express this pattern,
for instance selecting all elements of <tt class="docutils literal">odds</tt>  that evenly divide <tt class="docutils literal">25</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">odds</span> <span class="k">if</span> <span class="mi">25</span> <span class="o">%</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">[1, 5]</span>
</pre></div>

<p>The general form of a list comprehension is:</p>
<pre class="literal-block">
[&lt;map expression&gt; for &lt;name&gt; in &lt;sequence expression&gt; if &lt;filter expression&gt;]
</pre>
<p>To evaluate a list comprehension, Python evaluates the <tt class="docutils literal">&lt;sequence
expression&gt;</tt>, which must return an iterable value.  Then, for each element in
order, the element value is bound to <tt class="docutils literal">&lt;name&gt;</tt>, the filter expression is
evaluated, and if it yields a true value, the map expression is evaluated. The
values of the map expression are collected into a list.</p>
<p><strong>Aggregation.</strong> A third common pattern in sequence processing is to aggregate
all values in a sequence into a single value. The built-in functions <tt class="docutils literal">sum</tt>,
<tt class="docutils literal">min</tt>, and <tt class="docutils literal">max</tt> are all examples of aggregation functions.</p>
<p>By combining the patterns of evaluating an expression for each element,
selecting a subset of elements, and aggregating elements, we can solve problems
using a sequence processing approach.</p>
<p>A perfect number is a positive integer that is equal to the sum of its
divisors. The divisors of <tt class="docutils literal">n</tt> are positive integers less than <tt class="docutils literal">n</tt> that
divide evenly into <tt class="docutils literal">n</tt>. Listing the divisors of <tt class="docutils literal">n</tt> can be expressed with a
list comprehension.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">divisors</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">divisors</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">[1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 6]</span>
</pre></div>

<p>Using <tt class="docutils literal">divisors</tt>, we can compute all perfect numbers from 1 to 1000 with
another list comprehension. (1 is typically considered to be a perfect number
as well, but it does not qualify under our definition of <tt class="docutils literal">divisors</tt>.)</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">divisors</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">==</span> <span class="n">n</span><span class="p">]</span>
<span class="go">[6, 28, 496]</span>
</pre></div>

<p>We can reuse our definition of <tt class="docutils literal">divisors</tt> to solve another problem, finding
the minimum perimeter of a rectangle with integer side lengths, given its area.
The area of a rectangle is its height times its width. Therefore, given the
area and height, we can compute the width. We can assert that both the width
and height evenly divide the area to ensure that the side lengths are integers.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">area</span> <span class="o">%</span> <span class="n">height</span> <span class="o">==</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">area</span> <span class="o">//</span> <span class="n">height</span>
</pre></div>

<p>The perimeter of a rectangle is the sum of its side lengths.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">height</span>
</pre></div>

<p>The height of a rectangle with integer side lengths must be a divisor of its
area. We can compute the minimum perimeter by considering all heights.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">minimum_perimeter</span><span class="p">(</span><span class="n">area</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">heights</span> <span class="o">=</span> <span class="n">divisors</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">perimeters</span> <span class="o">=</span> <span class="p">[</span><span class="n">perimeter</span><span class="p">(</span><span class="n">width</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">heights</span><span class="p">]</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">perimeters</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">area</span> <span class="o">=</span> <span class="mi">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">width</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">36</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minimum_perimeter</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
<span class="go">36</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">minimum_perimeter</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
<span class="go">[4, 6, 8, 8, 12, 10, 16, 12, 12]</span>
</pre></div>

<p><strong>Higher-Order Functions.</strong> The common patterns we have observed in sequence
processing can be expressed using higher-order functions. First, evaluating an
expression for each element in a sequence can be expressed by applying a
function to each element.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">apply_to_all</span><span class="p">(</span><span class="n">map_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="p">[</span><span class="n">map_fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>
</pre></div>

<p>Selecting only elements for which some expression is true can be expressed by
applying a function to each element.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">keep_if</span><span class="p">(</span><span class="n">filter_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">filter_fn</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
</pre></div>

<p>Finally, many forms of aggregation can be expressed as repeatedly applying a
two-argument function to the <tt class="docutils literal">reduced</tt> value so far and each element in turn.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">reduce_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">initial</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">reduced</span> <span class="o">=</span> <span class="n">initial</span>
<span class="gp">    </span>    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">reduced</span> <span class="o">=</span> <span class="n">reduce_fn</span><span class="p">(</span><span class="n">reduced</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">reduced</span>
</pre></div>

<p>For example, <tt class="docutils literal">reduce</tt> can be used to multiply together all elements of a
sequence. Using <tt class="docutils literal">mul</tt> as the <tt class="docutils literal">reduce_fn</tt> and 1 as the <tt class="docutils literal">initial</tt> value,
<tt class="docutils literal">reduce</tt> can be used to multiply together a sequence of numbers.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">64</span>
</pre></div>

<p>We can find perfect numbers using these higher-order functions as well.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">divisors_of</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">divides_n</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">n</span> <span class="o">%</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">keep_if</span><span class="p">(</span><span class="n">divides_n</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">divisors_of</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sum_of_divisors</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">divisors_of</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">perfect</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">sum_of_divisors</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">keep_if</span><span class="p">(</span><span class="n">perfect</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>
<span class="go">[1, 6, 28, 496]</span>
</pre></div>

<p><strong>Conventional Names.</strong>  In the computer science community, the more common
name for <tt class="docutils literal">apply_to_all</tt> is <tt class="docutils literal">map</tt> and the more common name for <tt class="docutils literal">keep_if</tt>
is <tt class="docutils literal">filter</tt>. In Python, the built-in <tt class="docutils literal">map</tt> and <tt class="docutils literal">filter</tt> are
generalizations of these functions that do not return lists. These functions
are discussed in Chapter 4. The definitions above are equivalent to applying
the <tt class="docutils literal">list</tt> constructor to the result of built-in <tt class="docutils literal">map</tt> and <tt class="docutils literal">filter</tt>
calls.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">apply_to_all</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">map_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">map_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keep_if</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">filter_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">filter_fn</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
</pre></div>

<p>The <tt class="docutils literal">reduce</tt> function is built into the <tt class="docutils literal">functools</tt> module of the Python
standard library. In this version, the <tt class="docutils literal">initial</tt> argument is optional.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">product</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">120</span>
</pre></div>

<p>In Python programs, it is more common to use list comprehensions directly
rather than higher-order functions, but both approaches to sequence processing
are widely used.</p>
</div>
<div class="section" id="sequence-abstraction">
<h3>2.3.4   Sequence Abstraction</h3>
<p>We have introduced two native data types that satisfy the sequence abstraction:
lists and ranges.  Both satisfy the conditions with which we began this
section: length and element selection.  Python includes two more behaviors
of sequence types that extend the sequence abstraction.</p>
<p><strong>Membership.</strong>  A value can be tested for membership in a sequence.  Python has
two operators <tt class="docutils literal">in</tt> and <tt class="docutils literal">not in</tt> that evaluate to <tt class="docutils literal">True</tt> or <tt class="docutils literal">False</tt>
depending on whether an element appears in a sequence.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">digits</span>
<span class="go">[1, 8, 2, 8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="ow">in</span> <span class="n">digits</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1828</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">digits</span>
<span class="go">True</span>
</pre></div>

<p><strong>Slicing.</strong> Sequences contain smaller sequences within them.  A <em>slice</em> of a
sequence is any contiguous span of the original sequence, designated by a pair
of integers. As with the <tt class="docutils literal">range</tt> constructor, the first integer indicates the
starting index of the slice and the second indicates one beyond the ending
index.</p>
<p>In Python, sequence slicing is expressed similarly to element selection, using
square brackets.  A colon separates the starting and ending indices.  Any bound
that is omitted is assumed to be an extreme value: 0 for the starting index,
and the length of the sequence for the ending index.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[1, 8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">digits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="go">[8, 2, 8]</span>
</pre></div>

<p>Enumerating these additional behaviors of the Python sequence abstraction gives
us an opportunity to reflect upon what constitutes a useful data abstraction in
general.  The richness of an abstraction (that is, how many behaviors it
includes) has consequences.  For users of an abstraction, additional behaviors
can be helpful.  On the other hand, satisfying the requirements of a rich
abstraction with a new data type can be challenging. Another negative
consequence of rich abstractions is that they take longer for users to learn.</p>
<p>Sequences have a rich abstraction because they are so ubiquitous in computing
that learning a few complex behaviors is justified.  In general, most
user-defined abstractions should be kept as simple as possible.</p>
<p><strong>Further reading.</strong> Slice notation admits a variety of special cases, such as
negative starting values, ending values, and step sizes.  A complete description
appears in the subsection called
<a class="reference external" href="http://getpython3.com/diveintopython3/native-datatypes.html#slicinglists">slicing a list</a>
in Dive Into Python 3.  In this chapter, we will only use the basic features
described above.</p>
</div>
<div class="section" id="strings">
<h3>2.3.5   Strings</h3>
<p>Text values are perhaps more fundamental to computer science than even numbers.
As a case in point, Python programs are written and stored as text.  The native
data type for text in Python is called a string, and corresponds to the
constructor <tt class="docutils literal">str</tt>.</p>
<p>There are many details of how strings are represented, expressed, and
manipulated in Python. Strings are another example of a rich abstraction, one
that requires a substantial commitment on the part of the programmer to master.
This section serves as a condensed introduction to essential string behaviors.</p>
<p>String literals can express arbitrary text, surrounded by either single or
double quotation marks.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'I am string!'</span>
<span class="go">'I am string!'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">"I've got an apostrophe"</span>
<span class="go">"I've got an apostrophe"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'您好'</span>
<span class="go">'您好'</span>
</pre></div>

<p>We have seen strings already in our code, as docstrings, in calls to <tt class="docutils literal">print</tt>,
and as error messages in <tt class="docutils literal">assert</tt> statements.</p>
<p>Strings satisfy the two basic conditions of a sequence that we introduced at the
beginning of this section: they have a length and they support element
selection.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">city</span> <span class="o">=</span> <span class="s1">'Berkeley'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">city</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">city</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">'k'</span>
</pre></div>

<p>The elements of a string are themselves strings that have only a single
character.  A character is any single letter of the alphabet, punctuation
mark, or other symbol.  Unlike many other programming languages, Python does
not have a separate character type; any text is a string, and strings that
represent single characters have a length of 1.</p>
<p>Like lists, strings can also be combined via addition and multiplication.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'Berkeley'</span> <span class="o">+</span> <span class="s1">', CA'</span>
<span class="go">'Berkeley, CA'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'Shabu '</span> <span class="o">*</span> <span class="mi">2</span>
<span class="go">'Shabu Shabu '</span>
</pre></div>

<p><strong>Membership.</strong> The behavior of strings diverges from other sequence
types in Python.  The string abstraction does not conform to the full sequence
abstraction that we described for lists and ranges.  In particular, the
membership operator <tt class="docutils literal">in</tt> applies to strings, but has an entirely different
behavior than when it is applied to sequences.  It matches substrings rather
than elements.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'here'</span> <span class="ow">in</span> <span class="s2">"Where's Waldo?"</span>
<span class="go">True</span>
</pre></div>

<p><strong>Multiline Literals.</strong> Strings aren't limited to a single line. Triple quotes
delimit string literals that span multiple lines.  We have used this triple
quoting extensively already for docstrings.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">"""The Zen of Python</span>
<span class="go">claims, Readability counts.</span>
<span class="go">Read more: import this."""</span>
<span class="go">'The Zen of Python\nclaims, "Readability counts."\nRead more: import this.'</span>
</pre></div>

<p>In the printed result above, the <tt class="docutils literal">\n</tt> (pronounced "<em>backslash en</em>") is a
single element that represents a new line.  Although it appears as two
characters (backslash and "n"), it is considered a single character for the
purposes of length and element selection.</p>
<p><strong>String Coercion.</strong> A string can be created from any object in Python by
calling the <tt class="docutils literal">str</tt> constructor function with an object value as its argument.
This feature of strings is useful for constructing descriptive strings from
objects of various types.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s1">' is an element of '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span>
<span class="go">'2 is an element of [1, 8, 2, 8]'</span>
</pre></div>

<p><strong>Further reading.</strong> Encoding text in computers is a complex topic.  In this
chapter, we will abstract away the details of how strings are represented.
However, for many applications, the particular details of how strings are
encoded by computers is essential knowledge. <a class="reference external" href="http://getpython3.com/diveintopython3/strings.html">The strings chapter of Dive Into
Python 3</a> provides a
description of character encodings and Unicode.</p>
</div>
<div class="section" id="trees">
<h3>2.3.6   Trees</h3>
<p>Our ability to use lists as the elements of other lists provides a new means of
combination in our programming language.  This ability is called a <em>closure
property</em> of a data type.  In general, a method for combining data values
has a closure property if the result of combination can itself be combined
using the same method.  Closure is the key to power in any means of combination
because it permits us to create hierarchical structures — structures made up of
parts, which themselves are made up of parts, and so on.</p>
<p>We can visualize lists in environment diagrams using <em>box-and-pointer</em>
notation. A list is depicted as adjacent boxes that contain the elements of the
list. Primitive values such as numbers, strings, boolean values, and <tt class="docutils literal">None</tt>
appear within an element box.  Composite values, such as function values and
other lists, are indicated by an arrow.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_0" style="">
one_two = [1, 2]
nested = [[1, 2], [],
          [[3, False, None],
           [4, lambda: 5]]]
</div>
<script type="text/javascript">
var example_0_trace = {"code": "one_two = [1, 2]\nnested = [[1, 2], [],\n          [[3, False, None],\n           [4, lambda: 5]]]", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"one_two": ["REF", 1]}, "heap": {"1": ["LIST", 1, 2]}, "line": 2, "ordered_globals": ["one_two"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"one_two": ["REF", 1]}, "heap": {"1": ["LIST", 1, 2]}, "line": 3, "ordered_globals": ["one_two"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"one_two": ["REF", 1]}, "heap": {"1": ["LIST", 1, 2]}, "line": 4, "ordered_globals": ["one_two"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"nested": ["REF", 2], "one_two": ["REF", 1]}, "heap": {"1": ["LIST", 1, 2], "2": ["LIST", ["REF", 3], ["REF", 4], ["REF", 5]], "3": ["LIST", 1, 2], "4": ["LIST"], "5": ["LIST", ["REF", 6], ["REF", 7]], "6": ["LIST", 3, false, null], "7": ["LIST", 4, ["REF", 8]], "8": ["FUNCTION", "<lambda>() <line 4>", null]}, "line": 4, "ordered_globals": ["one_two", "nested"], "stack_to_render": [], "stdout": ""}]}</script><p>Nesting lists within lists can introduce complexity. The <em>tree</em> is a
fundamental data abstraction that imposes regularity on how hierarchical values
are structured and manipulated.</p>
<p>A tree has a root label and a sequence of branches. Each branch of a tree is a
tree. A tree with no branches is called a leaf. Any tree contained within a
tree is called a sub-tree of that tree (such as a branch of a branch). The root
of each sub-tree of a tree is called a node in that tree.</p>
<p>The data abstraction for a tree consists of the constructor <tt class="docutils literal">tree</tt> and the
selectors <tt class="docutils literal">label</tt> and <tt class="docutils literal">branches</tt>. We begin with a simplified version.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">tree</span><span class="p">(</span><span class="n">root_label</span><span class="p">,</span> <span class="n">branches</span><span class="o">=</span><span class="p">[]):</span>
<span class="gp">    </span>    <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">assert</span> <span class="n">is_tree</span><span class="p">(</span><span class="n">branch</span><span class="p">),</span> <span class="s1">'branches must be trees'</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="p">[</span><span class="n">root_label</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">branches</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">branches</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</pre></div>

<p>A tree is well-formed only if it has a root label and all branches are also
trees. The <tt class="docutils literal">is_tree</tt> function is applied in the <tt class="docutils literal">tree</tt> constructor to
verify that all branches are well-formed.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">is_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">    </span>    <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_tree</span><span class="p">(</span><span class="n">branch</span><span class="p">):</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="kc">False</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="kc">True</span>
</pre></div>

<p>The <tt class="docutils literal">is_leaf</tt> function checks whether or not a tree has branches.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="ow">not</span> <span class="n">branches</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>

<p>Trees can be constructed by nested expressions. The following tree <tt class="docutils literal">t</tt> has
root label 3 and two branches.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="n">tree</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">tree</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">tree</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">tree</span><span class="p">(</span><span class="mi">1</span><span class="p">)])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span>
<span class="go">[3, [1], [2, [1], [1]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">branches</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">[[1], [2, [1], [1]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label</span><span class="p">(</span><span class="n">branches</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_leaf</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_leaf</span><span class="p">(</span><span class="n">branches</span><span class="p">(</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>

<p>Tree-recursive functions can be used to construct trees. For example, the nth
Fibonacci tree has a root label of the nth Fibonacci number and, for <tt class="docutils literal">n &gt; 1</tt>,
two branches that are also Fibonacci trees. A Fibonacci tree illustrates the
tree-recursive computation of a Fibonacci number.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fib_tree</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">tree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">fib_tree</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">fib_tree</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">    </span>        <span class="n">fib_n</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">label</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">tree</span><span class="p">(</span><span class="n">fib_n</span><span class="p">,</span> <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[5, [2, [1], [1, [0], [1]]], [3, [1, [0], [1]], [2, [1], [1, [0], [1]]]]]</span>
</pre></div>

<p>Tree-recursive functions are also used to process trees. For example, the
<tt class="docutils literal">count_leaves</tt> function counts the leaves of a tree.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">count_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="gp">    </span>  <span class="k">if</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="gp">    </span>      <span class="k">return</span> <span class="mi">1</span>
<span class="gp">    </span>  <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>      <span class="n">branch_counts</span> <span class="o">=</span> <span class="p">[</span><span class="n">count_leaves</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">(</span><span class="n">tree</span><span class="p">)]</span>
<span class="gp">    </span>      <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">branch_counts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count_leaves</span><span class="p">(</span><span class="n">fib_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">8</span>
</pre></div>

<p><strong>Partition trees.</strong> Trees can also be used to represent the partitions of an
integer. A partition tree for <tt class="docutils literal">n</tt> using parts up to size <tt class="docutils literal">m</tt> is a binary
(two branch) tree that represents the choices taken during computation. In a
non-leaf partition tree:</p>
<ul class="simple">
<li>the left (index 0) branch contains all ways of partitioning <tt class="docutils literal">n</tt> using at
least one <tt class="docutils literal">m</tt>,</li>
<li>the right (index 1) branch contains partitions using parts up to <tt class="docutils literal"><span class="pre">m-1</span></tt>, and</li>
<li>the root label is <tt class="docutils literal">m</tt>.</li>
</ul>
<p>The labels at the leaves of a partition tree express whether the path from the
root of the tree to the leaf represents a successful partition of <tt class="docutils literal">n</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">partition_tree</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a partition tree of n using parts of up to m."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">tree</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">tree</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">left</span> <span class="o">=</span> <span class="n">partition_tree</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">    </span>        <span class="n">right</span> <span class="o">=</span> <span class="n">partition_tree</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">tree</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">])</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">partition_tree</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[2, [True], [1, [1, [True], [False]], [False]]]</span>
</pre></div>

<p>Printing the partitions from a partition tree is another tree-recursive process
that traverses the tree, constructing each partition as a list. Whenever
a <tt class="docutils literal">True</tt> leaf is reached, the partition is printed.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_parts</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">partition</span><span class="o">=</span><span class="p">[]):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">label</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="gp">    </span>            <span class="nb">print</span><span class="p">(</span><span class="s1">' + '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">partition</span><span class="p">))</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">branches</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="gp">    </span>        <span class="n">m</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
<span class="gp">    </span>        <span class="n">print_parts</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">partition</span> <span class="o">+</span> <span class="p">[</span><span class="n">m</span><span class="p">])</span>
<span class="gp">    </span>        <span class="n">print_parts</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_parts</span><span class="p">(</span><span class="n">partition_tree</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">4 + 2</span>
<span class="go">4 + 1 + 1</span>
<span class="go">3 + 3</span>
<span class="go">3 + 2 + 1</span>
<span class="go">3 + 1 + 1 + 1</span>
<span class="go">2 + 2 + 2</span>
<span class="go">2 + 2 + 1 + 1</span>
<span class="go">2 + 1 + 1 + 1 + 1</span>
<span class="go">1 + 1 + 1 + 1 + 1 + 1</span>
</pre></div>

<p>Slicing can be used on the branches of a tree as well. For example, we may want
to place a restriction on the number of branches in a tree. A binarized tree has
at most two branches. A common tree transformation called <em>binarization</em> finds a
binarized tree with the same labels as an original tree by grouping together
branches.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">right_binarize</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Construct a right-branching binary tree."""</span>
<span class="gp">    </span><span class="k">return</span> <span class="n">tree</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">binarize_branches</span><span class="p">(</span><span class="n">branches</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">binarize_branches</span><span class="p">(</span><span class="n">bs</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Binarize a list of branches."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">first</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">bs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="p">[</span><span class="n">right_binarize</span><span class="p">(</span><span class="n">first</span><span class="p">),</span> <span class="n">binarize_branches</span><span class="p">(</span><span class="n">rest</span><span class="p">)]</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="p">[</span><span class="n">right_binarize</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bs</span><span class="p">]</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">right_binarize</span><span class="p">(</span><span class="n">tree</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">tree</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]))</span>
<span class="go">[0, [1], [[2], [[3], [[4], [[5], [[6], [7]]]]]]]</span>
</pre></div>

</div>
<div class="section" id="linked-lists">
<h3>2.3.7   Linked Lists</h3>
<p>So far, we have used only native types to represent sequences. However, we can
also develop sequence representations that are not built into Python. A
common representation of a sequence constructed from nested pairs is called a
<em>linked list</em>. The environment diagram below illustrates the linked list
representation of a four-element sequence containing 1, 2, 3, and 4.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_1" style="">
four = [1, [2, [3, [4, 'empty']]]]
</div>
<script type="text/javascript">
var example_1_trace = {"code": "four = [1, [2, [3, [4, 'empty']]]]", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"four": ["REF", 1]}, "heap": {"1": ["LIST", 1, ["REF", 2]], "2": ["LIST", 2, ["REF", 3]], "3": ["LIST", 3, ["REF", 4]], "4": ["LIST", 4, "empty"]}, "line": 1, "ordered_globals": ["four"], "stack_to_render": [], "stdout": ""}]}</script><p>A linked list is a pair containing the first element of the sequence (in this
case 1) and the rest of the sequence (in this case a representation of 2, 3,
4).  The second element is also a linked list. The rest of the inner-most
linked list containing only 4 is <tt class="docutils literal">'empty'</tt>, a value that represents an empty
linked list.</p>
<p>Linked lists have recursive structure: the rest of a linked list is a linked
list or <tt class="docutils literal">'empty'</tt>. We can define an abstract data representation to validate,
construct, and select the components of linked lists.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">empty</span> <span class="o">=</span> <span class="s1">'empty'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""s is a linked list if it is empty or a (first, rest) pair."""</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">s</span> <span class="o">==</span> <span class="n">empty</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">link</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">rest</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Construct a linked list from its first element and the rest."""</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">is_link</span><span class="p">(</span><span class="n">rest</span><span class="p">),</span> <span class="s2">"rest must be a linked list."</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="n">rest</span><span class="p">]</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return the first element of a linked list s."""</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s2">"first only applies to linked lists."</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">empty</span><span class="p">,</span> <span class="s2">"empty linked list has no first element."</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rest</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return the rest of the elements of a linked list s."""</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s2">"rest only applies to linked lists."</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">empty</span><span class="p">,</span> <span class="s2">"empty linked list has no rest."</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>

<p>Above, <tt class="docutils literal">link</tt> is a constructor and <tt class="docutils literal">first</tt> and <tt class="docutils literal">rest</tt> are selectors for
an abstract data representation of linked lists. The behavior condition for a
linked list is that, like a pair, its constructor and selectors are inverse
functions.</p>
<ul class="simple">
<li>If a linked list <tt class="docutils literal">s</tt> was constructed from first element <tt class="docutils literal">f</tt> and linked
list <tt class="docutils literal">r</tt>, then <tt class="docutils literal">first(s)</tt> returns <tt class="docutils literal">f</tt>, and <tt class="docutils literal">rest(s)</tt> returns <tt class="docutils literal">r</tt>.</li>
</ul>
<p>We can use the constructor and selectors to manipulate linked lists.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">four</span> <span class="o">=</span> <span class="n">link</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">link</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">link</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">empty</span><span class="p">))))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">first</span><span class="p">(</span><span class="n">four</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rest</span><span class="p">(</span><span class="n">four</span><span class="p">)</span>
<span class="go">[2, [3, [4, 'empty']]]</span>
</pre></div>

<p>Our implementation of this kind of abstract data uses pairs that are
two-element <tt class="docutils literal">list</tt> values. It is worth noting that we were also able to
implement pairs using functions, and we can implement linked lists using any
pairs, therefore we could implement linked lists using functions alone.</p>
<p>The linked list can store a sequence of values in order, but we have not yet
shown that it satisfies the sequence abstraction.  Using the abstract data
representation we have defined, we can implement the two behaviors that
characterize a sequence: length and element selection.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">len_link</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return the length of linked list s."""</span>
<span class="gp">    </span>    <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">s</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">length</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">getitem_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return the element at index i of linked list s."""</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>

<p>Now, we can manipulate a linked list as a sequence using these functions.
(We cannot yet use the built-in <tt class="docutils literal">len</tt> function, element selection syntax, or
<tt class="docutils literal">for</tt> statement, but we will soon.)</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">len_link</span><span class="p">(</span><span class="n">four</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getitem_link</span><span class="p">(</span><span class="n">four</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>

<p>The series of environment diagrams below illustrate the iterative process by
which <tt class="docutils literal">getitem_link</tt> finds the element 2 at index 1 in a linked
list. Below, we have defined the linked list <tt class="docutils literal">four</tt> using Python primitives to
simplify the diagrams. This implementation choice violates an abstraction
barrier, but allows us to inspect the computational process more easily for
this example.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="4" id="example_2" style="">
def first(s):
    return s[0]
def rest(s):
    return s[1]

def getitem_link(s, i):
    while i &gt; 0:
        s, i = rest(s), i - 1
    return first(s)

four = [1, [2, [3, [4, 'empty']]]]
getitem_link(four, 1)
</div>
<script type="text/javascript">
var example_2_trace = {"code": "def first(s):\n    return s[0]\ndef rest(s):\n    return s[1]\n\ndef getitem_link(s, i):\n    while i > 0:\n        s, i = rest(s), i - 1\n    return first(s)\n\nfour = [1, [2, [3, [4, 'empty']]]]\ngetitem_link(four, 1)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1]}, "heap": {"1": ["FUNCTION", "first(s)", null]}, "line": 3, "ordered_globals": ["first"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null]}, "line": 6, "ordered_globals": ["first", "rest"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null]}, "line": 11, "ordered_globals": ["first", "rest", "getitem_link"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 12, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 6, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 7, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 8, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}], "stdout": ""}, {"event": "call", "func_name": "rest", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 3, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "rest_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "rest", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 4, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "rest_f2"}], "stdout": ""}, {"event": "return", "func_name": "rest", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 4, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 7, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 9, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}], "stdout": ""}, {"event": "call", "func_name": "first", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 1, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "first_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "first", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 2, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "first_f3"}], "stdout": ""}, {"event": "return", "func_name": "first", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 2, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"__return__": 2, "s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "first_f3"}], "stdout": ""}, {"event": "return", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 9, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"__return__": 2, "i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i", "__return__"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"__return__": 2, "s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "first_f3_z"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 12, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"__return__": 2, "i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "i", "__return__"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1_z"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"__return__": 2, "s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "first_f3_z"}], "stdout": ""}]}</script><p>First, the function <tt class="docutils literal">getitem_link</tt> is called, creating a local frame.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="5" id="example_3" style="">
def first(s):
    return s[0]
def rest(s):
    return s[1]

def getitem_link(s, i):
    while i &gt; 0:
        s, i = rest(s), i - 1
    return first(s)

four = [1, [2, [3, [4, 'empty']]]]
getitem_link(four, 1)
</div>
<script type="text/javascript">
var example_3_trace = {"code": "def first(s):\n    return s[0]\ndef rest(s):\n    return s[1]\n\ndef getitem_link(s, i):\n    while i > 0:\n        s, i = rest(s), i - 1\n    return first(s)\n\nfour = [1, [2, [3, [4, 'empty']]]]\ngetitem_link(four, 1)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1]}, "heap": {"1": ["FUNCTION", "first(s)", null]}, "line": 3, "ordered_globals": ["first"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null]}, "line": 6, "ordered_globals": ["first", "rest"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null]}, "line": 11, "ordered_globals": ["first", "rest", "getitem_link"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 12, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 6, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 7, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 8, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}], "stdout": ""}, {"event": "call", "func_name": "rest", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 3, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "rest_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "rest", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 4, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "rest_f2"}], "stdout": ""}, {"event": "return", "func_name": "rest", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 4, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 7, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 9, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}], "stdout": ""}, {"event": "call", "func_name": "first", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 1, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "first_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "first", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 2, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "first_f3"}], "stdout": ""}, {"event": "return", "func_name": "first", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 2, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"__return__": 2, "s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "first_f3"}], "stdout": ""}, {"event": "return", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 9, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"__return__": 2, "i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i", "__return__"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"__return__": 2, "s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "first_f3_z"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 12, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"__return__": 2, "i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "i", "__return__"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1_z"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"__return__": 2, "s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "first_f3_z"}], "stdout": ""}]}</script><p>The expression in the <tt class="docutils literal">while</tt> header evaluates to true, which causes the
assignment statement in the <tt class="docutils literal">while</tt> suite to be executed.  The function
<tt class="docutils literal">rest</tt> returns the sublist starting with 2.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="8" id="example_4" style="">
def first(s):
    return s[0]
def rest(s):
    return s[1]

def getitem_link(s, i):
    while i &gt; 0:
        s, i = rest(s), i - 1
    return first(s)

four = [1, [2, [3, [4, 'empty']]]]
getitem_link(four, 1)
</div>
<script type="text/javascript">
var example_4_trace = {"code": "def first(s):\n    return s[0]\ndef rest(s):\n    return s[1]\n\ndef getitem_link(s, i):\n    while i > 0:\n        s, i = rest(s), i - 1\n    return first(s)\n\nfour = [1, [2, [3, [4, 'empty']]]]\ngetitem_link(four, 1)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1]}, "heap": {"1": ["FUNCTION", "first(s)", null]}, "line": 3, "ordered_globals": ["first"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null]}, "line": 6, "ordered_globals": ["first", "rest"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null]}, "line": 11, "ordered_globals": ["first", "rest", "getitem_link"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 12, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 6, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 7, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 8, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}], "stdout": ""}, {"event": "call", "func_name": "rest", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 3, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "rest_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "rest", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 4, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "rest_f2"}], "stdout": ""}, {"event": "return", "func_name": "rest", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 4, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 7, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 9, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}], "stdout": ""}, {"event": "call", "func_name": "first", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 1, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "first_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "first", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 2, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "first_f3"}], "stdout": ""}, {"event": "return", "func_name": "first", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 2, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"__return__": 2, "s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "first_f3"}], "stdout": ""}, {"event": "return", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 9, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"__return__": 2, "i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i", "__return__"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"__return__": 2, "s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "first_f3_z"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 12, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"__return__": 2, "i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "i", "__return__"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1_z"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"__return__": 2, "s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "first_f3_z"}], "stdout": ""}]}</script><p>Next, the local name <tt class="docutils literal">s</tt> will be updated to refer to the sub-list that begins
with the second element of the original list.  Evaluating the <tt class="docutils literal">while</tt> header
expression now yields a false value, and so Python evaluates the expression in
the return statement on the final line of <tt class="docutils literal">getitem_link</tt>.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="12" id="example_5" style="">
def first(s):
    return s[0]
def rest(s):
    return s[1]

def getitem_link(s, i):
    while i &gt; 0:
        s, i = rest(s), i - 1
    return first(s)

four = [1, [2, [3, [4, 'empty']]]]
getitem_link(four, 1)
</div>
<script type="text/javascript">
var example_5_trace = {"code": "def first(s):\n    return s[0]\ndef rest(s):\n    return s[1]\n\ndef getitem_link(s, i):\n    while i > 0:\n        s, i = rest(s), i - 1\n    return first(s)\n\nfour = [1, [2, [3, [4, 'empty']]]]\ngetitem_link(four, 1)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1]}, "heap": {"1": ["FUNCTION", "first(s)", null]}, "line": 3, "ordered_globals": ["first"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null]}, "line": 6, "ordered_globals": ["first", "rest"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null]}, "line": 11, "ordered_globals": ["first", "rest", "getitem_link"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 12, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 6, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 7, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 8, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}], "stdout": ""}, {"event": "call", "func_name": "rest", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 3, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "rest_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "rest", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 4, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "rest_f2"}], "stdout": ""}, {"event": "return", "func_name": "rest", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 4, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 1, "s": ["REF", 4]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 7, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}], "stdout": ""}, {"event": "step_line", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 9, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}], "stdout": ""}, {"event": "call", "func_name": "first", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 1, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "first_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "first", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 2, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s"], "parent_frame_id_list": [], "unique_hash": "first_f3"}], "stdout": ""}, {"event": "return", "func_name": "first", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 2, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"__return__": 2, "s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "first_f3"}], "stdout": ""}, {"event": "return", "func_name": "getitem_link", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 9, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"__return__": 2, "i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["s", "i", "__return__"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"__return__": 2, "s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "first_f3_z"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"first": ["REF", 1], "four": ["REF", 4], "getitem_link": ["REF", 3], "rest": ["REF", 2]}, "heap": {"1": ["FUNCTION", "first(s)", null], "2": ["FUNCTION", "rest(s)", null], "3": ["FUNCTION", "getitem_link(s, i)", null], "4": ["LIST", 1, ["REF", 5]], "5": ["LIST", 2, ["REF", 6]], "6": ["LIST", 3, ["REF", 7]], "7": ["LIST", 4, "empty"]}, "line": 12, "ordered_globals": ["first", "rest", "getitem_link", "four"], "stack_to_render": [{"encoded_locals": {"__return__": 2, "i": 0, "s": ["REF", 5]}, "frame_id": 1, "func_name": "getitem_link", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "i", "__return__"], "parent_frame_id_list": [], "unique_hash": "getitem_link_f1_z"}, {"encoded_locals": {"__return__": ["REF", 5], "s": ["REF", 4]}, "frame_id": 2, "func_name": "rest", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "rest_f2_z"}, {"encoded_locals": {"__return__": 2, "s": ["REF", 5]}, "frame_id": 3, "func_name": "first", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["s", "__return__"], "parent_frame_id_list": [], "unique_hash": "first_f3_z"}], "stdout": ""}]}</script><p>This final environment diagram shows the local frame for the call to <tt class="docutils literal">first</tt>,
which contains the name <tt class="docutils literal">s</tt> bound to that same sub-list.  The <tt class="docutils literal">first</tt>
function selects the value 2 and returns it, which will also be returned
from <tt class="docutils literal">getitem_link</tt>.</p>
<p>This example demonstrates a common pattern of computation with linked lists,
where each step in an iteration operates on an increasingly shorter suffix of
the original list. This incremental processing to find the length and elements
of a linked list does take some time to compute. Python's built-in sequence
types are implemented in a different way that does not have a large cost for
computing the length of a sequence or retrieving its elements. The details of
that representation are beyond the scope of this text.</p>
<p><strong>Recursive manipulation.</strong> Both <tt class="docutils literal">len_link</tt> and <tt class="docutils literal">getitem_link</tt> are
iterative. They peel away each layer of nested pair until the end of the list
(in <tt class="docutils literal">len_link</tt>) or the desired element (in <tt class="docutils literal">getitem_link</tt>) is reached. We
can also implement length and element selection using recursion.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">len_link_recursive</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return the length of a linked list s."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">len_link_recursive</span><span class="p">(</span><span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">getitem_link_recursive</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return the element at index i of linked list s."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">getitem_link_recursive</span><span class="p">(</span><span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">len_link_recursive</span><span class="p">(</span><span class="n">four</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getitem_link_recursive</span><span class="p">(</span><span class="n">four</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>

<p>These recursive implementations follow the chain of pairs until the end of the
list (in <tt class="docutils literal">len_link_recursive</tt>) or the desired element (in
<tt class="docutils literal">getitem_link_recursive</tt>) is reached.</p>
<p>Recursion is also useful for transforming and combining linked lists.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">extend_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a list with the elements of s followed by those of t."""</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_link</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">t</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">link</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">extend_link</span><span class="p">(</span><span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">t</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">extend_link</span><span class="p">(</span><span class="n">four</span><span class="p">,</span> <span class="n">four</span><span class="p">)</span>
<span class="go">[1, [2, [3, [4, [1, [2, [3, [4, 'empty']]]]]]]]</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">apply_to_all_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Apply f to each element of s."""</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">s</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">link</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">apply_to_all_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">apply_to_all_link</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">four</span><span class="p">)</span>
<span class="go">[1, [4, [9, [16, 'empty']]]]</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">keep_if_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a list with elements of s for which f(e) is true."""</span>
<span class="gp">    </span>    <span class="k">assert</span> <span class="n">is_link</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">s</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">kept</span> <span class="o">=</span> <span class="n">keep_if_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">link</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">kept</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">kept</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">keep_if_link</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">four</span><span class="p">)</span>
<span class="go">[2, [4, 'empty']]</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">join_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">separator</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a string of all elements in s separated by separator."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="s2">""</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">+</span> <span class="n">separator</span> <span class="o">+</span> <span class="n">join_link</span><span class="p">(</span><span class="n">rest</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">separator</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">join_link</span><span class="p">(</span><span class="n">four</span><span class="p">,</span> <span class="s2">", "</span><span class="p">)</span>
<span class="go">'1, 2, 3, 4'</span>
</pre></div>

<p><strong>Recursive Construction.</strong> Linked lists are particularly useful when
constructing sequences incrementally, a situation that arises often in
recursive computations.</p>
<p>The <tt class="docutils literal">count_partitions</tt> function from Chapter 1 counted the number of ways
to partition an integer <tt class="docutils literal">n</tt> using parts up to size <tt class="docutils literal">m</tt> via a tree-recursive
process. With sequences, we can also enumerate these partitions explicitly
using a similar process.</p>
<p>We follow the same recursive analysis of the problem as we did while counting:
partitioning <tt class="docutils literal">n</tt> using integers up to <tt class="docutils literal">m</tt> involves either</p>
<ol class="arabic simple">
<li>partitioning <tt class="docutils literal"><span class="pre">n-m</span></tt> using integers up to <tt class="docutils literal">m</tt>, or</li>
<li>partitioning <tt class="docutils literal">n</tt> using integers up to <tt class="docutils literal"><span class="pre">m-1</span></tt>.</li>
</ol>
<p>For base cases, we find that 0 has an empty partition, while partitioning a
negative integer or using parts smaller than 1 is impossible.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a linked list of partitions of n using parts of up to m.</span>
<span class="gp">    </span><span class="sd">    Each partition is represented as a linked list.</span>
<span class="gp">    </span><span class="sd">    """</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">link</span><span class="p">(</span><span class="n">empty</span><span class="p">,</span> <span class="n">empty</span><span class="p">)</span> <span class="c1"># A list containing the empty partition</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">empty</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">using_m</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">    </span>        <span class="n">with_m</span> <span class="o">=</span> <span class="n">apply_to_all_link</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">link</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">using_m</span><span class="p">)</span>
<span class="gp">    </span>        <span class="n">without_m</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">extend_link</span><span class="p">(</span><span class="n">with_m</span><span class="p">,</span> <span class="n">without_m</span><span class="p">)</span>
</pre></div>

<p>In the recursive case, we construct two sublists of partitions. The first uses
<tt class="docutils literal">m</tt>, and so we prepend <tt class="docutils literal">m</tt> to each element of the result <tt class="docutils literal">using_m</tt> to
form <tt class="docutils literal">with_m</tt>.</p>
<p>The result of <tt class="docutils literal">partitions</tt> is highly nested: a linked list of linked lists,
and each linked list is represented as nested pairs that are <tt class="docutils literal">list</tt> values.
Using <tt class="docutils literal">join_link</tt> with appropriate separators, we can display the partitions
in a human-readable manner.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">lists</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">strings</span> <span class="o">=</span> <span class="n">apply_to_all_link</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">join_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">" + "</span><span class="p">),</span> <span class="n">lists</span><span class="p">)</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="n">join_link</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">4 + 2</span>
<span class="go">4 + 1 + 1</span>
<span class="go">3 + 3</span>
<span class="go">3 + 2 + 1</span>
<span class="go">3 + 1 + 1 + 1</span>
<span class="go">2 + 2 + 2</span>
<span class="go">2 + 2 + 1 + 1</span>
<span class="go">2 + 1 + 1 + 1 + 1</span>
<span class="go">1 + 1 + 1 + 1 + 1 + 1</span>
</pre></div>

</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/24-mutable-data.html">
  		2.4 Mutable Data
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="mutable-data">
<h2>2.4   Mutable Data</h2>
<p>We have seen how abstraction is vital in helping us to cope with the complexity
of large systems.  Effective programming also requires organizational
principles that can guide us in formulating the overall design of a program. In
particular, we need strategies to help us structure large systems to be
modular, meaning that they divide naturally into coherent parts that can be
separately developed and maintained.</p>
<p>One powerful technique for creating modular programs is to incorporate data
that may change state over time.  In this way, a single data object can
represent something that evolves independently of the rest of the program. The
behavior of a changing object may be influenced by its history, just like an
entity in the world. Adding state to data is a central ingredient of a paradigm
called object-oriented programming.</p>
<div class="section" id="the-object-metaphor">
<h3>2.4.1   The Object Metaphor</h3>
<p>In the beginning of this text, we distinguished between functions and data:
functions performed operations and data were operated upon.  When we included
function values among our data, we acknowledged that data too can have
behavior. Functions could be manipulated as data, but could also be called to
perform computation.</p>
<p><em>Objects</em> combine data values with behavior.  Objects represent information,
but also <em>behave</em> like the things that they represent.  The logic of how an
object interacts with other objects is bundled along with the
information that encodes the object's value.  When an object is printed, it
knows how to spell itself out in text.  If an object is composed of parts, it
knows how to reveal those parts on demand.  Objects are both information and
processes, bundled together to represent the properties, interactions, and
behaviors of complex things.</p>
<p>Object behavior is implemented in Python through specialized object syntax
and associated terminology, which we can introduce by example.  A date is a
kind of object.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">date</span>
</pre></div>

<p>The name <tt class="docutils literal">date</tt> is bound to a <em>class</em>. As we have seen, a class represents a
kind of value. Individual dates are called <em>instances</em> of that class.
Instances can be <em>constructed</em> by calling the class on arguments that
characterize the instance.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tues</span> <span class="o">=</span> <span class="n">date</span><span class="p">(</span><span class="mi">2014</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
</pre></div>

<p>While <tt class="docutils literal">tues</tt> was constructed from primitive numbers, it behaves like a date.
For instance, subtracting it from another date will give a time difference,
which we can print.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">date</span><span class="p">(</span><span class="mi">2014</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">19</span><span class="p">)</span> <span class="o">-</span> <span class="n">tues</span><span class="p">)</span>
<span class="go">6 days, 0:00:00</span>
</pre></div>

<p>Objects have <em>attributes</em>, which are named values that are part of the object.
In Python, like many other programming languages, we use dot notation to
designate an attribute of an object.</p>
<blockquote>
&lt;expression&gt; . &lt;name&gt;</blockquote>
<p>Above, the <tt class="docutils literal">&lt;expression&gt;</tt> evaluates to an object, and <tt class="docutils literal">&lt;name&gt;</tt> is the name
of an attribute for that object.</p>
<p>Unlike the names that we have considered so far, these attribute names are not
available in the general environment.  Instead, attribute names are particular
to the object instance preceding the dot.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tues</span><span class="o">.</span><span class="n">year</span>
<span class="go">2014</span>
</pre></div>

<p>Objects also have <em>methods</em>, which are function-valued attributes.
Metaphorically, we say that the object "knows" how to carry out those methods.
By implementation, methods are functions that compute their results from both
their arguments and their object.  For example, The <tt class="docutils literal">strftime</tt> method
(a classic function name meant to evoke "string format of time") of <tt class="docutils literal">tues</tt>
takes a single argument that specifies how to display a date (e.g., <tt class="docutils literal">%A</tt>
means that the day of the week should be spelled out in full).</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tues</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">'%A, %B </span><span class="si">%d</span><span class="s1">'</span><span class="p">)</span>
<span class="go">'Tuesday, May 13'</span>
</pre></div>

<p>Computing the return value  of <tt class="docutils literal">strftime</tt> requires two inputs: the string
that describes the format of the output and the date information bundled into
<tt class="docutils literal">tues</tt>.  Date-specific logic is applied within this method to yield this
result.  We never stated that the 13th of May, 2014, was a Tuesday, but
knowing the corresponding weekday is part of what it means to be a date.  By
bundling behavior and information together, this Python object offers us a
convincing, self-contained abstraction of a date.</p>
<p>Dates are objects, but numbers, strings, lists, and ranges are all objects as
well. They represent values, but also behave in a manner that befits the values
they represent. They also have attributes and methods. For instance, strings
have an array of methods that facilitate text processing.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'1234'</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'rOBERT dE nIRO'</span><span class="o">.</span><span class="n">swapcase</span><span class="p">()</span>
<span class="go">'Robert De Niro'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'eyes'</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">'YES'</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>

<p>In fact, all values in Python are objects. That is, all values have behavior
and attributes. They act like the values they represent.</p>
</div>
<div class="section" id="sequence-objects">
<h3>2.4.2   Sequence Objects</h3>
<p>Instances of primitive built-in values such as numbers are <em>immutable</em>. The
values themselves cannot change over the course of program execution. Lists on
the other hand are <em>mutable</em>.</p>
<p>Mutable objects are used to represent values that change over time. A person is
the same person from one day to the next, despite having aged, received a
haircut, or otherwise changed in some way. Similarly, an object may have
changing properties due to <em>mutating</em> operations. For example,  it is possible
to change the contents of a list. Most changes are performed by invoking
methods on list objects.</p>
<p>We can introduce many list modification operations through an example that
illustrates the history of playing cards (drastically simplified). Comments in
the examples describe the effect of each method invocation.</p>
<p>Playing cards were invented in China, perhaps around the 9th century. An early
deck had three suits, which corresponded to denominations of money.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chinese</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'coin'</span><span class="p">,</span> <span class="s1">'string'</span><span class="p">,</span> <span class="s1">'myriad'</span><span class="p">]</span>  <span class="c1"># A list literal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span> <span class="o">=</span> <span class="n">chinese</span>                         <span class="c1"># Two names refer to the same list</span>
</pre></div>

<p>As cards migrated to Europe (perhaps through Egypt), only the suit of coins
remained in Spanish decks (<em>oro</em>).</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>             <span class="c1"># Remove and return the final element</span>
<span class="go">'myriad'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">'string'</span><span class="p">)</span>  <span class="c1"># Remove the first element that equals the argument</span>
</pre></div>

<p>Three more suits were added (they evolved in name and design over time),</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'cup'</span><span class="p">)</span>              <span class="c1"># Add an element to the end</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">'sword'</span><span class="p">,</span> <span class="s1">'club'</span><span class="p">])</span>  <span class="c1"># Add all elements of a sequence to the end</span>
</pre></div>

<p>and Italians called swords <em>spades</em>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'spade'</span>  <span class="c1"># Replace an element</span>
</pre></div>

<p>giving the suits of a traditional Italian deck of cards.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span>
<span class="go">['coin', 'cup', 'spade', 'club']</span>
</pre></div>

<p>The French variant used today in the U.S. changes the first two suits:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'heart'</span><span class="p">,</span> <span class="s1">'diamond'</span><span class="p">]</span>  <span class="c1"># Replace a slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span>
<span class="go">['heart', 'diamond', 'spade', 'club']</span>
</pre></div>

<p>Methods also exist for inserting, sorting, and reversing lists.  All of these
mutation operations change the value of the list; they do not create new list
objects.</p>
<p><strong>Sharing and Identity.</strong> Because we have been changing a single list rather
than creating new lists, the object bound to the name <tt class="docutils literal">chinese</tt> has also
changed, because it is the same list object that was bound to <tt class="docutils literal">suits</tt>!</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chinese</span>  <span class="c1"># This name co-refers with "suits" to the same changing list</span>
<span class="go">['heart', 'diamond', 'spade', 'club']</span>
</pre></div>

<p>This behavior is new.  Previously, if a name did not appear in a statement,
then its value would not be affected by that statement.  With mutable data,
methods called on one name can affect another name at the same time.</p>
<p>The environment diagram for this example shows how the value bound to
<tt class="docutils literal">chinese</tt> is changed by statements involving only <tt class="docutils literal">suits</tt>. Step through
each line of the following example to observe these changes.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="3" id="example_6" style="">
chinese = ['coin', 'string', 'myriad']
suits = chinese
suits.pop()
suits.remove('string')
suits.append('cup')
suits.extend(['sword', 'club'])
suits[2] = 'spade'
suits[0:2] = ['heart', 'diamond']
</div>
<script type="text/javascript">
var example_6_trace = {"code": "chinese = ['coin', 'string', 'myriad']\nsuits = chinese\nsuits.pop()\nsuits.remove('string')\nsuits.append('cup')\nsuits.extend(['sword', 'club'])\nsuits[2] = 'spade'\nsuits[0:2] = ['heart', 'diamond']", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"chinese": ["REF", 1]}, "heap": {"1": ["LIST", "coin", "string", "myriad"]}, "line": 2, "ordered_globals": ["chinese"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"chinese": ["REF", 1], "suits": ["REF", 1]}, "heap": {"1": ["LIST", "coin", "string", "myriad"]}, "line": 3, "ordered_globals": ["chinese", "suits"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"chinese": ["REF", 1], "suits": ["REF", 1]}, "heap": {"1": ["LIST", "coin", "string"]}, "line": 4, "ordered_globals": ["chinese", "suits"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"chinese": ["REF", 1], "suits": ["REF", 1]}, "heap": {"1": ["LIST", "coin"]}, "line": 5, "ordered_globals": ["chinese", "suits"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"chinese": ["REF", 1], "suits": ["REF", 1]}, "heap": {"1": ["LIST", "coin", "cup"]}, "line": 6, "ordered_globals": ["chinese", "suits"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"chinese": ["REF", 1], "suits": ["REF", 1]}, "heap": {"1": ["LIST", "coin", "cup", "sword", "club"]}, "line": 7, "ordered_globals": ["chinese", "suits"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"chinese": ["REF", 1], "suits": ["REF", 1]}, "heap": {"1": ["LIST", "coin", "cup", "spade", "club"]}, "line": 8, "ordered_globals": ["chinese", "suits"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"chinese": ["REF", 1], "suits": ["REF", 1]}, "heap": {"1": ["LIST", "heart", "diamond", "spade", "club"]}, "line": 8, "ordered_globals": ["chinese", "suits"], "stack_to_render": [], "stdout": ""}]}</script><p>Lists can be copied using the <tt class="docutils literal">list</tt> constructor function.  Changes to one
list do not affect another, unless they share structure.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nest</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">suits</span><span class="p">)</span>  <span class="c1"># Bind "nest" to a second list with the same elements</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nest</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">suits</span>     <span class="c1"># Create a nested list</span>
</pre></div>

<p>According to this environment, changing the list referenced by <tt class="docutils literal">suits</tt> will
affect the nested list that is the first element of <tt class="docutils literal">nest</tt>, but not the other
elements.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'Joker'</span><span class="p">)</span>  <span class="c1"># Insert an element at index 2, shifting the rest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nest</span>
<span class="go">[['heart', 'diamond', 'Joker', 'spade', 'club'], 'diamond', 'spade', 'club']</span>
</pre></div>

<p>And likewise, undoing this change in the first element of <tt class="docutils literal">nest</tt> will change
<tt class="docutils literal">suit</tt> as well.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nest</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">'Joker'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span>
<span class="go">['heart', 'diamond', 'spade', 'club']</span>
</pre></div>

<p>Stepping through this example line by line will show the representation of a
nested list.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="0" id="example_7" style="">
suits = ['heart', 'diamond', 'spade', 'club']
nest = list(suits)
nest[0] = suits
suits.insert(2, 'Joker')
joke = nest[0].pop(2)
</div>
<script type="text/javascript">
var example_7_trace = {"code": "suits = ['heart', 'diamond', 'spade', 'club']\nnest = list(suits)\nnest[0] = suits\nsuits.insert(2, 'Joker')\njoke = nest[0].pop(2)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"suits": ["REF", 1]}, "heap": {"1": ["LIST", "heart", "diamond", "spade", "club"]}, "line": 2, "ordered_globals": ["suits"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"nest": ["REF", 2], "suits": ["REF", 1]}, "heap": {"1": ["LIST", "heart", "diamond", "spade", "club"], "2": ["LIST", "heart", "diamond", "spade", "club"]}, "line": 3, "ordered_globals": ["suits", "nest"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"nest": ["REF", 2], "suits": ["REF", 1]}, "heap": {"1": ["LIST", "heart", "diamond", "spade", "club"], "2": ["LIST", ["REF", 1], "diamond", "spade", "club"]}, "line": 4, "ordered_globals": ["suits", "nest"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"nest": ["REF", 2], "suits": ["REF", 1]}, "heap": {"1": ["LIST", "heart", "diamond", "Joker", "spade", "club"], "2": ["LIST", ["REF", 1], "diamond", "spade", "club"]}, "line": 5, "ordered_globals": ["suits", "nest"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"joke": "Joker", "nest": ["REF", 2], "suits": ["REF", 1]}, "heap": {"1": ["LIST", "heart", "diamond", "spade", "club"], "2": ["LIST", ["REF", 1], "diamond", "spade", "club"]}, "line": 5, "ordered_globals": ["suits", "nest", "joke"], "stack_to_render": [], "stdout": ""}]}</script><p>Because two lists may have the same contents but in fact be different lists, we
require a means to test whether two objects are the same.  Python includes two
comparison operators, called <tt class="docutils literal">is</tt> and <tt class="docutils literal">is not</tt>, that test whether two
expressions in fact evaluate to the identical object.  Two objects are
identical if they are equal in their current value, and any change to one will
always be reflected in the other. Identity is a stronger condition than
equality.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span> <span class="ow">is</span> <span class="n">nest</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span> <span class="ow">is</span> <span class="p">[</span><span class="s1">'heart'</span><span class="p">,</span> <span class="s1">'diamond'</span><span class="p">,</span> <span class="s1">'spade'</span><span class="p">,</span> <span class="s1">'club'</span><span class="p">]</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">suits</span> <span class="o">==</span> <span class="p">[</span><span class="s1">'heart'</span><span class="p">,</span> <span class="s1">'diamond'</span><span class="p">,</span> <span class="s1">'spade'</span><span class="p">,</span> <span class="s1">'club'</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>

<p>The final two comparisons illustrate the difference between <tt class="docutils literal">is</tt> and <tt class="docutils literal">==</tt>.
The former checks for identity, while the latter checks for the equality of
contents.</p>
<p><strong>List Manipulation.</strong> The behavior of list functions and methods can best be
understood in terms of object mutation and identity. Lists have a large number
of built-in methods that are useful in many scenarios, and so learning their
behavior is useful for programming productivity.</p>
<p>Slicing a list creates a new list and leaves the original list unchanged. A
slice from the beginning to the end of the list is one way to copy the contents
of a list.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_8" style="">
a = [11, 12, 13]
b = a[1:]
b[1] = 15
</div>
<script type="text/javascript">
var example_8_trace = {"code": "a = [11, 12, 13]\nb = a[1:]\nb[1] = 15", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", 11, 12, 13]}, "line": 2, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 2]}, "heap": {"1": ["LIST", 11, 12, 13], "2": ["LIST", 12, 13]}, "line": 3, "ordered_globals": ["a", "b"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 2]}, "heap": {"1": ["LIST", 11, 12, 13], "2": ["LIST", 12, 15]}, "line": 3, "ordered_globals": ["a", "b"], "stack_to_render": [], "stdout": ""}]}</script><p>Although the list is copied, the values contained within the list are not.
Instead, a new list is constructed that contains a subset of the same values as
the sliced list. Therefore, mutating a list within a sliced list will affect the
original list.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_9" style="">
a = [11, [12, 13], 14]
b = a[:]
b[1][1] = 15
</div>
<script type="text/javascript">
var example_9_trace = {"code": "a = [11, [12, 13], 14]\nb = a[:]\nb[1][1] = 15", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", 11, ["REF", 2], 14], "2": ["LIST", 12, 13]}, "line": 2, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3]}, "heap": {"1": ["LIST", 11, ["REF", 2], 14], "2": ["LIST", 12, 13], "3": ["LIST", 11, ["REF", 2], 14]}, "line": 3, "ordered_globals": ["a", "b"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3]}, "heap": {"1": ["LIST", 11, ["REF", 2], 14], "2": ["LIST", 12, 15], "3": ["LIST", 11, ["REF", 2], 14]}, "line": 3, "ordered_globals": ["a", "b"], "stack_to_render": [], "stdout": ""}]}</script><p>The built-in <tt class="docutils literal">list</tt> function creates a new list that contains the values of
its argument, which must be an iterable value such as a sequence. Again, the
values placed in this list are not copied. <tt class="docutils literal">list(s)</tt> and <tt class="docutils literal"><span class="pre">s[:]</span></tt> are
equivalent for a list <tt class="docutils literal">s</tt>.</p>
<p>Adding two lists together creates a new list that contains the values of the
first list, followed by the values in the second list. Therefore, <tt class="docutils literal">a+b</tt> and
<tt class="docutils literal">b+a</tt> can result in different values for two lists <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt>. However,
the <tt class="docutils literal">+=</tt> operator behaves differently for lists, and its behavior is described
below along with the <tt class="docutils literal">extend</tt> method.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_10" style="">
a = [[11], 12]
b = [13, 14]
c = a + b
d = b + a
a[0][0] = 15
b[0] = 16
</div>
<script type="text/javascript">
var example_10_trace = {"code": "a = [[11], 12]\nb = [13, 14]\nc = a + b\nd = b + a\na[0][0] = 15\nb[0] = 16", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", ["REF", 2], 12], "2": ["LIST", 11]}, "line": 2, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3]}, "heap": {"1": ["LIST", ["REF", 2], 12], "2": ["LIST", 11], "3": ["LIST", 13, 14]}, "line": 3, "ordered_globals": ["a", "b"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3], "c": ["REF", 4]}, "heap": {"1": ["LIST", ["REF", 2], 12], "2": ["LIST", 11], "3": ["LIST", 13, 14], "4": ["LIST", ["REF", 2], 12, 13, 14]}, "line": 4, "ordered_globals": ["a", "b", "c"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3], "c": ["REF", 4], "d": ["REF", 5]}, "heap": {"1": ["LIST", ["REF", 2], 12], "2": ["LIST", 11], "3": ["LIST", 13, 14], "4": ["LIST", ["REF", 2], 12, 13, 14], "5": ["LIST", 13, 14, ["REF", 2], 12]}, "line": 5, "ordered_globals": ["a", "b", "c", "d"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3], "c": ["REF", 4], "d": ["REF", 5]}, "heap": {"1": ["LIST", ["REF", 2], 12], "2": ["LIST", 15], "3": ["LIST", 13, 14], "4": ["LIST", ["REF", 2], 12, 13, 14], "5": ["LIST", 13, 14, ["REF", 2], 12]}, "line": 6, "ordered_globals": ["a", "b", "c", "d"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3], "c": ["REF", 4], "d": ["REF", 5]}, "heap": {"1": ["LIST", ["REF", 2], 12], "2": ["LIST", 15], "3": ["LIST", 16, 14], "4": ["LIST", ["REF", 2], 12, 13, 14], "5": ["LIST", 13, 14, ["REF", 2], 12]}, "line": 6, "ordered_globals": ["a", "b", "c", "d"], "stack_to_render": [], "stdout": ""}]}</script><p>The <tt class="docutils literal">append</tt> method of a list takes one value as an argument and adds it to the
end of the list. The argument can be any value, such as a number or another list.
If the argument is a list, then that list (and not a copy) is added as an item
in the list. The method always returns <tt class="docutils literal">None</tt>, and it mutates the list by increasing its length by one.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_11" style="">
a = [1, [2, 3]]
b = [4, [5, 6]]
c = 7
a.append(b)
a.append(c)
b.append(c)
d = a.append(a)
</div>
<script type="text/javascript">
var example_11_trace = {"code": "a = [1, [2, 3]]\nb = [4, [5, 6]]\nc = 7\na.append(b)\na.append(c)\nb.append(c)\nd = a.append(a)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", 1, ["REF", 2]], "2": ["LIST", 2, 3]}, "line": 2, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3]}, "heap": {"1": ["LIST", 1, ["REF", 2]], "2": ["LIST", 2, 3], "3": ["LIST", 4, ["REF", 4]], "4": ["LIST", 5, 6]}, "line": 3, "ordered_globals": ["a", "b"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3], "c": 7}, "heap": {"1": ["LIST", 1, ["REF", 2]], "2": ["LIST", 2, 3], "3": ["LIST", 4, ["REF", 4]], "4": ["LIST", 5, 6]}, "line": 4, "ordered_globals": ["a", "b", "c"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3], "c": 7}, "heap": {"1": ["LIST", 1, ["REF", 2], ["REF", 3]], "2": ["LIST", 2, 3], "3": ["LIST", 4, ["REF", 4]], "4": ["LIST", 5, 6]}, "line": 5, "ordered_globals": ["a", "b", "c"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3], "c": 7}, "heap": {"1": ["LIST", 1, ["REF", 2], ["REF", 3], 7], "2": ["LIST", 2, 3], "3": ["LIST", 4, ["REF", 4]], "4": ["LIST", 5, 6]}, "line": 6, "ordered_globals": ["a", "b", "c"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3], "c": 7}, "heap": {"1": ["LIST", 1, ["REF", 2], ["REF", 3], 7], "2": ["LIST", 2, 3], "3": ["LIST", 4, ["REF", 4], 7], "4": ["LIST", 5, 6]}, "line": 7, "ordered_globals": ["a", "b", "c"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 3], "c": 7, "d": null}, "heap": {"1": ["LIST", 1, ["REF", 2], ["REF", 3], 7, ["REF", 1]], "2": ["LIST", 2, 3], "3": ["LIST", 4, ["REF", 4], 7], "4": ["LIST", 5, 6]}, "line": 7, "ordered_globals": ["a", "b", "c", "d"], "stack_to_render": [], "stdout": ""}]}</script><p>The <tt class="docutils literal">extend</tt> method of a list takes an iterable value as an argument and adds
each of its elements to the end of the list. It mutates the list by increasing
its length by the length of the iterable argument.
The statement <tt class="docutils literal">x += y</tt> for a list <tt class="docutils literal">x</tt> and iterable <tt class="docutils literal">y</tt> is equivalent to
<tt class="docutils literal">x.extend(y)</tt>, aside from some obscure and minor differences beyond the scope
of this text. Passing any argument to <tt class="docutils literal">extend</tt> that is not iterable will cause
a <tt class="docutils literal">TypeError</tt>. The method does not return anything, and it mutates the list.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_12" style="">
a = [1, 2]
b = [1, 2]
c = [1, 2]
d = [3, [4]]
a.extend(d)
b += d
c.append(d)
</div>
<script type="text/javascript">
var example_12_trace = {"code": "a = [1, 2]\nb = [1, 2]\nc = [1, 2]\nd = [3, [4]]\na.extend(d)\nb += d\nc.append(d)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", 1, 2]}, "line": 2, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 2]}, "heap": {"1": ["LIST", 1, 2], "2": ["LIST", 1, 2]}, "line": 3, "ordered_globals": ["a", "b"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 2], "c": ["REF", 3]}, "heap": {"1": ["LIST", 1, 2], "2": ["LIST", 1, 2], "3": ["LIST", 1, 2]}, "line": 4, "ordered_globals": ["a", "b", "c"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 2], "c": ["REF", 3], "d": ["REF", 4]}, "heap": {"1": ["LIST", 1, 2], "2": ["LIST", 1, 2], "3": ["LIST", 1, 2], "4": ["LIST", 3, ["REF", 5]], "5": ["LIST", 4]}, "line": 5, "ordered_globals": ["a", "b", "c", "d"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 2], "c": ["REF", 3], "d": ["REF", 4]}, "heap": {"1": ["LIST", 1, 2, 3, ["REF", 5]], "2": ["LIST", 1, 2], "3": ["LIST", 1, 2], "4": ["LIST", 3, ["REF", 5]], "5": ["LIST", 4]}, "line": 6, "ordered_globals": ["a", "b", "c", "d"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 2], "c": ["REF", 3], "d": ["REF", 4]}, "heap": {"1": ["LIST", 1, 2, 3, ["REF", 5]], "2": ["LIST", 1, 2, 3, ["REF", 5]], "3": ["LIST", 1, 2], "4": ["LIST", 3, ["REF", 5]], "5": ["LIST", 4]}, "line": 7, "ordered_globals": ["a", "b", "c", "d"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 2], "c": ["REF", 3], "d": ["REF", 4]}, "heap": {"1": ["LIST", 1, 2, 3, ["REF", 5]], "2": ["LIST", 1, 2, 3, ["REF", 5]], "3": ["LIST", 1, 2, ["REF", 4]], "4": ["LIST", 3, ["REF", 5]], "5": ["LIST", 4]}, "line": 7, "ordered_globals": ["a", "b", "c", "d"], "stack_to_render": [], "stdout": ""}]}</script><p>The <tt class="docutils literal">pop</tt> method removes and returns the last element of the list. When given
an integer argument <tt class="docutils literal">i</tt>, it removes and returns the element at index <tt class="docutils literal">i</tt> of
the list. This method mutates the list, reducing its length by one. Attempting
to pop from an empty list causes an <tt class="docutils literal">IndexError</tt>.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_13" style="">
a = [0, 1, [2, 3], 4]
b = a.pop(2)
c = a.pop()
</div>
<script type="text/javascript">
var example_13_trace = {"code": "a = [0, 1, [2, 3], 4]\nb = a.pop(2)\nc = a.pop()", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", 0, 1, ["REF", 2], 4], "2": ["LIST", 2, 3]}, "line": 2, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 2]}, "heap": {"1": ["LIST", 0, 1, 4], "2": ["LIST", 2, 3]}, "line": 3, "ordered_globals": ["a", "b"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"a": ["REF", 1], "b": ["REF", 2], "c": 4}, "heap": {"1": ["LIST", 0, 1], "2": ["LIST", 2, 3]}, "line": 3, "ordered_globals": ["a", "b", "c"], "stack_to_render": [], "stdout": ""}]}</script><p>The <tt class="docutils literal">remove</tt> method takes one argument that must be equal to a value in the
list. It removes the first item in the list that is equal to its argument.
Calling <tt class="docutils literal">remove</tt> on a value that is not equal to any item in the list causes a
<tt class="docutils literal">ValueError</tt>.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_14" style="">
a = [10, 11, 10, 12, [13, 14]]
a.remove([13, 14])
a.remove(10)
</div>
<script type="text/javascript">
var example_14_trace = {"code": "a = [10, 11, 10, 12, [13, 14]]\na.remove([13, 14])\na.remove(10)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", 10, 11, 10, 12, ["REF", 2]], "2": ["LIST", 13, 14]}, "line": 2, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", 10, 11, 10, 12]}, "line": 3, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", 11, 10, 12]}, "line": 3, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}]}</script><p>The <tt class="docutils literal">index</tt> method takes one argument that must be equal to a value in the
list. It returns the index in the list of the first item that is equal to the
argument.  Calling <tt class="docutils literal">index</tt> on a value that is not equal to any item in the
list causes a <tt class="docutils literal">ValueError</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span> <span class="mi">15</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">([</span><span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">])</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>

<p>The <tt class="docutils literal">insert</tt> method takes two arguments: an index and a value to be inserted.
The value is added to the list at the given index. All elements before the given
index stay the same, but all elements after the index have their indices
increased by one. This method mutates the list by increasing its size by one,
then returns <tt class="docutils literal">None</tt>.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_15" style="">
a = [0, 1, 2]
a.insert(0, [3, 4])
a.insert(2, 5)
a.insert(5, 6)
</div>
<script type="text/javascript">
var example_15_trace = {"code": "a = [0, 1, 2]\na.insert(0, [3, 4])\na.insert(2, 5)\na.insert(5, 6)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", 0, 1, 2]}, "line": 2, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", ["REF", 2], 0, 1, 2], "2": ["LIST", 3, 4]}, "line": 3, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", ["REF", 2], 0, 5, 1, 2], "2": ["LIST", 3, 4]}, "line": 4, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"a": ["REF", 1]}, "heap": {"1": ["LIST", ["REF", 2], 0, 5, 1, 2, 6], "2": ["LIST", 3, 4]}, "line": 4, "ordered_globals": ["a"], "stack_to_render": [], "stdout": ""}]}</script><p>The <tt class="docutils literal">count</tt> method of a list takes in an item as an argument and returns how
many times an equal item apears in the list. If the argument is not equal to any
element of the list, then <tt class="docutils literal">count</tt> returns 0.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>

<p><strong>List comprehensions.</strong> A list comprehension always creates a new list.
For example, the <tt class="docutils literal">unicodedata</tt> module tracks the official names of every
character in the Unicode alphabet.  We can look up the characters corresponding
to names, including those for card suits.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unicodedata</span> <span class="k">import</span> <span class="n">lookup</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">lookup</span><span class="p">(</span><span class="s1">'WHITE '</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> <span class="s1">' SUIT'</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">suits</span><span class="p">]</span>
<span class="go">['♡', '♢', '♤', '♧']</span>
</pre></div>

<p>This resulting list does not share any of its contents with <tt class="docutils literal">suits</tt>, and
evaluating the list comprehension does not modify the <tt class="docutils literal">suits</tt> list.</p>
<p>You can read more about the Unicode standard for representing text in the
<a class="reference external" href="http://getpython3.com/diveintopython3/strings.html#one-ring-to-rule-them-all">Unicode section</a>
of Dive into Python 3.</p>
<p><strong>Tuples.</strong> A tuple, an instance of the built-in <tt class="docutils literal">tuple</tt> type, is an
immutable sequence. Tuples are created using a tuple literal that separates
element expressions by commas. Parentheses are optional but used commonly in
practice. Any objects can be placed within tuples.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
<span class="go">(1, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="s2">"the"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s2">"and"</span><span class="p">,</span> <span class="s2">"only"</span><span class="p">))</span>
<span class="go">('the', 1, ('and', 'only'))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="p">)</span>
<span class="go">&lt;class 'tuple'&gt;</span>
</pre></div>

<p>Empty and one-element tuples have special literal syntax.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">()</span>    <span class="c1"># 0 elements</span>
<span class="go">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">10</span><span class="p">,)</span> <span class="c1"># 1 element</span>
<span class="go">(10,)</span>
</pre></div>

<p>Like lists, tuples have a finite length and support element selection. They
also have a few methods that are also available for lists, such as <tt class="docutils literal">count</tt>
and <tt class="docutils literal">index</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">code</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"up"</span><span class="p">,</span> <span class="s2">"up"</span><span class="p">,</span> <span class="s2">"down"</span><span class="p">,</span> <span class="s2">"down"</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s2">"left"</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">code</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">'down'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">code</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">"down"</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">code</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">"left"</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>

<p>However, the methods for manipulating the contents of a list are not available
for tuples because tuples are immutable.</p>
<p>While it is not possible to change which elements are in a tuple, it is
possible to change the value of a mutable element contained within a tuple.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_16" style="">
nest = (10, 20, [30, 40])
nest[2].pop()
</div>
<script type="text/javascript">
var example_16_trace = {"code": "nest = (10, 20, [30, 40])\nnest[2].pop()", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"nest": ["REF", 1]}, "heap": {"1": ["TUPLE", 10, 20, ["REF", 2]], "2": ["LIST", 30, 40]}, "line": 2, "ordered_globals": ["nest"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"nest": ["REF", 1]}, "heap": {"1": ["TUPLE", 10, 20, ["REF", 2]], "2": ["LIST", 30]}, "line": 2, "ordered_globals": ["nest"], "stack_to_render": [], "stdout": ""}]}</script><p>Tuples are used implicitly in multiple assignment. An assignment of two values
to two names creates a two-element tuple and then unpacks it.</p>
<p>attention to</p>
</div>
<div class="section" id="dictionaries">
<h3>2.4.3   Dictionaries</h3>
<p>Dictionaries are Python's built-in data type for storing and manipulating
correspondence relationships.  A dictionary contains key-value pairs, where
both the keys and values are objects.  The purpose of a dictionary is to
provide an abstraction for storing and retrieving values that are indexed not
by consecutive integers, but by descriptive keys.</p>
<p>Strings commonly serve as keys, because strings are our conventional
representation for names of things. This dictionary literal gives the values of
various Roman numerals.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">numerals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'I'</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">'V'</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">'X'</span><span class="p">:</span> <span class="mi">10</span><span class="p">}</span>
</pre></div>

<p>Looking up values by their keys uses the element selection operator that we
previously applied to sequences.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">numerals</span><span class="p">[</span><span class="s1">'X'</span><span class="p">]</span>
<span class="go">10</span>
</pre></div>

<p>A dictionary can have at most one value for each key.  Adding new key-value
pairs and changing the existing value for a key can both be achieved with
assignment statements.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">numerals</span><span class="p">[</span><span class="s1">'I'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numerals</span><span class="p">[</span><span class="s1">'L'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numerals</span>
<span class="go">{'I': 1, 'X': 10, 'L': 50, 'V': 5}</span>
</pre></div>

<p>Notice that <tt class="docutils literal">'L'</tt> was not added to the end of the output above.  Dictionaries
were unordered collections of key-value pairs until Python 3.6. Since Python
3.6, their contents will be ordered by insertion. Since dictionaries were
historically unordered collections, it is safest not to assume anything about
the order in which keys and values will be printed.</p>
<p>Dictionaries can appear in environment diagrams as well.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_17" style="">
numerals = {'I': 1, 'V': 5, 'X': 10}
numerals['L'] = 50
</div>
<script type="text/javascript">
var example_17_trace = {"code": "numerals = {'I': 1, 'V': 5, 'X': 10}\nnumerals['L'] = 50", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"numerals": ["REF", 1]}, "heap": {"1": ["DICT", ["I", 1], ["V", 5], ["X", 10]]}, "line": 2, "ordered_globals": ["numerals"], "stack_to_render": [], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"numerals": ["REF", 1]}, "heap": {"1": ["DICT", ["I", 1], ["L", 50], ["V", 5], ["X", 10]]}, "line": 2, "ordered_globals": ["numerals"], "stack_to_render": [], "stdout": ""}]}</script><p>The dictionary type also supports various methods of iterating over the
contents of the dictionary as a whole.  The methods <tt class="docutils literal">keys</tt>, <tt class="docutils literal">values</tt>, and
<tt class="docutils literal">items</tt> all return iterable values.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">numerals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="go">66</span>
</pre></div>

<p>A list of key-value pairs can be converted into a dictionary by calling the
<tt class="docutils literal">dict</tt> constructor function.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">)])</span>
<span class="go">{3: 9, 4: 16, 5: 25}</span>
</pre></div>

<p>Dictionaries do have some restrictions:</p>
<ul class="simple">
<li>A key of a dictionary cannot be or contain a mutable value.</li>
<li>There can be at most one value for a given key.</li>
</ul>
<p>This first restriction is tied to the underlying implementation of dictionaries
in Python. The details of this implementation are not a topic of this text.
Intuitively, consider that the key tells Python where to find that key-value
pair in memory; if the key changes, the location of the pair may be lost.
Tuples are commonly used for keys in dictionaries because lists cannot be used.</p>
<p>The second restriction is a consequence of the dictionary abstraction, which is
designed to store and retrieve values for keys.  We can only retrieve <em>the</em>
value for a key if at most one such value exists in the dictionary.</p>
<p>A useful method implemented by dictionaries is <tt class="docutils literal">get</tt>, which returns either
the value for a key, if the key is present, or a default value.  The arguments
to <tt class="docutils literal">get</tt> are the key and the default value.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">numerals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'A'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numerals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'V'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>

<p>Dictionaries also have a comprehension syntax analogous to those of lists.
A key expression and a value expression are separated by a colon. Evaluating a
dictionary comprehension creates a new dictionary object.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">)}</span>
<span class="go">{3: 9, 4: 16, 5: 25}</span>
</pre></div>

</div>
<div class="section" id="local-state">
<h3>2.4.4   Local State</h3>
<p>Lists and dictionaries have <em>local state</em>: they are changing values that have
some particular contents at any point in the execution of a program. The word
"state" implies an evolving process in which that state may change.</p>
<p>Functions can also have local state.  For instance, let us define a function
that models the process of withdrawing money from a bank account. We will
create a function called <tt class="docutils literal">withdraw</tt>, which takes as its argument an amount to
be withdrawn. If there is enough money in the account to accommodate the
withdrawal, then <tt class="docutils literal">withdraw</tt> will return the balance remaining after the
withdrawal. Otherwise, <tt class="docutils literal">withdraw</tt> will return the message <tt class="docutils literal">'Insufficient
funds'</tt>.  For example, if we begin with $100 in the account, we would like to
obtain the following sequence of return values by calling withdraw:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">withdraw</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
<span class="go">75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">withdraw</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
<span class="go">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">withdraw</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
<span class="go">'Insufficient funds'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">withdraw</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">35</span>
</pre></div>

<p>Above, the expression <tt class="docutils literal">withdraw(25)</tt>, evaluated twice, yields different
values. Thus, this user-defined function is non-pure. Calling the function not
only returns a value, but also has the side effect of changing the function in
some way, so that the next call with the same argument will return a different
result.  This side effect is a result of <tt class="docutils literal">withdraw</tt> making a change to a
name-value binding outside of the current frame.</p>
<p>For <tt class="docutils literal">withdraw</tt> to make sense, it must be created with an initial account
balance. The function <tt class="docutils literal">make_withdraw</tt> is a higher-order function that takes a
starting balance as an argument.  The function <tt class="docutils literal">withdraw</tt> is its return
value.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">withdraw</span> <span class="o">=</span> <span class="n">make_withdraw</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>

<p>An implementation of <tt class="docutils literal">make_withdraw</tt> requires a new kind of statement: a
<tt class="docutils literal">nonlocal</tt> statement.  When we call <tt class="docutils literal">make_withdraw</tt>, we bind the name
<tt class="docutils literal">balance</tt> to the initial amount.  We then define and return a local function,
<tt class="docutils literal">withdraw</tt>, which updates and returns the value of <tt class="docutils literal">balance</tt> when called.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">make_withdraw</span><span class="p">(</span><span class="n">balance</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a withdraw function that draws down balance with each call."""</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="n">amount</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">nonlocal</span> <span class="n">balance</span>                 <span class="c1"># Declare the name "balance" nonlocal</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="n">balance</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="s1">'Insufficient funds'</span>
<span class="gp">    </span>        <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">-</span> <span class="n">amount</span>       <span class="c1"># Re-bind the existing balance name</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">balance</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">withdraw</span>
</pre></div>

<p>The <tt class="docutils literal">nonlocal</tt> statement declares that whenever we change the binding of the
name <tt class="docutils literal">balance</tt>, the binding is changed in the first frame in which
<tt class="docutils literal">balance</tt> is already bound. Recall that without the <tt class="docutils literal">nonlocal</tt> statement,
an assignment statement would always bind a name in the first frame of the
current environment.  The <tt class="docutils literal">nonlocal</tt> statement indicates that the name
appears somewhere in the environment other than the first (local) frame or the
last (global) frame.</p>
<p>The following environment diagrams illustrate the effects of multiple calls to
a function created by <tt class="docutils literal">make_withdraw</tt>.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="5" id="example_18" style="">
def make_withdraw(balance):
    def withdraw(amount):
        nonlocal balance
        if amount &gt; balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw

wd = make_withdraw(20)
wd(5)
wd(3)
</div>
<script type="text/javascript">
var example_18_trace = {"code": "def make_withdraw(balance):\n    def withdraw(amount):\n        nonlocal balance\n        if amount > balance:\n            return 'Insufficient funds'\n        balance = balance - amount\n        return balance\n    return withdraw\n\nwd = make_withdraw(20)\nwd(5)\nwd(3)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 10, "ordered_globals": ["make_withdraw"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 1, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 2, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 8, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "return", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 8, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 11, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 2, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 4, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 6, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 12, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 2, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 4, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 6, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"__return__": 12, "amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 12, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"__return__": 12, "amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3_z"}], "stdout": ""}]}</script><p>The first def statement has the usual effect: it creates a new user-defined
function and binds the name <tt class="docutils literal">make_withdraw</tt> to that function in the global
frame. The subsequent call to <tt class="docutils literal">make_withdraw</tt> creates and returns a locally
defined function <tt class="docutils literal">withdraw</tt>.  The name <tt class="docutils literal">balance</tt> is bound in the parent
frame of this function.  Crucially, there will only be this single binding for
the name <tt class="docutils literal">balance</tt> throughout the rest of this example.</p>
<p>Next, we evaluate an expression that calls this function, bound to the name
<tt class="docutils literal">wd</tt>, on an amount 5.  The body of <tt class="docutils literal">withdraw</tt> is executed in a new
environment that extends the environment in which <tt class="docutils literal">withdraw</tt> was defined.
Tracing the effect of evaluating <tt class="docutils literal">withdraw</tt> illustrates the effect of a
<tt class="docutils literal">nonlocal</tt> statement in Python: a name outside of the first local frame can
be changed by an assignment statement.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="10" id="example_19" style="">
def make_withdraw(balance):
    def withdraw(amount):
        nonlocal balance
        if amount &gt; balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw

wd = make_withdraw(20)
wd(5)
wd(3)
</div>
<script type="text/javascript">
var example_19_trace = {"code": "def make_withdraw(balance):\n    def withdraw(amount):\n        nonlocal balance\n        if amount > balance:\n            return 'Insufficient funds'\n        balance = balance - amount\n        return balance\n    return withdraw\n\nwd = make_withdraw(20)\nwd(5)\nwd(3)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 10, "ordered_globals": ["make_withdraw"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 1, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 2, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 8, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "return", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 8, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 11, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 2, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 4, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 6, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 12, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 2, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 4, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 6, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"__return__": 12, "amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 12, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"__return__": 12, "amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3_z"}], "stdout": ""}]}</script><p>The <tt class="docutils literal">nonlocal</tt> statement changes all of the remaining assignment statements
in the definition of <tt class="docutils literal">withdraw</tt>.  After executing <tt class="docutils literal">nonlocal balance</tt>, any
assignment statement with <tt class="docutils literal">balance</tt> on the left-hand side of <tt class="docutils literal">=</tt> will not
bind <tt class="docutils literal">balance</tt> in the first frame of the current environment.  Instead, it
will find the first frame in which <tt class="docutils literal">balance</tt> was already defined and re-bind
the name in that frame.  If <tt class="docutils literal">balance</tt> has not previously been bound to a
value, then the <tt class="docutils literal">nonlocal</tt> statement will give an error.</p>
<p>By virtue of changing the binding for <tt class="docutils literal">balance</tt>, we have changed the
<tt class="docutils literal">withdraw</tt> function as well.  The next time it is called, the name
<tt class="docutils literal">balance</tt> will evaluate to 15 instead of 20.  Hence, when we call
<tt class="docutils literal">withdraw</tt> a second time, we see that its return value is 12 and not
17.  The change to <tt class="docutils literal">balance</tt> from the first call affects the result of
the second call.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_20" style="">
def make_withdraw(balance):
    def withdraw(amount):
        nonlocal balance
        if amount &gt; balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw

wd = make_withdraw(20)
wd(5)
wd(3)
</div>
<script type="text/javascript">
var example_20_trace = {"code": "def make_withdraw(balance):\n    def withdraw(amount):\n        nonlocal balance\n        if amount > balance:\n            return 'Insufficient funds'\n        balance = balance - amount\n        return balance\n    return withdraw\n\nwd = make_withdraw(20)\nwd(5)\nwd(3)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 10, "ordered_globals": ["make_withdraw"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 1, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 2, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 8, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "return", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 8, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 11, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 2, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 4, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 6, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 12, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 2, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 4, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 6, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 15, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"__return__": 12, "amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 12, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 15, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"__return__": 12, "amount": 3}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3_z"}], "stdout": ""}]}</script><p>The second call to <tt class="docutils literal">withdraw</tt> does create a second local frame, as usual.
However, both <tt class="docutils literal">withdraw</tt> frames have the same parent.  That is, they both
extend the environment for <tt class="docutils literal">make_withdraw</tt>, which contains the binding for
<tt class="docutils literal">balance</tt>.  Hence, they share that particular name binding.  Calling
<tt class="docutils literal">withdraw</tt> has the side effect of altering the environment that will be
extended by future calls to <tt class="docutils literal">withdraw</tt>.  The <tt class="docutils literal">nonlocal</tt> statement allows
<tt class="docutils literal">withdraw</tt> to change a name binding in the <tt class="docutils literal">make_withdraw</tt> frame.</p>
<p>Ever since we first encountered nested <tt class="docutils literal">def</tt> statements, we have observed
that a locally defined function can look up names outside of its local frames.
No <tt class="docutils literal">nonlocal</tt> statement is required to <em>access</em> a non-local name.  By
contrast, only after a <tt class="docutils literal">nonlocal</tt> statement can a function <em>change</em> the
binding of names in these frames.</p>
<p>By introducing <tt class="docutils literal">nonlocal</tt> statements, we have created a dual role for
assignment statements.  Either they change local bindings, or they change
nonlocal bindings.  In fact, assignment statements already had a dual role:
they either created new bindings or re-bound existing names. Assignment can
also change the contents of lists and dictionaries. The many roles of Python
assignment can obscure the effects of executing an assignment statement. It is
up to you as a programmer to document your code clearly so that the effects of
assignment can be understood by others.</p>
<p><strong>Python Particulars.</strong> This pattern of non-local assignment is a general
feature of programming languages with higher-order functions and lexical scope.
Most other languages do not require a <tt class="docutils literal">nonlocal</tt> statement at all. Instead,
non-local assignment is often the default behavior of assignment statements.</p>
<p>Python also has an unusual restriction regarding the lookup of names: within
the body of a function, all instances of a name must refer to the same frame.
As a result, Python cannot look up the value of a name in a non-local frame,
then bind that same name in the local frame, because the same name would be
accessed in two different frames in the same function.  This restriction
allows Python to pre-compute which frame contains each name before executing
the body of a function. When this restriction is violated, a confusing error
message results.  To demonstrate, the <tt class="docutils literal">make_withdraw</tt> example is repeated
below with the <tt class="docutils literal">nonlocal</tt> statement removed.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="7" id="example_21" style="">
def make_withdraw(balance):
    def withdraw(amount):
        if amount &gt; balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw

wd = make_withdraw(20)
wd(5)
</div>
<script type="text/javascript">
var example_21_trace = {"code": "def make_withdraw(balance):\n    def withdraw(amount):\n        if amount > balance:\n            return 'Insufficient funds'\n        balance = balance - amount\n        return balance\n    return withdraw\n\nwd = make_withdraw(20)\nwd(5)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 9, "ordered_globals": ["make_withdraw"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 1, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 2, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "return", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 10, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 2, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 3, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "exception", "exception_msg": "UnboundLocalError: local variable 'balance' referenced before assignment", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 3, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 3, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": null, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "exception", "exception_msg": "UnboundLocalError: local variable 'balance' referenced before assignment", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 10, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": null, "amount": 5}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}], "stdout": ""}]}</script><p>This <tt class="docutils literal">UnboundLocalError</tt> appears because <tt class="docutils literal">balance</tt> is assigned locally in
line 5, and so Python assumes that all references to <tt class="docutils literal">balance</tt> must
appear in the local frame as well.  This error occurs <em>before</em> line 5 is
ever executed, implying that Python has considered line 5 in some way
before executing line 3. As we study interpreter design, we will see that
pre-computing facts about a function body before executing it is quite common.
In this case, Python's pre-processing restricted the frame in which <tt class="docutils literal">balance</tt>
could appear, and thus prevented the name from being found. Adding a
<tt class="docutils literal">nonlocal</tt> statement corrects this error. The <tt class="docutils literal">nonlocal</tt> statement did not
exist in Python 2.</p>
</div>
<div class="section" id="the-benefits-of-non-local-assignment">
<h3>2.4.5   The Benefits of Non-Local Assignment</h3>
<p>Non-local assignment is an important step on our path to viewing a program as a
collection of independent and autonomous <em>objects</em>, which interact with each
other but each manage their own internal state.</p>
<p>In particular, non-local assignment has given us the ability to maintain some
state that is local to a function, but evolves over successive calls to that
function.  The <tt class="docutils literal">balance</tt> associated with a particular withdraw function is
shared among all calls to that function. However, the binding for balance
associated with an instance of withdraw is inaccessible to the rest of the
program.  Only <tt class="docutils literal">wd</tt> is associated with the frame for <tt class="docutils literal">make_withdraw</tt> in
which it was defined.  If <tt class="docutils literal">make_withdraw</tt> is called again, then it will
create a separate frame with a separate binding for <tt class="docutils literal">balance</tt>.</p>
<p>We can extend our example to illustrate this point.  A second call to
<tt class="docutils literal">make_withdraw</tt> returns a second <tt class="docutils literal">withdraw</tt> function that has a different
parent. We bind this second function to the name <tt class="docutils literal">wd2</tt> in the global frame.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="9" id="example_22" style="">
def make_withdraw(balance):
    def withdraw(amount):
        nonlocal balance
        if amount &gt; balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw

wd = make_withdraw(20)
wd2 = make_withdraw(7)
wd2(6)
wd(8)
</div>
<script type="text/javascript">
var example_22_trace = {"code": "def make_withdraw(balance):\n    def withdraw(amount):\n        nonlocal balance\n        if amount > balance:\n            return 'Insufficient funds'\n        balance = balance - amount\n        return balance\n    return withdraw\n\nwd = make_withdraw(20)\nwd2 = make_withdraw(7)\nwd2(6)\nwd(8)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 10, "ordered_globals": ["make_withdraw"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 1, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 2, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 8, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "return", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 8, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 11, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}], "stdout": ""}, {"event": "call", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 1, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"balance": 7}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 2, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"balance": 7}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 8, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"balance": 7, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p"}], "stdout": ""}, {"event": "return", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 8, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 7, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 12, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 7, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 2, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 7, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 4, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 7, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 6, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 7, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 7, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 7, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 13, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 2, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}, {"encoded_locals": {"amount": 8}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 4, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}, {"encoded_locals": {"amount": 8}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 6, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}, {"encoded_locals": {"amount": 8}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 7, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}, {"encoded_locals": {"amount": 8}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f4"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 7, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}, {"encoded_locals": {"__return__": 12, "amount": 8}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f4"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 13, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}, {"encoded_locals": {"__return__": 12, "amount": 8}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f4_z"}], "stdout": ""}]}</script><p>Now, we see that there are in fact two bindings for the name <tt class="docutils literal">balance</tt> in two
different frames, and each <tt class="docutils literal">withdraw</tt> function has a different parent. The
name <tt class="docutils literal">wd</tt> is bound to a function with a balance of 20, while
<tt class="docutils literal">wd2</tt> is bound to a different function with a balance of 7.</p>
<p>Calling <tt class="docutils literal">wd2</tt> changes the binding of its non-local <tt class="docutils literal">balance</tt> name, but
does not affect the function bound to the name <tt class="docutils literal">withdraw</tt>. A future call to
<tt class="docutils literal">wd</tt> is unaffected by the changing balance of <tt class="docutils literal">wd2</tt>; its balance is still
20.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="14" id="example_23" style="">
def make_withdraw(balance):
    def withdraw(amount):
        nonlocal balance
        if amount &gt; balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw

wd = make_withdraw(20)
wd2 = make_withdraw(7)
wd2(6)
wd(8)
</div>
<script type="text/javascript">
var example_23_trace = {"code": "def make_withdraw(balance):\n    def withdraw(amount):\n        nonlocal balance\n        if amount > balance:\n            return 'Insufficient funds'\n        balance = balance - amount\n        return balance\n    return withdraw\n\nwd = make_withdraw(20)\nwd2 = make_withdraw(7)\nwd2(6)\nwd(8)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 10, "ordered_globals": ["make_withdraw"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 1, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 2, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 8, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "return", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 8, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 11, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}], "stdout": ""}, {"event": "call", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 1, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"balance": 7}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 2, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"balance": 7}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 8, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"balance": 7, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p"}], "stdout": ""}, {"event": "return", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 8, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 7, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 12, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 7, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 2, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 7, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 4, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 7, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 6, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 7, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 7, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 7, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 13, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 2, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}, {"encoded_locals": {"amount": 8}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 4, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}, {"encoded_locals": {"amount": 8}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 6, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 20, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}, {"encoded_locals": {"amount": 8}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 7, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}, {"encoded_locals": {"amount": 8}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f4"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 7, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}, {"encoded_locals": {"__return__": 12, "amount": 8}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f4"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 3]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1], "3": ["FUNCTION", "withdraw(amount)", 2]}, "line": 13, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": ["REF", 3], "balance": 1, "withdraw": ["REF", 3]}, "frame_id": 2, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f2_p_z"}, {"encoded_locals": {"__return__": 1, "amount": 6}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [2], "unique_hash": "withdraw_f3_z"}, {"encoded_locals": {"__return__": 12, "amount": 8}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f4_z"}], "stdout": ""}]}</script><p>In this way, each instance of <tt class="docutils literal">withdraw</tt> maintains its own balance state,
but that state is inaccessible to any other function in the program.  Viewing
this situation at a higher level, we have created an abstraction of a bank
account that manages its own internals but behaves in a way that models accounts
in the world: it changes over time based on its own history of withdrawal
requests.</p>
</div>
<div class="section" id="the-cost-of-non-local-assignment">
<h3>2.4.6   The Cost of Non-Local Assignment</h3>
<p>Our environment model of computation cleanly extends to explain the effects of
non-local assignment.  However, non-local assignment introduces some important
nuances in the way we think about names and values.</p>
<p>Previously, our values did not change; only our names and bindings changed.
When two names <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> were both bound to the value 4, it did not
matter whether they were bound to the same 4 or different 4's.  As far
as we could tell, there was only one 4 object that never changed.</p>
<p>However, functions with state do not behave this way.  When two names <tt class="docutils literal">wd</tt>
and <tt class="docutils literal">wd2</tt> are both bound to a <tt class="docutils literal">withdraw</tt> function, it <em>does</em> matter whether
they are bound to the same function or different instances of that function.
Consider the following example, which contrasts the one we just analyzed.
In this case, calling the function named by <tt class="docutils literal">wd2</tt> did change the value of the
function named by <tt class="docutils literal">wd</tt>, because both names refer to the same function.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_24" style="">
def make_withdraw(balance):
    def withdraw(amount):
        nonlocal balance
        if amount &gt; balance:
            return 'Insufficient funds'
        balance = balance - amount
        return balance
    return withdraw

wd = make_withdraw(12)
wd2 = wd
wd2(1)
wd(1)
</div>
<script type="text/javascript">
var example_24_trace = {"code": "def make_withdraw(balance):\n    def withdraw(amount):\n        nonlocal balance\n        if amount > balance:\n            return 'Insufficient funds'\n        balance = balance - amount\n        return balance\n    return withdraw\n\nwd = make_withdraw(12)\nwd2 = wd\nwd2(1)\nwd(1)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 10, "ordered_globals": ["make_withdraw"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 1, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 12}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null]}, "line": 2, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 12}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["balance"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 8, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "return", "func_name": "make_withdraw", "globals": {"make_withdraw": ["REF", 1]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 8, "ordered_globals": ["make_withdraw"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 11, "ordered_globals": ["make_withdraw", "wd"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 12, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 2, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 1}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 4, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 1}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 6, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 12, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 1}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 11, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"amount": 1}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 11, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 11, "amount": 1}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 13, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 11, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 11, "amount": 1}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 2, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 11, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 11, "amount": 1}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 1}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 4, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 11, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 11, "amount": 1}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 1}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 6, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 11, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 11, "amount": 1}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 1}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 10, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 11, "amount": 1}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"amount": 1}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 7, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 10, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 11, "amount": 1}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"__return__": 10, "amount": 1}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"make_withdraw": ["REF", 1], "wd": ["REF", 2], "wd2": ["REF", 2]}, "heap": {"1": ["FUNCTION", "make_withdraw(balance)", null], "2": ["FUNCTION", "withdraw(amount)", 1]}, "line": 13, "ordered_globals": ["make_withdraw", "wd", "wd2"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 2], "balance": 10, "withdraw": ["REF", 2]}, "frame_id": 1, "func_name": "make_withdraw", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["balance", "withdraw", "__return__"], "parent_frame_id_list": [], "unique_hash": "make_withdraw_f1_p_z"}, {"encoded_locals": {"__return__": 11, "amount": 1}, "frame_id": 2, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f2_z"}, {"encoded_locals": {"__return__": 10, "amount": 1}, "frame_id": 3, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f3_z"}], "stdout": ""}]}</script><p>It is not unusual for two names to co-refer to the same value in the world, and
so it is in our programs.  But, as values change over time, we must be very
careful to understand the effect of a change on other names that might refer to
those values.</p>
<p>The key to correctly analyzing code with non-local assignment is to remember
that only function calls can introduce new frames.  Assignment statements always
change bindings in existing frames.  In this case, unless <tt class="docutils literal">make_withdraw</tt> is
called twice, there can be only one binding for <tt class="docutils literal">balance</tt>.</p>
<p><strong>Sameness and change.</strong> These subtleties arise because, by introducing non-pure
functions that change the non-local environment, we have changed the nature of
expressions.  An expression that contains only pure function calls is
<em>referentially transparent</em>; its value does not change if we substitute one of
its subexpression with the value of that subexpression.</p>
<p>Re-binding operations violate the conditions of referential transparency because
they do more than return a value; they change the environment.  When we
introduce arbitrary re-binding, we encounter a thorny epistemological issue:
what it means for two values to be the same. In our environment model of
computation, two separately defined functions are not the same, because changes
to one may not be reflected in the other.</p>
<p>In general, so long as we never modify data objects, we can regard a compound
data object to be precisely the totality of its pieces. For example, a rational
number is determined by giving its numerator and its denominator. But this view
is no longer valid in the presence of change, where a compound data object has
an "identity" that is something different from the pieces of which it is
composed. A bank account is still "the same" bank account even if we change the
balance by making a withdrawal; conversely, we could have two bank accounts that
happen to have the same balance, but are different objects.</p>
<p>Despite the complications it introduces, non-local assignment is a powerful tool
for creating modular programs. Different parts of a program, which correspond to
different environment frames, can evolve separately throughout program
execution.  Moreover, using functions with local state, we are able to implement
mutable data types.  In fact, we can implement abstract data types that are
equivalent to the built-in <tt class="docutils literal">list</tt> and <tt class="docutils literal">dict</tt> types introduced above.</p>
</div>
<div class="section" id="iterators">
<h3>2.4.7   Iterators</h3>
<p>Python and many other programming languages provide a unified way to process
elements of a container value sequentially, called an iterator.  An <em>iterator</em>
is an object that provides sequential access to values, one by one.</p>
<p>The iterator abstraction has two components: a mechanism for retrieving the next
element in the sequence being processed and a mechanism for signaling that the
end of the sequence has been reached and no further elements remain. For any
container, such as a list or range, an iterator can be obtained by calling the
built-in <tt class="docutils literal">iter</tt> function. The contents of the iterator can be accessed by
calling the built-in <tt class="docutils literal">next</tt> function.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">primes</span><span class="p">)</span>
<span class="go">&lt;class 'list'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">primes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">&lt;class 'list_iterator'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>

<p>Python signals that there are no more values available by raising a
<tt class="docutils literal">StopIteration</tt> exception when <tt class="docutils literal">next</tt> is called. This exception can be
handled using a <tt class="docutils literal">try</tt> statement.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>
</pre></div>

<p>An iterator maintains local state to represent its position in a sequence. Each
time <tt class="docutils literal">next</tt> is called, that position advances. Two separate iterators can
track two different positions in the same sequence. However, two names for the
same iterator will share a position because they share the same value.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># 1st iterator over r</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># 2nd iterator over r</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">t</span>        <span class="c1"># Alternate name for the 2nd iterator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>

<p>Advancing the second iterator does not affect the first. Since the last value
returned from the first iterator was 4, it is positioned to return 5 next. On
the other hand, the second iterator is positioned to return 7 next.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>

<p>Calling <tt class="docutils literal">iter</tt> on an iterator will return that iterator, not a copy. This
behavior is included in Python so that a programmer can call <tt class="docutils literal">iter</tt> on a
value to get an iterator without having to worry about whether it is an iterator
or a container.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># Another alterante name for the 2nd iterator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>

<p>The usefulness of iterators is derived from the fact that the underlying
series of data for an iterator may not be represented explicitly in memory.
An iterator provides a mechanism for considering each of a series of values in
turn, but all of those elements do not need to be stored simultaneously.
Instead, when the next element is requested from an iterator, that element may
be computed on demand instead of being retrieved from an existing memory
source.</p>
<p>Ranges are able to compute the elements of a sequence lazily because the
sequence represented is uniform, and any element is easy to compute from the
starting and ending bounds of the range. Iterators allow for lazy generation of
a much broader class of underlying sequential datasets because they do not need
to provide access to arbitrary elements of the underlying series. Instead,
iterators are only required to compute the next element of the series, in order,
each time another element is requested. While not as flexible as <em>random access</em>
(accessing arbitrary elements of a sequence in any order), <em>sequential access</em>
to sequential data is often sufficient for data processing applications.</p>
</div>
<div class="section" id="iterables">
<h3>2.4.8   Iterables</h3>
<p>Any value that can produce iterators is called an <em>iterable</em> value. In Python,
an iterable value is anything that can be passed to the built-in <tt class="docutils literal">iter</tt>
function. Iterables include sequence values such as strings and tuples, as well
as other containers such as sets and dictionaries. Iterators are also iterables
because they can be passed to the <tt class="docutils literal">iter</tt> function.</p>
<p>Even unordered collections, such as dictionaries in Python 3.5 and earlier, must
define an ordering over their contents when they produce iterators. Dictionaries
and sets are unordered because the programmer has no control over the order of
iteration, but Python does guarantee certain properties about their order in its
specification.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'one'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'two'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'three'</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{'one': 1, 'three': 3, 'two': 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="go">'one'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="go">'three'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>

<p>If a dictionary changes in structure because a key is added or removed, then all
iterators become invalid, and future iterators may exhibit changes to
the order of their contents. On the other hand, changing the value of an
existing key does not invalidate iterators or change the order of their
contents.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'two'</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">dictionary changed size during iteration</span>
</pre></div>

<p>A <tt class="docutils literal">for</tt> statement can be used to iterate over the contents of any iterable or
iterator.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
</pre></div>

</div>
<div class="section" id="built-in-iterators">
<h3>2.4.9   Built-in Iterators</h3>
<p>Several built-in functions take as arguments iterable values and return
iterators. These functions are used extensively for lazy sequence processing.</p>
<p>The <tt class="docutils literal">map</tt> function is lazy: calling it does not perform the computation
required to compute elements of its result. Instead, an iterator object is
created that can return results if queried using <tt class="docutils literal">next</tt>. We can observe this
fact in the following example, in which the call to <tt class="docutils literal">print</tt> is delayed until
the corresponding element is requested from the <tt class="docutils literal">doubled</tt> iterator.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">double_and_print</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'***'</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">'=&gt;'</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="s1">'***'</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doubled</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">double_and_print</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>  <span class="c1"># double_and_print not yet called</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">doubled</span><span class="p">)</span>                       <span class="c1"># double_and_print called once</span>
<span class="go">*** 3 =&gt; 6 ***</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">doubled</span><span class="p">)</span>                       <span class="c1"># double_and_print called again</span>
<span class="go">*** 4 =&gt; 8 ***</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">doubled</span><span class="p">)</span>                       <span class="c1"># double_and_print called twice more</span>
<span class="go">*** 5 =&gt; 10 ***</span>
<span class="go">*** 6 =&gt; 12 ***</span>
<span class="go">[10, 12]</span>
</pre></div>

<p>The <tt class="docutils literal">filter</tt> function returns an iterator over a subset of the values in
another iterable. The <tt class="docutils literal">zip</tt> function returns an iterator over tuples of values
that combine one value from each of multiple iterables.</p>
</div>
<div class="section" id="generators">
<h3>2.4.10   Generators</h3>
<p>Generators allow us to define iterations over arbitrary sequences, even infinite
sequences, by leveraging the features of the Python interpreter.</p>
<p>A <em>generator</em> is an iterator returned by a special class of function called a
<em>generator function</em>. Generator functions are distinguished from regular
functions in that rather than containing <tt class="docutils literal">return</tt> statements in their body,
they use <tt class="docutils literal">yield</tt> statements to return elements of a series.</p>
<p>Generators do not use attributes of an object to track their progress through a
series. Instead, they control the execution of the generator function, which
runs until the next <tt class="docutils literal">yield</tt> statement is executed each time <tt class="docutils literal">next</tt> is called
on the generator. For example, the <tt class="docutils literal">letters_generator</tt> function below returns a generator over the letters a, b, c, and then d.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">letters_generator</span><span class="p">():</span>
<span class="gp">    </span>    <span class="n">current</span> <span class="o">=</span> <span class="s1">'a'</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="n">current</span> <span class="o">&lt;=</span> <span class="s1">'d'</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">yield</span> <span class="n">current</span>
<span class="gp">    </span>        <span class="n">current</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">current</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">letters_generator</span><span class="p">():</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
<span class="go">a</span>
<span class="go">b</span>
<span class="go">c</span>
<span class="go">d</span>
</pre></div>

<p>The <tt class="docutils literal">yield</tt> statement indicates that we are defining a generator function,
rather than a regular function.  When called, a generator function doesn't
return a particular yielded value, but instead a <tt class="docutils literal">generator</tt> (which is a type
of iterator) that itself can return the yielded values. Calling <tt class="docutils literal">next</tt> on the
generator continues execution of the generator function from wherever it left
off previously until another <tt class="docutils literal">yield</tt> statement is executed.</p>
<p>The first time <tt class="docutils literal">next</tt> is called, the program executes statements from
the body of the <tt class="docutils literal">letters_generator</tt> function until it encounters the
<tt class="docutils literal">yield</tt> statement. Then, it pauses and returns the value of <tt class="docutils literal">current</tt>.
<tt class="docutils literal">yield</tt> statements do not destroy the newly created environment; they
preserve it for later. When <tt class="docutils literal">next</tt> is called again, execution resumes
where it left off. The values of <tt class="docutils literal">current</tt> and of any other bound names in
the scope of <tt class="docutils literal">letters_generator</tt> are preserved across subsequent calls to
<tt class="docutils literal">next</tt>.</p>
<p>We can walk through the generator by manually calling <tt class="docutils literal">next()</tt>:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span> <span class="o">=</span> <span class="n">letters_generator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="go">&lt;class 'generator'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="go">'a'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="go">'b'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="go">'c'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="go">'d'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>
</pre></div>

<p>The generator does not start executing any of the body statements of its
generator function until the first time <tt class="docutils literal">next</tt> is called. The generator
raises a <tt class="docutils literal">StopIteration</tt> exception whenever its generator function returns.</p>
</div>
<div class="section" id="implementing-lists-and-dictionaries">
<h3>2.4.11   Implementing Lists and Dictionaries</h3>
<p>The Python language does not give us access to the implementation of lists,
only to the sequence abstraction and mutation methods built into the language.
To understand how a mutable list could be represented using functions with
local state, we will now develop an implementation of a mutable linked list.</p>
<p>We will represent a mutable linked list by a function that has a linked list as
its local state.  Lists need to have an identity, like any mutable value.  In
particular, we cannot use <tt class="docutils literal">None</tt> to represent an empty mutable list, because
two empty lists are not identical values (e.g., appending to one does not
append to the other), but <tt class="docutils literal">None is None</tt>.  On the other hand, two different
functions that each have <tt class="docutils literal">empty</tt> as their local state will suffice to
distinguish two empty lists.</p>
<p>If a mutable linked list is a function, what arguments does it take? The answer
exhibits a general pattern in programming: the function is a dispatch function
and its arguments are first a message, followed by additional arguments to
parameterize that method. This message is a string naming what the function
should do. Dispatch functions are effectively many functions in one: the
message determines the behavior of the function, and the additional arguments
are used in that behavior.</p>
<p>Our mutable list will respond to five different messages: <tt class="docutils literal">len</tt>, <tt class="docutils literal">getitem</tt>,
<tt class="docutils literal">push_first</tt>, <tt class="docutils literal">pop_first</tt>, and <tt class="docutils literal">str</tt>.  The first two implement the
behaviors of the sequence abstraction.  The next two add or remove the first
element of the list.  The final message returns a string representation of the
whole linked list.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mutable_link</span><span class="p">():</span>
<span class="gp">    </span>    <span class="sd">"""Return a functional implementation of a mutable linked list."""</span>
<span class="gp">    </span>    <span class="n">contents</span> <span class="o">=</span> <span class="n">empty</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">nonlocal</span> <span class="n">contents</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">'len'</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">len_link</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">'getitem'</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">getitem_link</span><span class="p">(</span><span class="n">contents</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">'push_first'</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">contents</span> <span class="o">=</span> <span class="n">link</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">contents</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">'pop_first'</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
<span class="gp">    </span>            <span class="n">contents</span> <span class="o">=</span> <span class="n">rest</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">f</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">'str'</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">join_link</span><span class="p">(</span><span class="n">contents</span><span class="p">,</span> <span class="s2">", "</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">dispatch</span>
</pre></div>

<p>We can also add a convenience function to construct a functionally implemented
linked list from any built-in sequence, simply by adding each element in
reverse order.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">to_mutable_link</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a functional list with the same contents as source."""</span>
<span class="gp">    </span>    <span class="n">s</span> <span class="o">=</span> <span class="n">mutable_link</span><span class="p">()</span>
<span class="gp">    </span>    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">s</span><span class="p">(</span><span class="s1">'push_first'</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">s</span>
</pre></div>

<p>In the definition above, the function <tt class="docutils literal">reversed</tt> takes and returns an
iterable value; it is another example of a function that processes sequences.</p>
<p>At this point, we can construct a functionally implemented mutable linked
lists.  Note that the linked list itself is a function.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">to_mutable_link</span><span class="p">(</span><span class="n">suits</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">&lt;class 'function'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="s1">'str'</span><span class="p">))</span>
<span class="go">heart, diamond, spade, club</span>
</pre></div>

<p>In addition, we can pass messages to the list <tt class="docutils literal">s</tt> that change its contents,
for instance removing the first element.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">(</span><span class="s1">'pop_first'</span><span class="p">)</span>
<span class="go">'heart'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="s1">'str'</span><span class="p">))</span>
<span class="go">diamond, spade, club</span>
</pre></div>

<p>In principle, the operations <tt class="docutils literal">push_first</tt> and <tt class="docutils literal">pop_first</tt> suffice to make
arbitrary changes to a list.  We can always empty out the list entirely and then
replace its old contents with the desired result.</p>
<p><strong>Message passing.</strong> Given some time, we could implement the many useful
mutation operations of Python lists, such as <tt class="docutils literal">extend</tt> and <tt class="docutils literal">insert</tt>.  We
would have a choice: we could implement them all as functions, which use the
existing messages <tt class="docutils literal">pop_first</tt> and <tt class="docutils literal">push_first</tt> to make all changes.
Alternatively, we could add additional <tt class="docutils literal">elif</tt> clauses to the body of
<tt class="docutils literal">dispatch</tt>, each checking for a message (e.g.,  <tt class="docutils literal">'extend'</tt>) and applying the
appropriate change to <tt class="docutils literal">contents</tt> directly.</p>
<p>This second approach, which encapsulates the logic for all operations on a data
value within one function that responds to different messages, is a discipline
called message passing.  A program that uses message passing defines dispatch
functions, each of which may have local state, and organizes computation by
passing "messages" as the first argument to those functions.  The messages are
strings that correspond to particular behaviors.</p>
<p><strong>Implementing Dictionaries.</strong> We can also implement a value with similar
behavior to a dictionary. In this case, we use a list of key-value pairs to
store the contents of the dictionary. Each pair is a two-element list.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">dictionary</span><span class="p">():</span>
<span class="gp">    </span>    <span class="sd">"""Return a functional implementation of a dictionary."""</span>
<span class="gp">    </span>    <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">]</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">value</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">setitem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">nonlocal</span> <span class="n">records</span>
<span class="gp">    </span>        <span class="n">non_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span> <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">]</span>
<span class="gp">    </span>        <span class="n">records</span> <span class="o">=</span> <span class="n">non_matches</span> <span class="o">+</span> <span class="p">[[</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">]]</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">'getitem'</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="n">message</span> <span class="o">==</span> <span class="s1">'setitem'</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">setitem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">dispatch</span>
</pre></div>

<p>Again, we use the message passing method to organize our implementation.  We
have supported two messages: <tt class="docutils literal">getitem</tt> and <tt class="docutils literal">setitem</tt>.   To insert a value
for a key, we filter out any existing records with the given key, then add one.
In this way, we are assured that each key appears only once in records. To look
up a value for a key, we filter for the record that matches the given key.   We
can now use our implementation to store and retrieve values.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="s1">'setitem'</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="s1">'setitem'</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="s1">'getitem'</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="s1">'getitem'</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">16</span>
</pre></div>

<p>This implementation of a dictionary is <em>not</em> optimized for fast record lookup,
because each call must filter through all records. The built-in dictionary type
is considerably more efficient. The way in which it is implemented is beyond
the scope of this text.</p>
</div>
<div class="section" id="dispatch-dictionaries">
<h3>2.4.12   Dispatch Dictionaries</h3>
<p>The dispatch function is a general method for implementing a message passing
interface for abstract data. To implement message dispatch, we have thus far
used conditional statements to compare the message string to a fixed set of
known messages.</p>
<p>The built-in dictionary data type provides a general method for looking up a
value for a key. Instead of using conditionals to implement dispatching, we can
use dictionaries with string keys.</p>
<p>The mutable <tt class="docutils literal">account</tt> data type below is implemented as a dictionary.  It
has a constructor <tt class="docutils literal">account</tt> and selector <tt class="docutils literal">check_balance</tt>, as well as
functions to <tt class="docutils literal">deposit</tt> or <tt class="docutils literal">withdraw</tt> funds. Moreover, the local state of
the account is stored in the dictionary alongside the functions that implement
its behavior.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="12" id="example_25" style="">
def account(initial_balance):
    def deposit(amount):
        dispatch['balance'] += amount
        return dispatch['balance']
    def withdraw(amount):
        if amount &gt; dispatch['balance']:
            return 'Insufficient funds'
        dispatch['balance'] -= amount
        return dispatch['balance']
    dispatch = {'deposit':   deposit,
                'withdraw':  withdraw,
                'balance':   initial_balance}
    return dispatch

def withdraw(account, amount):
    return account['withdraw'](amount)
def deposit(account, amount):
    return account['deposit'](amount)
def check_balance(account):
    return account['balance']

a = account(20)
deposit(a, 5)
withdraw(a, 17)
check_balance(a)
</div>
<script type="text/javascript">
var example_25_trace = {"code": "def account(initial_balance):\n    def deposit(amount):\n        dispatch['balance'] += amount\n        return dispatch['balance']\n    def withdraw(amount):\n        if amount > dispatch['balance']:\n            return 'Insufficient funds'\n        dispatch['balance'] -= amount\n        return dispatch['balance']\n    dispatch = {'deposit':   deposit,\n                'withdraw':  withdraw,\n                'balance':   initial_balance}\n    return dispatch\n\ndef withdraw(account, amount):\n    return account['withdraw'](amount)\ndef deposit(account, amount):\n    return account['deposit'](amount)\ndef check_balance(account):\n    return account['balance']\n\na = account(20)\ndeposit(a, 5)\nwithdraw(a, 17)\ncheck_balance(a)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"account": ["REF", 1]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null]}, "line": 15, "ordered_globals": ["account"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"account": ["REF", 1], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null]}, "line": 17, "ordered_globals": ["account", "withdraw"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"account": ["REF", 1], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null]}, "line": 19, "ordered_globals": ["account", "withdraw", "deposit"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null]}, "line": 22, "ordered_globals": ["account", "withdraw", "deposit", "check_balance"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "account", "globals": {"account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null]}, "line": 1, "ordered_globals": ["account", "withdraw", "deposit", "check_balance"], "stack_to_render": [{"encoded_locals": {"initial_balance": 20}, "frame_id": 1, "func_name": "account", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["initial_balance"], "parent_frame_id_list": [], "unique_hash": "account_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "account", "globals": {"account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null]}, "line": 2, "ordered_globals": ["account", "withdraw", "deposit", "check_balance"], "stack_to_render": [{"encoded_locals": {"initial_balance": 20}, "frame_id": 1, "func_name": "account", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["initial_balance"], "parent_frame_id_list": [], "unique_hash": "account_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "account", "globals": {"account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1]}, "line": 5, "ordered_globals": ["account", "withdraw", "deposit", "check_balance"], "stack_to_render": [{"encoded_locals": {"deposit": ["REF", 5], "initial_balance": 20}, "frame_id": 1, "func_name": "account", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["initial_balance", "deposit"], "parent_frame_id_list": [], "unique_hash": "account_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "account", "globals": {"account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1]}, "line": 10, "ordered_globals": ["account", "withdraw", "deposit", "check_balance"], "stack_to_render": [{"encoded_locals": {"deposit": ["REF", 5], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["initial_balance", "deposit", "withdraw"], "parent_frame_id_list": [], "unique_hash": "account_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "account", "globals": {"account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1]}, "line": 11, "ordered_globals": ["account", "withdraw", "deposit", "check_balance"], "stack_to_render": [{"encoded_locals": {"deposit": ["REF", 5], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["initial_balance", "deposit", "withdraw"], "parent_frame_id_list": [], "unique_hash": "account_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "account", "globals": {"account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1]}, "line": 12, "ordered_globals": ["account", "withdraw", "deposit", "check_balance"], "stack_to_render": [{"encoded_locals": {"deposit": ["REF", 5], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["initial_balance", "deposit", "withdraw"], "parent_frame_id_list": [], "unique_hash": "account_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "account", "globals": {"account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 20], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 13, "ordered_globals": ["account", "withdraw", "deposit", "check_balance"], "stack_to_render": [{"encoded_locals": {"deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch"], "parent_frame_id_list": [], "unique_hash": "account_f1_p"}], "stdout": ""}, {"event": "return", "func_name": "account", "globals": {"account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 20], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 13, "ordered_globals": ["account", "withdraw", "deposit", "check_balance"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": true, "is_parent": true, "is_zombie": false, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 20], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 23, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}], "stdout": ""}, {"event": "call", "func_name": "deposit", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 20], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 17, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "deposit_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "deposit", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 20], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 18, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "deposit_f2"}], "stdout": ""}, {"event": "call", "func_name": "deposit", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 20], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 2, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "deposit_f2"}, {"encoded_locals": {"amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "deposit", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 20], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 3, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "deposit_f2"}, {"encoded_locals": {"amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "deposit", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 25], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 4, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "deposit_f2"}, {"encoded_locals": {"amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3"}], "stdout": ""}, {"event": "return", "func_name": "deposit", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 25], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 4, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "deposit_f2"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3"}], "stdout": ""}, {"event": "return", "func_name": "deposit", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 25], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 18, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 25], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 24, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 25], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 15, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 25], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 16, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4"}], "stdout": ""}, {"event": "call", "func_name": "withdraw", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 25], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 5, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4"}, {"encoded_locals": {"amount": 17}, "frame_id": 5, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f5"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 25], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 6, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4"}, {"encoded_locals": {"amount": 17}, "frame_id": 5, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f5"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 25], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 8, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4"}, {"encoded_locals": {"amount": 17}, "frame_id": 5, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f5"}], "stdout": ""}, {"event": "step_line", "func_name": "withdraw", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 8], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 9, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4"}, {"encoded_locals": {"amount": 17}, "frame_id": 5, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f5"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 8], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 9, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4"}, {"encoded_locals": {"__return__": 8, "amount": 17}, "frame_id": 5, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f5"}], "stdout": ""}, {"event": "return", "func_name": "withdraw", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 8], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 16, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"__return__": 8, "account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4"}, {"encoded_locals": {"__return__": 8, "amount": 17}, "frame_id": 5, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f5_z"}], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 8], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 25, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"__return__": 8, "account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4_z"}, {"encoded_locals": {"__return__": 8, "amount": 17}, "frame_id": 5, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f5_z"}], "stdout": ""}, {"event": "call", "func_name": "check_balance", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 8], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 19, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"__return__": 8, "account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4_z"}, {"encoded_locals": {"__return__": 8, "amount": 17}, "frame_id": 5, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f5_z"}, {"encoded_locals": {"account": ["REF", 7]}, "frame_id": 6, "func_name": "check_balance", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account"], "parent_frame_id_list": [], "unique_hash": "check_balance_f6"}], "stdout": ""}, {"event": "step_line", "func_name": "check_balance", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 8], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 20, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"__return__": 8, "account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4_z"}, {"encoded_locals": {"__return__": 8, "amount": 17}, "frame_id": 5, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f5_z"}, {"encoded_locals": {"account": ["REF", 7]}, "frame_id": 6, "func_name": "check_balance", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account"], "parent_frame_id_list": [], "unique_hash": "check_balance_f6"}], "stdout": ""}, {"event": "return", "func_name": "check_balance", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 8], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 20, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"__return__": 8, "account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4_z"}, {"encoded_locals": {"__return__": 8, "amount": 17}, "frame_id": 5, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f5_z"}, {"encoded_locals": {"__return__": 8, "account": ["REF", 7]}, "frame_id": 6, "func_name": "check_balance", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["account", "__return__"], "parent_frame_id_list": [], "unique_hash": "check_balance_f6"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"a": ["REF", 7], "account": ["REF", 1], "check_balance": ["REF", 4], "deposit": ["REF", 3], "withdraw": ["REF", 2]}, "heap": {"1": ["FUNCTION", "account(initial_balance)", null], "2": ["FUNCTION", "withdraw(account, amount)", null], "3": ["FUNCTION", "deposit(account, amount)", null], "4": ["FUNCTION", "check_balance(account)", null], "5": ["FUNCTION", "deposit(amount)", 1], "6": ["FUNCTION", "withdraw(amount)", 1], "7": ["DICT", ["balance", 8], ["deposit", ["REF", 5]], ["withdraw", ["REF", 6]]]}, "line": 25, "ordered_globals": ["account", "withdraw", "deposit", "check_balance", "a"], "stack_to_render": [{"encoded_locals": {"__return__": ["REF", 7], "deposit": ["REF", 5], "dispatch": ["REF", 7], "initial_balance": 20, "withdraw": ["REF", 6]}, "frame_id": 1, "func_name": "account", "is_highlighted": false, "is_parent": true, "is_zombie": true, "ordered_varnames": ["initial_balance", "deposit", "withdraw", "dispatch", "__return__"], "parent_frame_id_list": [], "unique_hash": "account_f1_p_z"}, {"encoded_locals": {"__return__": 25, "account": ["REF", 7], "amount": 5}, "frame_id": 2, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "deposit_f2_z"}, {"encoded_locals": {"__return__": 25, "amount": 5}, "frame_id": 3, "func_name": "deposit", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "deposit_f3_z"}, {"encoded_locals": {"__return__": 8, "account": ["REF", 7], "amount": 17}, "frame_id": 4, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "amount", "__return__"], "parent_frame_id_list": [], "unique_hash": "withdraw_f4_z"}, {"encoded_locals": {"__return__": 8, "amount": 17}, "frame_id": 5, "func_name": "withdraw", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["amount", "__return__"], "parent_frame_id_list": [1], "unique_hash": "withdraw_f5_z"}, {"encoded_locals": {"__return__": 8, "account": ["REF", 7]}, "frame_id": 6, "func_name": "check_balance", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["account", "__return__"], "parent_frame_id_list": [], "unique_hash": "check_balance_f6_z"}], "stdout": ""}]}</script><p>The name <tt class="docutils literal">dispatch</tt> within the body of the <tt class="docutils literal">account</tt> constructor is bound
to a dictionary that contains the messages accepted by an account as keys. The
<em>balance</em> is a number, while the messages <em>deposit</em> and <em>withdraw</em> are bound to
functions. These functions have access to the <tt class="docutils literal">dispatch</tt> dictionary, and so
they can read and change the balance. By storing the balance in the dispatch
dictionary rather than in the <tt class="docutils literal">account</tt> frame directly, we avoid the need for
<tt class="docutils literal">nonlocal</tt> statements in <tt class="docutils literal">deposit</tt> and <tt class="docutils literal">withdraw</tt>.</p>
<p>The operators <tt class="docutils literal">+=</tt> and <tt class="docutils literal"><span class="pre">-=</span></tt> are shorthand in Python (and many other
languages) for combined lookup and re-assignment.  The last two lines below are
equivalent.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>

</div>
<div class="section" id="propagating-constraints">
<h3>2.4.13   Propagating Constraints</h3>
<p>Mutable data allows us to simulate systems with change, but also allows us to
build new kinds of abstractions.  In this extended example, we combine nonlocal
assignment, lists, and dictionaries to build a <em>constraint-based system</em> that
supports computation in multiple directions. Expressing programs as constraints
is a type of <em>declarative programming</em>, in which a programmer declares the
structure of a problem to be solved, but abstracts away the details of exactly
how the solution to the problem is computed.</p>
<p>Computer programs are traditionally organized as one-directional computations,
which perform operations on pre-specified arguments to produce desired outputs.
On the other hand, we often want to model systems in terms of relations among
quantities. For example, we previously considered the ideal gas law, which
relates the pressure (<tt class="docutils literal">p</tt>), volume (<tt class="docutils literal">v</tt>), quantity (<tt class="docutils literal">n</tt>), and temperature
(<tt class="docutils literal">t</tt>) of an ideal gas via Boltzmann's constant (<tt class="docutils literal">k</tt>):</p>
<pre class="literal-block">
p * v = n * k * t
</pre>
<p>Such an equation is not one-directional. Given any four of the quantities, we
can use this equation to compute the fifth. Yet translating the equation into a
traditional computer language would force us to choose one of the quantities to
be computed in terms of the other four. Thus, a function for computing the
pressure could not be used to compute the temperature, even though the
computations of both quantities arise from the same equation.</p>
<p>In this section, we sketch the design of a general model of linear
relationships.  We define primitive constraints that hold between quantities,
such as an <tt class="docutils literal">adder(a, b, c)</tt> constraint that enforces the mathematical
relationship <tt class="docutils literal">a + b = c</tt>.</p>
<p>We also define a means of combination, so that primitive constraints can be
combined to express more complex relations.  In this way, our program resembles
a programming language.  We combine constraints by constructing a network in
which constraints are joined by connectors. A connector is an object that
"holds" a value and may participate in one or more constraints.</p>
<p>For example, we know that the relationship between Fahrenheit and Celsius
temperatures is:</p>
<pre class="literal-block">
9 * c = 5 * (f - 32)
</pre>
<p>This equation is a complex constraint between <tt class="docutils literal">c</tt> and <tt class="docutils literal">f</tt>. Such a constraint
can be thought of as a network consisting of primitive <tt class="docutils literal">adder</tt>,
<tt class="docutils literal">multiplier</tt>, and <tt class="docutils literal">constant</tt> constraints.</p>
<div class="figure">
<img alt="" src="../img/constraints.png">
</div>
<p>In this figure, we see on the left a multiplier box with three terminals,
labeled <tt class="docutils literal">a</tt>, <tt class="docutils literal">b</tt>, and <tt class="docutils literal">c</tt>. These connect the multiplier to the rest of the
network as follows: The <tt class="docutils literal">a</tt> terminal is linked to a connector <tt class="docutils literal">celsius</tt>,
which will hold the Celsius temperature. The <tt class="docutils literal">b</tt> terminal is linked to a
connector <tt class="docutils literal">w</tt>, which is also linked to a constant box that holds 9. The <tt class="docutils literal">c</tt>
terminal, which the multiplier box constrains to be the product of <tt class="docutils literal">a</tt> and
<tt class="docutils literal">b</tt>, is linked to the <tt class="docutils literal">c</tt> terminal of another multiplier box, whose <tt class="docutils literal">b</tt>
is connected to a constant 5 and whose <tt class="docutils literal">a</tt> is connected to one of the terms
in the sum constraint.</p>
<p>Computation by such a network proceeds as follows: When a connector is given a
value (by the user or by a constraint box to which it is linked), it awakens all
of its associated constraints (except for the constraint that just awakened it)
to inform them that it has a value. Each awakened constraint box then polls its
connectors to see if there is enough information to determine a value for a
connector. If so, the box sets that connector, which then awakens all of its
associated constraints, and so on. For instance, in conversion between Celsius
and Fahrenheit, <tt class="docutils literal">w</tt>, <tt class="docutils literal">x</tt>, and <tt class="docutils literal">y</tt> are immediately set by the constant
boxes to 9, 5, and 32, respectively. The connectors awaken the
multipliers and the adder, which determine that there is not enough information
to proceed. If the user (or some other part of the network) sets the <tt class="docutils literal">celsius</tt>
connector to a value (say 25), the leftmost multiplier will be awakened, and
it will set <tt class="docutils literal">u</tt> to <tt class="docutils literal">25 * 9 = 225</tt>.  Then <tt class="docutils literal">u</tt> awakens the second
multiplier, which sets <tt class="docutils literal">v</tt> to 45, and <tt class="docutils literal">v</tt> awakens the adder, which sets
the <tt class="docutils literal">fahrenheit</tt> connector to 77.</p>
<p><strong>Using the Constraint System.</strong> To use the constraint system to carry out the
temperature computation outlined above, we first create two named connectors,
<tt class="docutils literal">celsius</tt> and <tt class="docutils literal">fahrenheit</tt>, by calling the <tt class="docutils literal">connector</tt> constructor.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">celsius</span> <span class="o">=</span> <span class="n">connector</span><span class="p">(</span><span class="s1">'Celsius'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fahrenheit</span> <span class="o">=</span> <span class="n">connector</span><span class="p">(</span><span class="s1">'Fahrenheit'</span><span class="p">)</span>
</pre></div>

<p>Then, we link these connectors into a network that mirrors the figure above.
The function <tt class="docutils literal">converter</tt> assembles the various connectors and constraints
in the network.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">converter</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Connect c to f with constraints to convert from Celsius to Fahrenheit."""</span>
<span class="gp">    </span>    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">connector</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">    </span>    <span class="n">multiplier</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">multiplier</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">adder</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">constant</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">constant</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">constant</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">converter</span><span class="p">(</span><span class="n">celsius</span><span class="p">,</span> <span class="n">fahrenheit</span><span class="p">)</span>
</pre></div>

<p>We will use a message passing system to coordinate constraints and connectors.
Constraints are dictionaries that do not hold local states themselves. Their
responses to messages are non-pure functions that change the connectors that
they constrain.</p>
<p>Connectors are dictionaries that hold a current value and respond to messages
that manipulate that value.  Constraints will not change the value of connectors
directly, but instead will do so by sending messages, so that the connector can
notify other constraints in response to the change.  In this way, a connector
represents a number, but also encapsulates connector behavior.</p>
<p>One message we can send to a connector is to set its value.  Here, we (the
<tt class="docutils literal">'user'</tt>) set the value of <tt class="docutils literal">celsius</tt> to 25.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">celsius</span><span class="p">[</span><span class="s1">'set_val'</span><span class="p">](</span><span class="s1">'user'</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="go">Celsius = 25</span>
<span class="go">Fahrenheit = 77.0</span>
</pre></div>

<p>Not only does the value of <tt class="docutils literal">celsius</tt> change to 25, but its value
propagates through the network, and so the value of <tt class="docutils literal">fahrenheit</tt> is changed as
well.  These changes are printed because we named these two connectors when we
constructed them.</p>
<p>Now we can try to set <tt class="docutils literal">fahrenheit</tt> to a new value, say 212.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fahrenheit</span><span class="p">[</span><span class="s1">'set_val'</span><span class="p">](</span><span class="s1">'user'</span><span class="p">,</span> <span class="mi">212</span><span class="p">)</span>
<span class="go">Contradiction detected: 77.0 vs 212</span>
</pre></div>

<p>The connector complains that it has sensed a contradiction: Its value is
77.0, and someone is trying to set it to 212. If we really want to reuse
the network with new values, we can tell <tt class="docutils literal">celsius</tt> to forget its old value:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">celsius</span><span class="p">[</span><span class="s1">'forget'</span><span class="p">](</span><span class="s1">'user'</span><span class="p">)</span>
<span class="go">Celsius is forgotten</span>
<span class="go">Fahrenheit is forgotten</span>
</pre></div>

<p>The connector <tt class="docutils literal">celsius</tt> finds that the <tt class="docutils literal">user</tt>, who set its value originally,
is now retracting that value, so <tt class="docutils literal">celsius</tt> agrees to lose its value, and it
informs the rest of the network of this fact. This information eventually
propagates to <tt class="docutils literal">fahrenheit</tt>, which now finds that it has no reason for
continuing to believe that its own value is 77. Thus, it also gives up its
value.</p>
<p>Now that <tt class="docutils literal">fahrenheit</tt> has no value, we are free to set it to 212:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fahrenheit</span><span class="p">[</span><span class="s1">'set_val'</span><span class="p">](</span><span class="s1">'user'</span><span class="p">,</span> <span class="mi">212</span><span class="p">)</span>
<span class="go">Fahrenheit = 212</span>
<span class="go">Celsius = 100.0</span>
</pre></div>

<p>This new value, when propagated through the network, forces <tt class="docutils literal">celsius</tt> to have
a value of 100. We have used the very same network to compute <tt class="docutils literal">celsius</tt>
given <tt class="docutils literal">fahrenheit</tt> and to compute <tt class="docutils literal">fahrenheit</tt> given <tt class="docutils literal">celsius</tt>. This
non-directionality of computation is the distinguishing feature of
constraint-based systems.</p>
<p><strong>Implementing the Constraint System.</strong> As we have seen, connectors are
dictionaries that map message names to function and data values.  We will
implement connectors that respond to the following messages:</p>
<ul class="simple">
<li>
<tt class="docutils literal"><span class="pre">connector['set_val'](source,</span> value)</tt> indicates that the <tt class="docutils literal">source</tt> is
requesting the connector to set its current value to <tt class="docutils literal">value</tt>.</li>
<li>
<tt class="docutils literal"><span class="pre">connector['has_val']()</span></tt> returns whether the connector already has a value.</li>
<li>
<tt class="docutils literal"><span class="pre">connector['val']</span></tt> is the current value of the connector.</li>
<li>
<tt class="docutils literal"><span class="pre">connector['forget'](source)</span></tt> tells the connector that the <tt class="docutils literal">source</tt> is
requesting it to forget its value.</li>
<li>
<tt class="docutils literal"><span class="pre">connector['connect'](source)</span></tt> tells the connector to participate in a new
constraint, the <tt class="docutils literal">source</tt>.</li>
</ul>
<p>Constraints are also dictionaries, which receive information from connectors by
means of two messages:</p>
<ul class="simple">
<li>
<tt class="docutils literal"><span class="pre">constraint['new_val']()</span></tt> indicates that some connector that is connected to
the constraint has a new value.</li>
<li>
<tt class="docutils literal"><span class="pre">constraint['forget']()</span></tt> indicates that some connector that is connected to
the constraint has forgotten its value.</li>
</ul>
<p>When constraints receive these messages, they propagate them appropriately to
other connectors.</p>
<p>The <tt class="docutils literal">adder</tt> function constructs an adder constraint over three connectors,
where the first two must add to the third: <tt class="docutils literal">a + b = c</tt>.  To support
multidirectional constraint propagation, the adder must also specify that it
subtracts <tt class="docutils literal">a</tt> from <tt class="docutils literal">c</tt> to get <tt class="docutils literal">b</tt> and likewise subtracts <tt class="docutils literal">b</tt> from <tt class="docutils literal">c</tt>
to get <tt class="docutils literal">a</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">add</span><span class="p">,</span> <span class="n">sub</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">adder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""The constraint that a + b = c."""</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">make_ternary_constraint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>
</pre></div>

<p>We would like to implement a generic ternary (three-way) constraint, which
uses the three connectors and three functions from <tt class="docutils literal">adder</tt> to create a
constraint that accepts <tt class="docutils literal">new_val</tt> and <tt class="docutils literal">forget</tt> messages.  The response to
messages are local functions, which are placed in a dictionary called
<tt class="docutils literal">constraint</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">make_ternary_constraint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ab</span><span class="p">,</span> <span class="n">ca</span><span class="p">,</span> <span class="n">cb</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""The constraint that ab(a,b)=c and ca(c,a)=b and cb(c,b) = a."""</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">new_value</span><span class="p">():</span>
<span class="gp">    </span>        <span class="n">av</span><span class="p">,</span> <span class="n">bv</span><span class="p">,</span> <span class="n">cv</span> <span class="o">=</span> <span class="p">[</span><span class="n">connector</span><span class="p">[</span><span class="s1">'has_val'</span><span class="p">]()</span> <span class="k">for</span> <span class="n">connector</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)]</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">av</span> <span class="ow">and</span> <span class="n">bv</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">c</span><span class="p">[</span><span class="s1">'set_val'</span><span class="p">](</span><span class="n">constraint</span><span class="p">,</span> <span class="n">ab</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="s1">'val'</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]))</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="n">av</span> <span class="ow">and</span> <span class="n">cv</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">b</span><span class="p">[</span><span class="s1">'set_val'</span><span class="p">](</span><span class="n">constraint</span><span class="p">,</span> <span class="n">ca</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">'val'</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]))</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="n">bv</span> <span class="ow">and</span> <span class="n">cv</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">a</span><span class="p">[</span><span class="s1">'set_val'</span><span class="p">](</span><span class="n">constraint</span><span class="p">,</span> <span class="n">cb</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">'val'</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]))</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">forget_value</span><span class="p">():</span>
<span class="gp">    </span>        <span class="k">for</span> <span class="n">connector</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="gp">    </span>            <span class="n">connector</span><span class="p">[</span><span class="s1">'forget'</span><span class="p">](</span><span class="n">constraint</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">constraint</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'new_val'</span><span class="p">:</span> <span class="n">new_value</span><span class="p">,</span> <span class="s1">'forget'</span><span class="p">:</span> <span class="n">forget_value</span><span class="p">}</span>
<span class="gp">    </span>    <span class="k">for</span> <span class="n">connector</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">connector</span><span class="p">[</span><span class="s1">'connect'</span><span class="p">](</span><span class="n">constraint</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">constraint</span>
</pre></div>

<p>The dictionary called <tt class="docutils literal">constraint</tt> is a dispatch dictionary, but also the
constraint object itself. It responds to the two messages that constraints
receive, but is also passed as the <tt class="docutils literal">source</tt> argument in calls to its
connectors.</p>
<p>The constraint's local function <tt class="docutils literal">new_value</tt> is called whenever the constraint
is informed that one of its connectors has a value. This function first checks
to see if both <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> have values. If so, it tells <tt class="docutils literal">c</tt> to set its
value to the return value of function <tt class="docutils literal">ab</tt>, which is <tt class="docutils literal">add</tt> in the case of an
<tt class="docutils literal">adder</tt>. The constraint passes <em>itself</em> (<tt class="docutils literal">constraint</tt>) as the <tt class="docutils literal">source</tt>
argument of the connector, which is the adder object. If <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> do not
both have values, then the constraint checks <tt class="docutils literal">a</tt> and <tt class="docutils literal">c</tt>, and so on.</p>
<p>If the constraint is informed that one of its connectors has forgotten its
value, it requests that all of its connectors now forget their values. (Only
those values that were set by this constraint are actually lost.)</p>
<p>A <tt class="docutils literal">multiplier</tt> is very similar to an <tt class="docutils literal">adder</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">mul</span><span class="p">,</span> <span class="n">truediv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">multiplier</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""The constraint that a * b = c."""</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">make_ternary_constraint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">truediv</span><span class="p">,</span> <span class="n">truediv</span><span class="p">)</span>
</pre></div>

<p>A constant is a constraint as well, but one that is never sent any messages,
because it involves only a single connector that it sets on construction.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""The constraint that connector = value."""</span>
<span class="gp">    </span>    <span class="n">constraint</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">    </span>    <span class="n">connector</span><span class="p">[</span><span class="s1">'set_val'</span><span class="p">](</span><span class="n">constraint</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">constraint</span>
</pre></div>

<p>These three constraints are sufficient to implement our temperature conversion
network.</p>
<p><strong>Representing connectors.</strong> A connector is represented as a dictionary that
contains a value, but also has response functions with local state.  The
connector must track the <tt class="docutils literal">informant</tt> that gave it its current value, and a
list of <tt class="docutils literal">constraints</tt> in which it participates.</p>
<p>The constructor <tt class="docutils literal">connector</tt> has local functions for setting and
forgetting values, which are the responses to messages from constraints.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">connector</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""A connector between constraints."""</span>
<span class="gp">    </span>    <span class="n">informant</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">    </span>    <span class="n">constraints</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">nonlocal</span> <span class="n">informant</span>
<span class="gp">    </span>        <span class="n">val</span> <span class="o">=</span> <span class="n">connector</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">informant</span><span class="p">,</span> <span class="n">connector</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span>
<span class="gp">    </span>            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">    </span>                <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">'='</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">    </span>            <span class="n">inform_all_except</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s1">'new_val'</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
<span class="gp">    </span>                <span class="nb">print</span><span class="p">(</span><span class="s1">'Contradiction detected:'</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="s1">'vs'</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">forget_value</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">nonlocal</span> <span class="n">informant</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">informant</span> <span class="o">==</span> <span class="n">source</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">informant</span><span class="p">,</span> <span class="n">connector</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
<span class="gp">    </span>            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">    </span>                <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">'is forgotten'</span><span class="p">)</span>
<span class="gp">    </span>            <span class="n">inform_all_except</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s1">'forget'</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">connector</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'val'</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
<span class="gp">    </span>                 <span class="s1">'set_val'</span><span class="p">:</span> <span class="n">set_value</span><span class="p">,</span>
<span class="gp">    </span>                 <span class="s1">'forget'</span><span class="p">:</span> <span class="n">forget_value</span><span class="p">,</span>
<span class="gp">    </span>                 <span class="s1">'has_val'</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">connector</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
<span class="gp">    </span>                 <span class="s1">'connect'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">source</span><span class="p">:</span> <span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)}</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">connector</span>
</pre></div>

<p>A connector is again a dispatch dictionary for the five messages used by
constraints to communicate with connectors. Four responses are functions, and
the final response is the value itself.</p>
<p>The local function <tt class="docutils literal">set_value</tt> is called when there is a request to set the
connector's value. If the connector does not currently have a value, it will set
its value and remember as <tt class="docutils literal">informant</tt> the source constraint that requested the
value to be set. Then the connector will notify all of its participating
constraints except the constraint that requested the value to be set. This is
accomplished using the following iterative function.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">inform_all_except</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">constraints</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Inform all constraints of the message, except source."""</span>
<span class="gp">    </span>    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">source</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">c</span><span class="p">[</span><span class="n">message</span><span class="p">]()</span>
</pre></div>

<p>If a connector is asked to forget its value, it calls the local function
<tt class="docutils literal"><span class="pre">forget-value</span></tt>, which first checks to make sure that the request is coming
from the same constraint that set the value originally. If so, the connector
informs its associated constraints about the loss of the value.</p>
<p>The response to the message <tt class="docutils literal">has_val</tt> indicates whether the connector has a
value.  The response to the message <tt class="docutils literal">connect</tt> adds the source constraint to
the list of constraints.</p>
<p>The constraint program we have designed introduces many ideas that will appear
again in object-oriented programming.  Constraints and connectors are both
abstractions that are manipulated through messages.  When the value of a
connector is changed, it is changed via a message that not only changes the
value, but validates it (checking the source) and propagates its effects
(informing other constraints).  In fact, we will use a similar architecture of
dictionaries with string-valued keys and functional values to implement an
object-oriented system later in this chapter.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/25-object-oriented-programming.html">
  		2.5 Object-Oriented Programming
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="object-oriented-programming">
<h2>2.5   Object-Oriented Programming</h2>
<p>Object-oriented programming (OOP) is a method for organizing programs that
brings together many of the ideas introduced in this chapter. Like the
functions in data abstraction, classes create abstraction barriers between the
use and implementation of data. Like dispatch dictionaries, objects
respond to behavioral requests. Like mutable data structures, objects have
local state that is not directly accessible from the global environment.
The Python object system provides convenient syntax to promote the use of these
techniques for organizing programs. Much of this syntax is shared among other
object-oriented programming languages.</p>
<p>The object system offers more than just convenience. It enables a new metaphor
for designing programs in which several independent agents interact within the
computer. Each object bundles together local state and behavior in a
way that abstracts the complexity of both. Objects communicate with each other,
and useful results are computed as a consequence of their interaction.  Not
only do objects pass messages, they also share behavior among other objects of
the same type and inherit characteristics from related types.</p>
<p>The paradigm of object-oriented programming has its own vocabulary that
supports the object metaphor.  We have seen that an object is a data value
that has methods and attributes, accessible via dot notation. Every object also
has a type, called its <em>class</em>.  To create new types of data, we implement new
classes.</p>
<div class="section" id="objects-and-classes">
<h3>2.5.1   Objects and Classes</h3>
<p>A class serves as a template for all objects whose type is that class. Every
object is an instance of some particular class.  The objects we have used so
far all have built-in classes, but new user-defined classes can be created as
well. A class definition specifies the attributes and methods shared among
objects of that class.  We will introduce the class statement by revisiting the
example of a bank account.</p>
<p>When introducing local state, we saw that bank accounts are naturally modeled
as mutable values that have a <tt class="docutils literal">balance</tt>.  A bank account object should have a
<tt class="docutils literal">withdraw</tt> method that updates the account balance and returns the requested
amount, if it is available.  To complete the abstraction: a bank account should
be able to return its current <tt class="docutils literal">balance</tt>, return the name of the account
<tt class="docutils literal">holder</tt>, and an amount for <tt class="docutils literal">deposit</tt>.</p>
<p>An <tt class="docutils literal">Account</tt> class allows us to create multiple instances of bank accounts.
The act of creating a new object instance is known as <em>instantiating</em> the
class. The syntax in Python for instantiating a class is identical to the
syntax of calling a function.  In this case, we call <tt class="docutils literal">Account</tt> with the
argument <tt class="docutils literal">'Kirk'</tt>, the account holder's name.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="s1">'Kirk'</span><span class="p">)</span>
</pre></div>

<p>An <em>attribute</em> of an object is a name-value pair associated with the object,
which is accessible via dot notation.  The attributes specific to a particular
object, as opposed to all objects of a class, are called <em>instance attributes</em>.
Each <tt class="docutils literal">Account</tt> has its own balance and account holder name, which are examples
of instance attributes. In the broader programming community, instance
attributes may also be called <em>fields</em>, <em>properties</em>, or <em>instance variables</em>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">holder</span>
<span class="go">'Kirk'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">balance</span>
<span class="go">0</span>
</pre></div>

<p>Functions that operate on the object or perform object-specific computations are
called methods. The return values and side effects of a method can depend upon
and change other attributes of the object.  For example, <tt class="docutils literal">deposit</tt> is a
method of our <tt class="docutils literal">Account</tt> object <tt class="docutils literal">a</tt>. It takes one argument, the amount to
deposit, changes the <tt class="docutils literal">balance</tt> attribute of the object, and returns the
resulting balance.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>

<p>We say that methods are <em>invoked</em> on a particular object.  As a result
of invoking the <tt class="docutils literal">withdraw</tt> method, either the withdrawal is approved and the
amount is deducted, or the request is declined and the method returns an error
message.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># The withdraw method returns the balance after withdrawal</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">balance</span>       <span class="c1"># The balance attribute has changed</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">'Insufficient funds'</span>
</pre></div>

<p>As illustrated above, the behavior of a method can depend upon the changing
attributes of the object.  Two calls to <tt class="docutils literal">withdraw</tt> with the same argument
return different results.</p>
</div>
<div class="section" id="defining-classes">
<h3>2.5.2   Defining Classes</h3>
<p>User-defined classes are created by <tt class="docutils literal">class</tt> statements, which consist of a
single clause.   A class statement defines the class name, then includes a suite
of statements to define the attributes of the class:</p>
<pre class="literal-block">
class &lt;name&gt;:
    &lt;suite&gt;
</pre>
<p>When a class statement is executed, a new class is created and bound to
<tt class="docutils literal">&lt;name&gt;</tt> in the first frame of the current environment.  The suite is then
executed.  Any names bound within the <tt class="docutils literal">&lt;suite&gt;</tt>  of a <tt class="docutils literal">class</tt> statement,
through <tt class="docutils literal">def</tt> or assignment statements, create or modify attributes of the
class.</p>
<p>Classes are typically organized around manipulating instance attributes, which
are the name-value pairs associated with each instance of that class.  The
class specifies the instance attributes of its objects by defining a method for
initializing new objects.  For example, part of initializing an object of the
<tt class="docutils literal">Account</tt> class is to assign it a starting balance of 0.</p>
<p>The <tt class="docutils literal">&lt;suite&gt;</tt> of a <tt class="docutils literal">class</tt> statement contains <tt class="docutils literal">def</tt> statements that define
new methods for objects of that class.  The method that initializes objects has
a special name in Python, <tt class="docutils literal">__init__</tt> (two underscores on each side of the
word "init"), and is called the <em>constructor</em> for the class.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Account</span><span class="p">:</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">):</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">holder</span> <span class="o">=</span> <span class="n">account_holder</span>
</pre></div>

<p>The <tt class="docutils literal">__init__</tt> method for <tt class="docutils literal">Account</tt> has two formal parameters.  The first
one, <tt class="docutils literal">self</tt>, is bound to the newly created <tt class="docutils literal">Account</tt> object. The second
parameter, <tt class="docutils literal">account_holder</tt>, is bound to the argument passed to the class
when it is called to be instantiated.</p>
<p>The constructor binds the instance attribute name <tt class="docutils literal">balance</tt> to 0.  It also
binds the attribute name <tt class="docutils literal">holder</tt> to the value of the name
<tt class="docutils literal">account_holder</tt>. The formal parameter <tt class="docutils literal">account_holder</tt> is a local name in
the <tt class="docutils literal">__init__</tt> method.  On the other hand, the name <tt class="docutils literal">holder</tt> that is bound
via the final assignment statement persists, because it is stored as an
attribute of <tt class="docutils literal">self</tt> using dot notation.</p>
<p>Having defined the <tt class="docutils literal">Account</tt> class, we can instantiate it.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="s1">'Kirk'</span><span class="p">)</span>
</pre></div>

<p>This "call" to the <tt class="docutils literal">Account</tt> class creates a new object that is an instance of
<tt class="docutils literal">Account</tt>, then calls the constructor function <tt class="docutils literal">__init__</tt> with two
arguments: the newly created object and the string <tt class="docutils literal">'Kirk'</tt>.  By convention, we
use the parameter name <tt class="docutils literal">self</tt> for the first argument of a constructor, because
it is bound to the object being instantiated.  This convention is adopted in
virtually all Python code.</p>
<p>Now, we can access the object's <tt class="docutils literal">balance</tt> and <tt class="docutils literal">holder</tt> using dot notation.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">balance</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">holder</span>
<span class="go">'Kirk'</span>
</pre></div>

<p><strong>Identity.</strong> Each new account instance has its own balance attribute, the
value of which is independent of other objects of the same class.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="s1">'Spock'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">acc</span><span class="o">.</span><span class="n">balance</span> <span class="k">for</span> <span class="n">acc</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span>
<span class="go">[0, 200]</span>
</pre></div>

<p>To enforce this separation, every object that is an instance of a user-defined
class has a unique identity.  Object identity is compared using the <tt class="docutils literal">is</tt> and
<tt class="docutils literal">is not</tt> operators.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">b</span>
<span class="go">True</span>
</pre></div>

<p>Despite being constructed from identical calls, the objects bound to <tt class="docutils literal">a</tt> and
<tt class="docutils literal">b</tt> are not the same.  As usual, binding an object to a new name using
assignment does not create a new object.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>

<p>New objects that have user-defined classes are only created when a class (such
as <tt class="docutils literal">Account</tt>) is instantiated with call expression syntax.</p>
<p><strong>Methods.</strong> Object methods are also defined by a <tt class="docutils literal">def</tt> statement in the suite
of a <tt class="docutils literal">class</tt> statement.  Below, <tt class="docutils literal">deposit</tt> and <tt class="docutils literal">withdraw</tt> are both defined
as methods on objects of the <tt class="docutils literal">Account</tt> class.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Account</span><span class="p">:</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">):</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">holder</span> <span class="o">=</span> <span class="n">account_holder</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">+</span> <span class="n">amount</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="s1">'Insufficient funds'</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">-</span> <span class="n">amount</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span>
</pre></div>

<p>While method definitions do not differ from function definitions in how they
are declared, method definitions do have a different effect when executed.  The
function value that is created by a <tt class="docutils literal">def</tt> statement within a <tt class="docutils literal">class</tt>
statement is bound to the declared name, but bound locally within the class as
an attribute. That value is invoked as a method using dot notation from an
instance of the class.</p>
<p>Each method definition again includes a special first parameter <tt class="docutils literal">self</tt>,
which is bound to the object on which the method is invoked.  For example,
let us say that <tt class="docutils literal">deposit</tt> is invoked on a particular <tt class="docutils literal">Account</tt> object and
passed a single argument value: the amount deposited.  The object itself is
bound to <tt class="docutils literal">self</tt>, while the argument is bound to <tt class="docutils literal">amount</tt>.  All invoked
methods have access to the object via the <tt class="docutils literal">self</tt> parameter, and so they can
all access and manipulate the object's state.</p>
<p>To invoke these methods, we again use dot notation, as illustrated below.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spock_account</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="s1">'Spock'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spock_account</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spock_account</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spock_account</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
<span class="go">'Insufficient funds'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spock_account</span><span class="o">.</span><span class="n">holder</span>
<span class="go">'Spock'</span>
</pre></div>

<p>When a method is invoked via dot notation, the object itself (bound to
<tt class="docutils literal">spock_account</tt>, in this case) plays a dual role.  First, it determines what the
name <tt class="docutils literal">withdraw</tt> means; <tt class="docutils literal">withdraw</tt> is not a name in the environment, but
instead a name that is local to the <tt class="docutils literal">Account</tt> class.  Second, it is bound to
the first parameter <tt class="docutils literal">self</tt> when the <tt class="docutils literal">withdraw</tt> method is invoked.</p>
</div>
<div class="section" id="message-passing-and-dot-expressions">
<h3>2.5.3   Message Passing and Dot Expressions</h3>
<p>Methods, which are defined in classes, and instance attributes, which are
typically assigned in constructors, are the fundamental elements of
object-oriented programming.  These two concepts replicate much of the
behavior of a dispatch dictionary in a message passing implementation of a data
value.  Objects take messages using dot notation, but instead of those messages
being arbitrary string-valued keys, they are names local to a class.  Objects
also have named local state values (the instance attributes), but that state
can be accessed and manipulated using dot notation, without having to employ
<tt class="docutils literal">nonlocal</tt> statements in the implementation.</p>
<p>The central idea in message passing was that data values should have behavior by
responding to messages that are relevant to the abstract type they represent.
Dot notation is a syntactic feature of Python that formalizes the message
passing metaphor. The advantage of using a language with a built-in object
system is that message passing can interact seamlessly with other language
features, such as assignment statements.  We do not require different messages
to "get" or "set" the value associated with a local attribute name; the
language syntax allows us to use the message name directly.</p>
<p><strong>Dot expressions.</strong> The code fragment <tt class="docutils literal">spock_account.deposit</tt> is called a <em>dot
expression</em>. A dot expression consists of an expression, a dot, and a name:</p>
<pre class="literal-block">
&lt;expression&gt; . &lt;name&gt;
</pre>
<p>The <tt class="docutils literal">&lt;expression&gt;</tt> can be any valid Python expression, but the <tt class="docutils literal">&lt;name&gt;</tt> must
be a simple name (not an expression that evaluates to a name).  A dot expression
evaluates to the value of the attribute with the given <tt class="docutils literal">&lt;name&gt;</tt>, for the
object that is the value of the <tt class="docutils literal">&lt;expression&gt;</tt>.</p>
<p>The built-in function <tt class="docutils literal">getattr</tt> also returns an attribute for an object by
name.  It is the function equivalent of dot notation.  Using <tt class="docutils literal">getattr</tt>, we can
look up an attribute using a string, just as we did with a dispatch dictionary.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">getattr</span><span class="p">(</span><span class="n">spock_account</span><span class="p">,</span> <span class="s1">'balance'</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>

<p>We can also test whether an object has a named attribute with <tt class="docutils literal">hasattr</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">spock_account</span><span class="p">,</span> <span class="s1">'deposit'</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>

<p>The attributes of an object include all of its instance attributes, along with
all of the attributes (including methods) defined in its class.  Methods are
attributes of the class that require special handling.</p>
<p><strong>Methods and functions.</strong> When a method is invoked on an object, that object is
implicitly passed as the first argument to the method. That is, the object that
is the value of the <tt class="docutils literal">&lt;expression&gt;</tt> to the left of the dot is passed
automatically as the first argument to the method named on the right side of the
dot expression.  As a result, the object is bound to the parameter <tt class="docutils literal">self</tt>.</p>
<p>To achieve automatic <tt class="docutils literal">self</tt> binding, Python distinguishes between
<em>functions</em>, which we have been creating since the beginning of the text, and
<em>bound methods</em>, which couple together a function and the object on which
that method will be invoked. A bound method value is already associated with its
first argument, the instance on which it was invoked, which will be named
<tt class="docutils literal">self</tt> when the method is called.</p>
<p>We can see the difference in the interactive interpreter by calling <tt class="docutils literal">type</tt> on
the returned values of dot expressions.  As an attribute of a class, a method
is just a function, but as an attribute of an instance, it is a bound method:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Account</span><span class="o">.</span><span class="n">deposit</span><span class="p">)</span>
<span class="go">&lt;class 'function'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">spock_account</span><span class="o">.</span><span class="n">deposit</span><span class="p">)</span>
<span class="go">&lt;class 'method'&gt;</span>
</pre></div>

<p>These two results differ only in the fact that the first is a standard
two-argument function with parameters <tt class="docutils literal">self</tt> and <tt class="docutils literal">amount</tt>. The second
is a one-argument method, where the name <tt class="docutils literal">self</tt> will be bound to the object
named <tt class="docutils literal">spock_account</tt> automatically when the method is called, while the
parameter <tt class="docutils literal">amount</tt> will be bound to the argument passed to the method. Both of
these values, whether function values or bound method values, are associated
with the same <tt class="docutils literal">deposit</tt> function body.</p>
<p>We can call <tt class="docutils literal">deposit</tt> in two ways: as a function and as a bound method.  In
the former case, we must supply an argument for the <tt class="docutils literal">self</tt> parameter
explicitly.  In the latter case, the <tt class="docutils literal">self</tt> parameter is bound automatically.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Account</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">spock_account</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c1"># The deposit function takes 2 arguments</span>
<span class="go">1011</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spock_account</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>           <span class="c1"># The deposit method takes 1 argument</span>
<span class="go">2011</span>
</pre></div>

<p>The function <tt class="docutils literal">getattr</tt> behaves exactly like dot notation: if its first
argument is an object but the name is a method defined in the class, then
<tt class="docutils literal">getattr</tt> returns a bound method value.  On the other hand, if the first
argument is a class, then <tt class="docutils literal">getattr</tt> returns the attribute value directly,
which is a plain function.</p>
<p><strong>Naming Conventions.</strong> Class names are conventionally written using the
CapWords convention (also called CamelCase because the capital letters in the
middle of a name look like humps).  Method names follow the standard convention
of naming functions using lowercased words separated by underscores.</p>
<p>In some cases, there are instance variables and methods that are related to the
maintenance and consistency of an object that we don't want users of the object
to see or use.  They are not part of the abstraction defined by a class, but
instead part of the implementation.  Python's convention dictates that if an
attribute name starts with an underscore, it should only be accessed within
methods of the class itself, rather than by users of the class.</p>
</div>
<div class="section" id="class-attributes">
<h3>2.5.4   Class Attributes</h3>
<p>Some attribute values are shared across all objects of a given class. Such
attributes are associated with the class itself, rather than any individual
instance of the class. For instance, let us say that a bank pays interest on the
balance of accounts at a fixed interest rate. That interest rate may change, but
it is a single value shared across all accounts.</p>
<p>Class attributes are created by assignment statements in the suite of a
<tt class="docutils literal">class</tt> statement, outside of any method definition. In the broader developer
community, class attributes may also be called class variables or static
variables. The following class statement creates a class attribute for
<tt class="docutils literal">Account</tt> with the name <tt class="docutils literal">interest</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Account</span><span class="p">:</span>
<span class="gp">    </span>    <span class="n">interest</span> <span class="o">=</span> <span class="mf">0.02</span>            <span class="c1"># A class attribute</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">):</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">holder</span> <span class="o">=</span> <span class="n">account_holder</span>
<span class="gp">    </span>    <span class="c1"># Additional methods would be defined here</span>
</pre></div>

<p>This attribute can still be accessed from any instance of the class.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spock_account</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="s1">'Spock'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kirk_account</span> <span class="o">=</span> <span class="n">Account</span><span class="p">(</span><span class="s1">'Kirk'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spock_account</span><span class="o">.</span><span class="n">interest</span>
<span class="go">0.02</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kirk_account</span><span class="o">.</span><span class="n">interest</span>
<span class="go">0.02</span>
</pre></div>

<p>However, a single assignment statement to a class attribute changes the value of
the attribute for all instances of the class.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Account</span><span class="o">.</span><span class="n">interest</span> <span class="o">=</span> <span class="mf">0.04</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spock_account</span><span class="o">.</span><span class="n">interest</span>
<span class="go">0.04</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kirk_account</span><span class="o">.</span><span class="n">interest</span>
<span class="go">0.04</span>
</pre></div>

<p><strong>Attribute names.</strong> We have introduced enough complexity into our object system
that we have to specify how names are resolved to particular attributes.  After
all, we could easily have a class attribute and an instance attribute with the
same name.</p>
<p>As we have seen, a dot expression consists of an expression, a dot, and a name:</p>
<pre class="literal-block">
&lt;expression&gt; . &lt;name&gt;
</pre>
<p>To evaluate a dot expression:</p>
<ol class="arabic simple">
<li>Evaluate the <tt class="docutils literal">&lt;expression&gt;</tt> to the left of the dot, which yields the
<em>object</em> of the dot expression.</li>
<li>
<tt class="docutils literal">&lt;name&gt;</tt> is matched against the instance attributes of that object; if an
attribute with that name exists, its value is returned.</li>
<li>If <tt class="docutils literal">&lt;name&gt;</tt> does not appear among instance attributes, then <tt class="docutils literal">&lt;name&gt;</tt> is
looked up in the class, which yields a class attribute value.</li>
<li>That value is returned unless it is a function, in which case a bound method
is returned instead.</li>
</ol>
<p>In this evaluation procedure, instance attributes are found before class
attributes, just as local names have priority over global in an environment.
Methods defined within the class are combined with the object of the dot
expression to form a bound method during the fourth step of this evaluation
procedure.  The procedure for looking up a name in a class has additional
nuances that will arise shortly, once we introduce class inheritance.</p>
<p><strong>Attribute assignment.</strong> All assignment statements that contain a dot
expression on their left-hand side affect attributes for the object of that dot
expression.  If the object is an instance, then assignment sets an instance
attribute.  If the object is a class, then assignment sets a class attribute.
As a consequence of this rule, assignment to an attribute of an object cannot
affect the attributes of its class.  The examples below illustrate this
distinction.</p>
<p>If we assign to the named attribute <tt class="docutils literal">interest</tt> of an account instance, we
create a new instance attribute that has the same name as the existing class
attribute.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kirk_account</span><span class="o">.</span><span class="n">interest</span> <span class="o">=</span> <span class="mf">0.08</span>
</pre></div>

<p>and that attribute value will be returned from a dot expression.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kirk_account</span><span class="o">.</span><span class="n">interest</span>
<span class="go">0.08</span>
</pre></div>

<p>However, the class attribute <tt class="docutils literal">interest</tt> still retains its original value,
which is returned for all other accounts.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spock_account</span><span class="o">.</span><span class="n">interest</span>
<span class="go">0.04</span>
</pre></div>

<p>Changes to the class attribute <tt class="docutils literal">interest</tt> will affect <tt class="docutils literal">spock_account</tt>, but the
instance attribute for <tt class="docutils literal">kirk_account</tt> will be unaffected.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Account</span><span class="o">.</span><span class="n">interest</span> <span class="o">=</span> <span class="mf">0.05</span>  <span class="c1"># changing the class attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spock_account</span><span class="o">.</span><span class="n">interest</span>     <span class="c1"># changes instances without like-named instance attributes</span>
<span class="go">0.05</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kirk_account</span><span class="o">.</span><span class="n">interest</span>     <span class="c1"># but the existing instance attribute is unaffected</span>
<span class="go">0.08</span>
</pre></div>

</div>
<div class="section" id="inheritance">
<h3>2.5.5   Inheritance</h3>
<p>When working in the object-oriented programming paradigm, we often find that
different types are related.  In particular, we find that similar classes differ
in their amount of specialization. Two classes may have similar attributes, but
one represents a special case of the other.</p>
<p>For example, we may want to implement a checking account, which is different
from a standard account. A checking account charges an extra $1 for each
withdrawal and has a lower interest rate.  Here, we demonstrate the desired
behavior.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ch</span> <span class="o">=</span> <span class="n">CheckingAccount</span><span class="p">(</span><span class="s1">'Spock'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ch</span><span class="o">.</span><span class="n">interest</span>     <span class="c1"># Lower interest rate for checking accounts</span>
<span class="go">0.01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ch</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>  <span class="c1"># Deposits are the same</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ch</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># withdrawals decrease balance by an extra charge</span>
<span class="go">14</span>
</pre></div>

<p>A <tt class="docutils literal">CheckingAccount</tt> is a specialization of an <tt class="docutils literal">Account</tt>.  In OOP
terminology, the generic account will serve as the base class of
<tt class="docutils literal">CheckingAccount</tt>, while <tt class="docutils literal">CheckingAccount</tt> will be a subclass of
<tt class="docutils literal">Account</tt>.  (The terms <em>parent class</em> and <em>superclass</em> are also used for the
base class, while <em>child class</em> is also used for the subclass.)</p>
<p>A subclass <em>inherits</em> the attributes of its base class, but may <em>override</em>
certain attributes, including certain methods. With inheritance, we only specify
what is different between the subclass and the base class. Anything that we
leave unspecified in the subclass is automatically assumed to behave just as it
would for the base class.</p>
<p>Inheritance also has a role in our object metaphor, in addition to being a
useful organizational feature.  Inheritance is meant to represent <em>is-a</em>
relationships between classes, which contrast with <em>has-a</em> relationships.  A
checking account <em>is-a</em> specific type of account, so having a
<tt class="docutils literal">CheckingAccount</tt> inherit from <tt class="docutils literal">Account</tt> is an appropriate use of
inheritance. On the other hand, a bank <em>has-a</em> list of bank accounts that it
manages, so neither should inherit from the other.  Instead, a list of account
objects would be naturally expressed as an instance attribute of a bank object.</p>
</div>
<div class="section" id="using-inheritance">
<h3>2.5.6   Using Inheritance</h3>
<p>First, we give a full implementation of the <tt class="docutils literal">Account</tt> class, which
includes docstrings for the class and its methods.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Account</span><span class="p">:</span>
<span class="gp">    </span>    <span class="sd">"""A bank account that has a non-negative balance."""</span>
<span class="gp">    </span>    <span class="n">interest</span> <span class="o">=</span> <span class="mf">0.02</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">):</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">holder</span> <span class="o">=</span> <span class="n">account_holder</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
<span class="gp">    </span>        <span class="sd">"""Increase the account balance by amount and return the new balance."""</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">+</span> <span class="n">amount</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
<span class="gp">    </span>        <span class="sd">"""Decrease the account balance by amount and return the new balance."""</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="s1">'Insufficient funds'</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">-</span> <span class="n">amount</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span>
</pre></div>

<p>A full implementation of <tt class="docutils literal">CheckingAccount</tt> appears below. We specify
inheritance by placing an expression that evaluates to the base class in
parentheses after the class name.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">CheckingAccount</span><span class="p">(</span><span class="n">Account</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""A bank account that charges for withdrawals."""</span>
<span class="gp">    </span>    <span class="n">withdraw_charge</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="n">interest</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Account</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">withdraw_charge</span><span class="p">)</span>
</pre></div>

<p>Here, we introduce a class attribute <tt class="docutils literal">withdraw_charge</tt> that is specific to the
<tt class="docutils literal">CheckingAccount</tt> class. We assign a lower value to the <tt class="docutils literal">interest</tt>
attribute.  We also define a new <tt class="docutils literal">withdraw</tt> method to override the behavior
defined in the <tt class="docutils literal">Account</tt> class. With no further statements in the class suite,
all other behavior is inherited from the base class <tt class="docutils literal">Account</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">checking</span> <span class="o">=</span> <span class="n">CheckingAccount</span><span class="p">(</span><span class="s1">'Sam'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checking</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checking</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checking</span><span class="o">.</span><span class="n">interest</span>
<span class="go">0.01</span>
</pre></div>

<p>The expression <tt class="docutils literal">checking.deposit</tt> evaluates to a bound method for making
deposits, which was defined in the <tt class="docutils literal">Account</tt> class. When Python
resolves a name in a dot expression that is not an attribute of the instance, it
looks up the name in the class.  In fact, the act of "looking up" a name in a
class tries to find that name in every base class in the inheritance chain for
the original object's class.  We can define this procedure recursively.  To look
up a name in a class.</p>
<ol class="arabic simple">
<li>If it names an attribute in the class, return the attribute value.</li>
<li>Otherwise, look up the name in the base class, if there is one.</li>
</ol>
<p>In the case of <tt class="docutils literal">deposit</tt>, Python would have looked for the name first on the
instance, and then in the <tt class="docutils literal">CheckingAccount</tt> class.  Finally, it would look in
the <tt class="docutils literal">Account</tt> class, where <tt class="docutils literal">deposit</tt> is defined. According to our evaluation
rule for dot expressions, since <tt class="docutils literal">deposit</tt> is a function looked up in the class
for the <tt class="docutils literal">checking</tt> instance, the dot expression evaluates to a bound method
value.  That method is invoked with the argument 10, which calls the deposit
method with <tt class="docutils literal">self</tt> bound to the <tt class="docutils literal">checking</tt> object and <tt class="docutils literal">amount</tt> bound to
10.</p>
<p>The class of an object stays constant throughout.  Even though the <tt class="docutils literal">deposit</tt>
method was found in the <tt class="docutils literal">Account</tt> class, <tt class="docutils literal">deposit</tt> is called with <tt class="docutils literal">self</tt>
bound to an instance of <tt class="docutils literal">CheckingAccount</tt>, not of <tt class="docutils literal">Account</tt>.</p>
<p><strong>Calling ancestors.</strong> Attributes that have been overridden are still
accessible via class objects.  For instance, we implemented
the <tt class="docutils literal">withdraw</tt> method of <tt class="docutils literal">CheckingAccount</tt> by calling the <tt class="docutils literal">withdraw</tt>
method of <tt class="docutils literal">Account</tt> with an argument that included the <tt class="docutils literal">withdraw_charge</tt>.</p>
<p>Notice that we called <tt class="docutils literal">self.withdraw_charge</tt> rather than the equivalent
<tt class="docutils literal">CheckingAccount.withdraw_charge</tt>.  The benefit of the former over the latter
is that a class that inherits from <tt class="docutils literal">CheckingAccount</tt> might override the
withdrawal charge.  If that is the case, we would like our implementation of
<tt class="docutils literal">withdraw</tt> to find that new value instead of the old one.</p>
<p><strong>Interfaces.</strong> It is extremely common in object-oriented programs that
different types of objects will share the same attribute names. An <em>object
interface</em> is a collection of attributes and conditions on those attributes.
For example, all accounts must have <tt class="docutils literal">deposit</tt> and <tt class="docutils literal">withdraw</tt> methods that
take numerical arguments, as well as a <tt class="docutils literal">balance</tt> attribute. The classes
<tt class="docutils literal">Account</tt> and <tt class="docutils literal">CheckingAccount</tt> both implement this interface. Inheritance
specifically promotes name sharing in this way. In some programming languages
such as Java, interface implementations must be explicitly declared.  In others
such as Python, Ruby, and Go, any object with the appropriate names implements
an interface.</p>
<p>The parts of your program that use objects (rather than implementing them) are
most robust to future changes if they do not make assumptions about object
types, but instead only about their attribute names. That is, they use the
object abstraction, rather than assuming anything about its implementation.</p>
<p>For example, let us say that we run a lottery, and we wish to deposit $5 into
each of a list of accounts.  The following implementation does not assume
anything about the types of those accounts, and therefore works equally well
with any type of object that has a <tt class="docutils literal">deposit</tt> method:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">deposit_all</span><span class="p">(</span><span class="n">winners</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">winners</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">account</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
</pre></div>

<p>The function <tt class="docutils literal">deposit_all</tt> above assumes only that each <tt class="docutils literal">account</tt> satisfies
the account object abstraction, and so it will work with any other account
classes that also implement this interface.  Assuming a particular class of
account would violate the abstraction barrier of the account object
abstraction. For example, the following implementation will not necessarily
work with new kinds of accounts:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">deposit_all</span><span class="p">(</span><span class="n">winners</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">winners</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">Account</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
</pre></div>

<p>We will address this topic in more detail later in the chapter.</p>
</div>
<div class="section" id="multiple-inheritance">
<h3>2.5.7   Multiple Inheritance</h3>
<p>Python supports the concept of a subclass inheriting attributes from multiple
base classes, a language feature called <em>multiple inheritance</em>.</p>
<p>Suppose that we have a <tt class="docutils literal">SavingsAccount</tt> that inherits from <tt class="docutils literal">Account</tt>, but
charges customers a small fee every time they make a deposit.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">SavingsAccount</span><span class="p">(</span><span class="n">Account</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">deposit_charge</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Account</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">deposit_charge</span><span class="p">)</span>
</pre></div>

<p>Then, a clever executive conceives of an <tt class="docutils literal">AsSeenOnTVAccount</tt> account with the
best features of both <tt class="docutils literal">CheckingAccount</tt> and <tt class="docutils literal">SavingsAccount</tt>: withdrawal
fees, deposit fees, and a low interest rate. It's both a checking and a savings
account in one! "If we build it," the executive reasons, "someone will sign up
and pay all those fees.  We'll even give them a dollar."</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">AsSeenOnTVAccount</span><span class="p">(</span><span class="n">CheckingAccount</span><span class="p">,</span> <span class="n">SavingsAccount</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">):</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">holder</span> <span class="o">=</span> <span class="n">account_holder</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="mi">1</span>           <span class="c1"># A free dollar!</span>
</pre></div>

<p>In fact, this implementation is complete.  Both withdrawal and deposits will
generate fees, using the function definitions in <tt class="docutils literal">CheckingAccount</tt> and
<tt class="docutils literal">SavingsAccount</tt> respectively.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">such_a_deal</span> <span class="o">=</span> <span class="n">AsSeenOnTVAccount</span><span class="p">(</span><span class="s2">"John"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">such_a_deal</span><span class="o">.</span><span class="n">balance</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">such_a_deal</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>            <span class="c1"># $2 fee from SavingsAccount.deposit</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">such_a_deal</span><span class="o">.</span><span class="n">withdraw</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>            <span class="c1"># $1 fee from CheckingAccount.withdraw</span>
<span class="go">13</span>
</pre></div>

<p>Non-ambiguous references are resolved correctly as expected:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">such_a_deal</span><span class="o">.</span><span class="n">deposit_charge</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">such_a_deal</span><span class="o">.</span><span class="n">withdraw_charge</span>
<span class="go">1</span>
</pre></div>

<p>But what about when the reference is ambiguous, such as the reference to the
<tt class="docutils literal">withdraw</tt> method that is defined in both <tt class="docutils literal">Account</tt> and <tt class="docutils literal">CheckingAccount</tt>?
The figure below depicts an <em>inheritance graph</em> for the <tt class="docutils literal">AsSeenOnTVAccount</tt>
class.  Each arrow points from a subclass to a base class.</p>
<div class="figure">
<img alt="" src="../img/multiple_inheritance.png">
</div>
<p>For a simple "diamond" shape like this, Python resolves names from left to
right, then upwards.  In this example, Python checks for an attribute name in
the following classes, in order, until an attribute with that name is found:</p>
<pre class="literal-block">
AsSeenOnTVAccount, CheckingAccount, SavingsAccount, Account, object
</pre>
<p>There is no correct solution to the inheritance ordering problem, as there are
cases in which we might prefer to give precedence to certain inherited classes
over others.  However, any programming language that supports multiple
inheritance must select some ordering in a consistent way, so that users of the
language can predict the behavior of their programs.</p>
<p><strong>Further reading.</strong> Python resolves this name using a recursive algorithm
called the C3 Method Resolution Ordering.  The method resolution order of any
class can be queried using the <tt class="docutils literal">mro</tt> method on all classes.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">AsSeenOnTVAccount</span><span class="o">.</span><span class="n">mro</span><span class="p">()]</span>
<span class="go">['AsSeenOnTVAccount', 'CheckingAccount', 'SavingsAccount', 'Account', 'object']</span>
</pre></div>

<p>The precise algorithm for finding method resolution orderings is not a topic for
this text, but is <a class="reference external" href="http://python-history.blogspot.com/2010/06/method-resolution-order.html">described by Python's primary author</a> with
a reference to the original paper.</p>
</div>
<div class="section" id="the-role-of-objects">
<h3>2.5.8   The Role of Objects</h3>
<p>The Python object system is designed to make data abstraction and message
passing both convenient and flexible.  The specialized syntax of classes,
methods, inheritance, and dot expressions all enable us to formalize the object
metaphor in our programs, which improves our ability to organize large programs.</p>
<p>In particular, we would like our object system to promote a <em>separation of
concerns</em> among the different aspects of the program.  Each object in a program
encapsulates and manages some part of the program's state, and each class
statement defines the functions that implement some part of the program's
overall logic.  Abstraction barriers enforce the boundaries between different
aspects of a large program.</p>
<p>Object-oriented programming is particularly well-suited to programs that model
systems that have separate but interacting parts.  For instance, different users
interact in a social network, different characters interact in a game, and
different shapes interact in a physical simulation. When representing such
systems, the objects in a program often map naturally onto objects in the system
being modeled, and classes represent their types and relationships.</p>
<p>On the other hand, classes may not provide the best mechanism for implementing
certain abstractions.  Functional abstractions provide a more natural metaphor
for representing relationships between inputs and outputs. One should not feel
compelled to fit every bit of logic in a program within a class, especially when
defining independent functions for manipulating data is more natural.  Functions
can also enforce a separation of concerns.</p>
<p>Multi-paradigm languages such as Python allow programmers to match
organizational paradigms to appropriate problems. Learning to identify when to
introduce a new class, as opposed to a new function, in order to simplify or
modularize a program, is an important design skill in software engineering that
deserves careful attention.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/26-implementing-classes-and-objects.html">
  		2.6 Implementing Classes and Objects
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="implementing-classes-and-objects">
<h2>2.6   Implementing Classes and Objects</h2>
<p>When working in the object-oriented programming paradigm, we use the object
metaphor to guide the organization of our programs.  Most logic about how to
represent and manipulate data is expressed within class declarations.  In this
section, we see that classes and objects can themselves be represented using
just functions and dictionaries.  The purpose of implementing an object system
in this way is to illustrate that using the object metaphor does not require a
special programming language.  Programs can be object-oriented, even in
programming languages that do not have a built-in object system.</p>
<p>In order to implement objects, we will abandon dot notation (which does require
built-in language support), but create dispatch dictionaries that behave
in much the same way as the elements of the built-in object system. We have
already seen how to implement message-passing behavior through dispatch
dictionaries.  To implement an object system in full, we send messages between
instances, classes, and base classes, all of which are dictionaries that contain
attributes.</p>
<p>We will not implement the entire Python object system, which includes features
that we have not covered in this text (e.g., meta-classes and static methods).
We will focus instead on user-defined classes without multiple inheritance and
without introspective behavior (such as returning the class of an instance).
Our implementation is not meant to follow the precise specification of the
Python type system.  Instead, it is designed to implement the core functionality
that enables the object metaphor.</p>
<div class="section" id="instances">
<h3>2.6.1   Instances</h3>
<p>We begin with instances.  An instance has named attributes, such as the balance
of an account, which can be set and retrieved. We implement an instance using a
dispatch dictionary that responds to messages that "get" and "set" attribute
values.  Attributes themselves are stored in a local dictionary called
<tt class="docutils literal">attributes</tt>.</p>
<p>As we have seen previously in this chapter, dictionaries themselves are abstract
data types.  We implemented dictionaries with lists, we implemented lists with
pairs, and we implemented pairs with functions. As we implement an object system
in terms of dictionaries, keep in mind that we could just as well be
implementing objects using functions alone.</p>
<p>To begin our implementation, we assume that we have a class implementation
that can look up any names that are not part of the instance.  We pass in a
class to <tt class="docutils literal">make_instance</tt> as the parameter <tt class="docutils literal">cls</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">make_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a new object instance, which is a dispatch dictionary."""</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
<span class="gp">    </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">value</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="n">name</span><span class="p">)</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">bind_method</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">attributes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">    </span>    <span class="n">attributes</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">    </span>    <span class="n">instance</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'get'</span><span class="p">:</span> <span class="n">get_value</span><span class="p">,</span> <span class="s1">'set'</span><span class="p">:</span> <span class="n">set_value</span><span class="p">}</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">instance</span>
</pre></div>

<p>The <tt class="docutils literal">instance</tt> is a dispatch dictionary that responds to the messages <tt class="docutils literal">get</tt>
and <tt class="docutils literal">set</tt>.  The <tt class="docutils literal">set</tt> message corresponds to attribute assignment in
Python's object system: all assigned attributes are stored directly within the
object's local attribute dictionary.  In <tt class="docutils literal">get</tt>, if <tt class="docutils literal">name</tt> does not appear in
the local <tt class="docutils literal">attributes</tt> dictionary, then it is looked up in the class. If the
<tt class="docutils literal">value</tt> returned by <tt class="docutils literal">cls</tt> is a function, it must be bound to the instance.</p>
<p><strong>Bound method values.</strong>  The <tt class="docutils literal">get_value</tt> function in <tt class="docutils literal">make_instance</tt> finds
a named attribute in its class with <tt class="docutils literal">get</tt>, then calls <tt class="docutils literal">bind_method</tt>.
Binding a method only applies to function values, and it creates a bound method
value from a function value by inserting the instance as the first argument:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bind_method</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a bound method if value is callable, or value otherwise."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">value</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">method</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">value</span>
</pre></div>

<p>When a method is called, the first parameter <tt class="docutils literal">self</tt> will be bound to the value
of <tt class="docutils literal">instance</tt> by this definition.</p>
</div>
<div class="section" id="classes">
<h3>2.6.2   Classes</h3>
<p>A class is also an object, both in Python's object system and the system we are
implementing here.  For simplicity, we say that classes do not themselves have a
class.  (In Python, classes do have classes; almost all classes share the same
class, called <tt class="docutils literal">type</tt>.) A class can respond to <tt class="docutils literal">get</tt> and <tt class="docutils literal">set</tt> messages, as
well as the <tt class="docutils literal">new</tt> message:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">make_class</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">base_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a new class, which is a dispatch dictionary."""</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">attributes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="n">base_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">base_class</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="n">name</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">attributes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">init_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">    </span>    <span class="bp">cls</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'get'</span><span class="p">:</span> <span class="n">get_value</span><span class="p">,</span> <span class="s1">'set'</span><span class="p">:</span> <span class="n">set_value</span><span class="p">,</span> <span class="s1">'new'</span><span class="p">:</span> <span class="n">new</span><span class="p">}</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="bp">cls</span>
</pre></div>

<p>Unlike an instance, the <tt class="docutils literal">get</tt> function for classes does not query its class
when an attribute is not found, but instead queries its <tt class="docutils literal">base_class</tt>.  No
method binding is required for classes.</p>
<p><strong>Initialization.</strong> The <tt class="docutils literal">new</tt> function in <tt class="docutils literal">make_class</tt> calls
<tt class="docutils literal">init_instance</tt>, which first makes a new instance, then invokes a method
called <tt class="docutils literal">__init__</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">init_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a new object with type cls, initialized with args."""</span>
<span class="gp">    </span>    <span class="n">instance</span> <span class="o">=</span> <span class="n">make_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">init</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'__init__'</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">init</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">init</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">instance</span>
</pre></div>

<p>This final function completes our object system.  We now have instances, which
<tt class="docutils literal">set</tt> locally but fall back to their classes on <tt class="docutils literal">get</tt>.  After an instance
looks up a name in its class, it binds itself to function values to create
methods.  Finally, classes can create <tt class="docutils literal">new</tt> instances, and they apply their
<tt class="docutils literal">__init__</tt> constructor function immediately after instance creation.</p>
<p>In this object system, the only function that should be called by the user is
<tt class="docutils literal">make_class</tt>.  All other functionality is enabled through message passing.
Similarly, Python's object system is invoked via the <tt class="docutils literal">class</tt> statement, and
all of its other functionality is enabled through dot expressions and calls to
classes.</p>
</div>
<div class="section" id="using-implemented-objects">
<h3>2.6.3   Using Implemented Objects</h3>
<p>We now return to use the bank account example from the previous section.  Using
our implemented object system, we will create an <tt class="docutils literal">Account</tt> class, a
<tt class="docutils literal">CheckingAccount</tt> subclass, and an instance of each.</p>
<p>The <tt class="docutils literal">Account</tt> class is created through a <tt class="docutils literal">make_account_class</tt> function,
which has structure similar to a <tt class="docutils literal">class</tt> statement in Python, but concludes
with a call to <tt class="docutils literal">make_class</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">make_account_class</span><span class="p">():</span>
<span class="gp">    </span>    <span class="sd">"""Return the Account class, which has deposit and withdraw methods."""</span>
<span class="gp">    </span>    <span class="n">interest</span> <span class="o">=</span> <span class="mf">0.02</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">):</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="p">[</span><span class="s1">'set'</span><span class="p">](</span><span class="s1">'holder'</span><span class="p">,</span> <span class="n">account_holder</span><span class="p">)</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="p">[</span><span class="s1">'set'</span><span class="p">](</span><span class="s1">'balance'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
<span class="gp">    </span>        <span class="sd">"""Increase the account balance by amount and return the new balance."""</span>
<span class="gp">    </span>        <span class="n">new_balance</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'balance'</span><span class="p">)</span> <span class="o">+</span> <span class="n">amount</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="p">[</span><span class="s1">'set'</span><span class="p">](</span><span class="s1">'balance'</span><span class="p">,</span> <span class="n">new_balance</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'balance'</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
<span class="gp">    </span>        <span class="sd">"""Decrease the account balance by amount and return the new balance."""</span>
<span class="gp">    </span>        <span class="n">balance</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'balance'</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="n">balance</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="s1">'Insufficient funds'</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="p">[</span><span class="s1">'set'</span><span class="p">](</span><span class="s1">'balance'</span><span class="p">,</span> <span class="n">balance</span> <span class="o">-</span> <span class="n">amount</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'balance'</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">make_class</span><span class="p">(</span><span class="nb">locals</span><span class="p">())</span>
</pre></div>

<p>The final call to <tt class="docutils literal">locals</tt> returns a dictionary with string keys that
contains the name-value bindings in the current local frame.</p>
<p>The <tt class="docutils literal">Account</tt> class is finally instantiated via assignment.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Account</span> <span class="o">=</span> <span class="n">make_account_class</span><span class="p">()</span>
</pre></div>

<p>Then, an account instance is created via the <tt class="docutils literal">new</tt> message, which requires a
name to go with the newly created account.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kirk_account</span> <span class="o">=</span> <span class="n">Account</span><span class="p">[</span><span class="s1">'new'</span><span class="p">](</span><span class="s1">'Kirk'</span><span class="p">)</span>
</pre></div>

<p>Then, <tt class="docutils literal">get</tt> messages passed to <tt class="docutils literal">kirk_account</tt> retrieve properties and methods.
Methods can be called to update the balance of the account.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kirk_account</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'holder'</span><span class="p">)</span>
<span class="go">'Kirk'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kirk_account</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'interest'</span><span class="p">)</span>
<span class="go">0.02</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kirk_account</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'deposit'</span><span class="p">)(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kirk_account</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'withdraw'</span><span class="p">)(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>

<p>As with the Python object system, setting an attribute of an instance does not
change the corresponding attribute of its class.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kirk_account</span><span class="p">[</span><span class="s1">'set'</span><span class="p">](</span><span class="s1">'interest'</span><span class="p">,</span> <span class="mf">0.04</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Account</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'interest'</span><span class="p">)</span>
<span class="go">0.02</span>
</pre></div>

<p><strong>Inheritance.</strong> We can create a subclass <tt class="docutils literal">CheckingAccount</tt> by overloading a
subset of the class attributes.  In this case, we change the <tt class="docutils literal">withdraw</tt> method
to impose a fee, and we reduce the interest rate.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">make_checking_account_class</span><span class="p">():</span>
<span class="gp">    </span>    <span class="sd">"""Return the CheckingAccount class, which imposes a $1 withdrawal fee."""</span>
<span class="gp">    </span>    <span class="n">interest</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="gp">    </span>    <span class="n">withdraw_fee</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">fee</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'withdraw_fee'</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Account</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'withdraw'</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span> <span class="o">+</span> <span class="n">fee</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">make_class</span><span class="p">(</span><span class="nb">locals</span><span class="p">(),</span> <span class="n">Account</span><span class="p">)</span>
</pre></div>

<p>In this implementation, we call the <tt class="docutils literal">withdraw</tt> function of the base class
<tt class="docutils literal">Account</tt> from the <tt class="docutils literal">withdraw</tt> function of the subclass, as we would in
Python's built-in object system.  We can create the subclass itself and an
instance, as before.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CheckingAccount</span> <span class="o">=</span> <span class="n">make_checking_account_class</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jack_acct</span> <span class="o">=</span> <span class="n">CheckingAccount</span><span class="p">[</span><span class="s1">'new'</span><span class="p">](</span><span class="s1">'Spock'</span><span class="p">)</span>
</pre></div>

<p>Deposits behave identically, as does the constructor function.  withdrawals
impose the $1 fee from the specialized <tt class="docutils literal">withdraw</tt> method, and <tt class="docutils literal">interest</tt> has
the new lower value from <tt class="docutils literal">CheckingAccount</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jack_acct</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'interest'</span><span class="p">)</span>
<span class="go">0.01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jack_acct</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'deposit'</span><span class="p">)(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jack_acct</span><span class="p">[</span><span class="s1">'get'</span><span class="p">](</span><span class="s1">'withdraw'</span><span class="p">)(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">14</span>
</pre></div>

<p>Our object system built upon dictionaries is quite similar in implementation
to the built-in object system in Python.  In Python, an instance of any
user-defined class has a special attribute <tt class="docutils literal">__dict__</tt> that stores the local
instance attributes for that object in a dictionary, much like our
<tt class="docutils literal">attributes</tt> dictionary.  Python differs because it distinguishes certain
special methods that interact with built-in functions to ensure that those
functions behave correctly for arguments of many different types.  Functions
that operate on different types are the subject of the next section.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/27-object-abstraction.html">
  		2.7 Object Abstraction
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="object-abstraction">
<h2>2.7   Object Abstraction</h2>
<p>The object system allows programmers to build and use abstract data
representations efficiently. It is also designed to allow multiple
representations of abstract data to coexist in the same program.</p>
<p>A central concept in object abstraction is a <em>generic function</em>, which is a
function that can accept values of multiple different types. We will consider
three different techniques for implementing generic functions: shared
interfaces, type dispatching, and type coercion. In the process of building up
these concepts, we will also discover features of the Python object system that
support the creation of generic functions.</p>
<div class="section" id="string-conversion">
<h3>2.7.1   String Conversion</h3>
<p>To represent data effectively, an object value should behave like the kind of
data it is meant to represent, including producing a string representation of
itself.  String representations of data values are especially important in an
interactive language such as Python that automatically displays the string
representation of the values of expressions in an interactive session.</p>
<p>String values provide a fundamental medium for communicating information among
humans. Sequences of characters can be rendered on a screen, printed to paper,
read aloud, converted to braille, or broadcast as Morse code.  Strings are also
fundamental to programming because they can represent Python expressions.</p>
<p>Python stipulates that all objects should produce two different string
representations: one that is human-interpretable text and one that is a
Python-interpretable expression.  The constructor function for strings,
<tt class="docutils literal">str</tt>, returns a human-readable string. Where possible, the <tt class="docutils literal">repr</tt> function
returns a Python expression that evaluates to an equal object. The docstring
for <em>repr</em> explains this property:</p>
<pre class="literal-block">
repr(object) -&gt; string

Return the canonical string representation of the object.
For most object types, eval(repr(object)) == object.
</pre>
<p>The result of calling <tt class="docutils literal">repr</tt> on the value of an expression is what Python
prints in an interactive session.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">12e12</span>
<span class="go">12000000000000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="mf">12e12</span><span class="p">))</span>
<span class="go">12000000000000.0</span>
</pre></div>

<p>In cases where no representation exists that evaluates to the original value,
Python typically produces a description surrounded by angled brackets.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span>
<span class="go">'&lt;built-in function min&gt;'</span>
</pre></div>

<p>The <tt class="docutils literal">str</tt> constructor often coincides with <tt class="docutils literal">repr</tt>, but provides a more
interpretable text representation in some cases.  For instance, we see a
difference between <tt class="docutils literal">str</tt> and <tt class="docutils literal">repr</tt> with dates.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">date</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tues</span> <span class="o">=</span> <span class="n">date</span><span class="p">(</span><span class="mi">2011</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">tues</span><span class="p">)</span>
<span class="go">'datetime.date(2011, 9, 12)'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">tues</span><span class="p">)</span>
<span class="go">'2011-09-12'</span>
</pre></div>

<p>Defining the <tt class="docutils literal">repr</tt> function presents a new challenge: we would like it to
apply correctly to all data types, even those that did not exist when <tt class="docutils literal">repr</tt>
was implemented.  We would like it to be a generic or <em>polymorphic function</em>,
one that can be applied to many (<em>poly</em>) different forms (<em>morph</em>) of data.</p>
<p>The object system provides an elegant solution in this case: the <tt class="docutils literal">repr</tt>
function always invokes a method called <tt class="docutils literal">__repr__</tt> on its argument.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tues</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
<span class="go">'datetime.date(2011, 9, 12)'</span>
</pre></div>

<p>By implementing this same method in user-defined classes, we can extend the
applicability of <tt class="docutils literal">repr</tt> to any class we create in the future.  This example
highlights another benefit of dot expressions in general, that they provide a
mechanism for extending the domain of existing functions to new object types.</p>
<p>The <tt class="docutils literal">str</tt> constructor is implemented in a similar manner: it invokes a method
called <tt class="docutils literal">__str__</tt> on its argument.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tues</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
<span class="go">'2011-09-12'</span>
</pre></div>

<p>These polymorphic functions are examples of a more general principle: certain
functions should apply to multiple data types. Moreover, one way to create
such a function is to use a shared attribute name with a different definition
in each class.</p>
</div>
<div class="section" id="special-methods">
<h3>2.7.2   Special Methods</h3>
<p>In Python, certain <em>special names</em> are invoked by the Python interpreter in
special circumstances. For instance, the <tt class="docutils literal">__init__</tt> method of a class is
automatically invoked whenever an object is constructed. The <tt class="docutils literal">__str__</tt> method
is invoked automatically when printing, and <tt class="docutils literal">__repr__</tt> is invoked in an
interactive session to display values.</p>
<p>There are special names for many other behaviors in Python. Some of those used
most commonly are described below.</p>
<p><strong>True and false values.</strong> We saw previously that numbers in Python have a
truth value; more specifically, 0 is a false value and all other numbers are
true values. In fact, all objects in Python have a truth value. By default,
objects of user-defined classes are considered to be true, but the special
<tt class="docutils literal">__bool__</tt> method can be used to override this behavior. If an object defines
the <tt class="docutils literal">__bool__</tt> method, then Python calls that method to determine its truth
value.</p>
<p>As an example, suppose we want a bank account with 0 balance to be false. We
can add a <tt class="docutils literal">__bool__</tt> method to the <tt class="docutils literal">Account</tt> class to create this behavior.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Account</span><span class="o">.</span><span class="fm">__bool__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">!=</span> <span class="mi">0</span>
</pre></div>

<p>We can call the <tt class="docutils literal">bool</tt> constructor to see the truth value of an object, and
we can use any object in a boolean context.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">Account</span><span class="p">(</span><span class="s1">'Jack'</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="ow">not</span> <span class="n">Account</span><span class="p">(</span><span class="s1">'Jack'</span><span class="p">):</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'Jack has nothing'</span><span class="p">)</span>
<span class="go">Jack has nothing</span>
</pre></div>

<p><strong>Sequence operations.</strong> We have seen that we can call the <tt class="docutils literal">len</tt> function to
determine the length of a sequence.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="s1">'Go Bears!'</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>

<p>The <tt class="docutils literal">len</tt> function invokes the <tt class="docutils literal">__len__</tt> method of its argument to determine
its length. All built-in sequence types implement this method.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'Go Bears!'</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>
<span class="go">9</span>
</pre></div>

<p>Python uses a sequence's length to determine its truth value, if it does not
provide a <tt class="docutils literal">__bool__</tt> method. Empty sequences are false, while non-empty
sequences are true.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">([])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="s1">'Go Bears!'</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>

<p>The <tt class="docutils literal">__getitem__</tt> method is invoked by the element selection operator, but it
can also be invoked directly.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">'Go Bears!'</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">'B'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'Go Bears!'</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">'B'</span>
</pre></div>

<p><strong>Callable objects.</strong> In Python, functions are first-class objects, so they can
be passed around as data and have attributes like any other object. Python also
allows us to define objects that can be "called" like functions by including a
<tt class="docutils literal">__call__</tt> method. With this method, we can define a class that behaves like
a higher-order function.</p>
<p>As an example, consider the following higher-order function, which returns a
function that adds a constant value to its argument.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">make_adder</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">adder</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">k</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">adder</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add_three</span> <span class="o">=</span> <span class="n">make_adder</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_three</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>

<p>We can create an <tt class="docutils literal">Adder</tt> class that defines a <tt class="docutils literal">__call__</tt> method to provide
the same functionality.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Adder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add_three_obj</span> <span class="o">=</span> <span class="n">Adder</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_three_obj</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>

<p>Here, the <tt class="docutils literal">Adder</tt> class behaves like the <tt class="docutils literal">make_adder</tt> higher-order
function, and the <tt class="docutils literal">add_three_obj</tt> object behaves like the <tt class="docutils literal">add_three</tt>
function. We have further blurred the line between data and functions.</p>
<p><strong>Arithmetic.</strong> Special methods can also define the behavior of built-in
operators applied to user-defined objects. In order to provide this generality,
Python follows specific protocols to apply each operator. For example, to
evaluate expressions that contain the <tt class="docutils literal">+</tt> operator, Python checks for special
methods on both the left and right operands of the expression. First, Python
checks for an <tt class="docutils literal">__add__</tt> method on the value of the left operand, then checks
for an <tt class="docutils literal">__radd__</tt> method on the value of the right operand. If either is
found, that method is invoked with the value of the other operand as its
argument. Some examples are given in the following sections. For readers
interested in further details, the Python documentation describes the
exhaustive set of <a class="reference external" href="http://docs.python.org/py3k/reference/datamodel.html#special-method-names">method names for operators</a>.
Dive into Python 3 has a chapter on <a class="reference external" href="http://getpython3.com/diveintopython3/special-method-names.html">special method names</a> that
describes how many of these special method names are used.</p>
</div>
<div class="section" id="multiple-representations">
<h3>2.7.3   Multiple Representations</h3>
<p>Abstraction barriers allow us to separate the use and representation of data.
However, in large programs, it may not always make sense to speak of "the
underlying representation" for a data type in a program. For one thing, there
might be more than one useful representation for a data object, and we might
like to design systems that can deal with multiple representations.</p>
<p>To take a simple example, complex numbers may be represented in two almost
equivalent ways: in rectangular form (real and imaginary parts) and in polar
form (magnitude and angle). Sometimes the rectangular form is more appropriate
and sometimes the polar form is more appropriate. Indeed, it is perfectly
plausible to imagine a system in which complex numbers are represented in both
ways, and in which the functions for manipulating complex numbers work with
either representation. We implement such a system below. As a side note, we are
developing a system that performs arithmetic operations on complex numbers as a
simple but unrealistic example of a program that uses generic operations.  A
<a class="reference external" href="http://docs.python.org/py3k/library/stdtypes.html#typesnumeric">complex number type</a> is actually
built into Python, but for this example we will implement our own.</p>
<p>The idea of allowing for multiple representations of data arises regularly.
Large software systems are often designed by many people working over extended
periods of time, subject to requirements that change over time. In such an
environment, it is simply not possible for everyone to agree in advance on
choices of data representation. In addition to the data-abstraction barriers
that isolate representation from use, we need abstraction barriers that isolate
different design choices from each other and permit different choices to
coexist in a single program.</p>
<p>We will begin our implementation at the highest level of abstraction and work
towards concrete representations. A <tt class="docutils literal">Complex</tt> number is a <tt class="docutils literal">Number</tt>, and
numbers can be added or multiplied together. How numbers can be added or
multiplied is abstracted by the method names <tt class="docutils literal">add</tt> and <tt class="docutils literal">mul</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</pre></div>

<p>This class requires that Number objects have <tt class="docutils literal">add</tt> and <tt class="docutils literal">mul</tt> methods, but
does not define them. Moreover, it does not have an <tt class="docutils literal">__init__</tt> method. The
purpose of <tt class="docutils literal">Number</tt> is not to be instantiated directly, but instead to serve
as a superclass of various specific number classes. Our next task is to define
<tt class="docutils literal">add</tt> and <tt class="docutils literal">mul</tt> appropriately for complex numbers.</p>
<p>A complex number can be thought of as a point in two-dimensional space with
two orthogonal axes, the real axis and the imaginary axis.  From this
perspective, the complex number <tt class="docutils literal">c = real + imag * i</tt> (where <tt class="docutils literal">i * i = <span class="pre">-1</span></tt>)
can be thought of as the point in the plane whose horizontal coordinate is
<tt class="docutils literal">real</tt> and whose vertical coordinate is <tt class="docutils literal">imag</tt>.  Adding complex numbers
involves adding their respective <tt class="docutils literal">real</tt> and <tt class="docutils literal">imag</tt> coordinates.</p>
<p>When multiplying complex numbers, it is more natural to think in terms of
representing a complex number in polar form, as a <tt class="docutils literal">magnitude</tt> and an
<tt class="docutils literal">angle</tt>.  The product of two complex numbers is the vector obtained by
stretching one complex number by a factor of the length of the other, and then
rotating it through the angle of the other.</p>
<p>The <tt class="docutils literal">Complex</tt> class inherits from <tt class="docutils literal">Number</tt> and describes arithmetic for
complex numbers.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Complex</span><span class="p">(</span><span class="n">Number</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">magnitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">magnitude</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">ComplexMA</span><span class="p">(</span><span class="n">magnitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
</pre></div>

<p>This implementation assumes that two classes exist for complex numbers,
corresponding to their two natural representations:</p>
<ul class="simple">
<li>
<tt class="docutils literal">ComplexRI</tt> constructs a complex number from real and imaginary parts.</li>
<li>
<tt class="docutils literal">ComplexMA</tt> constructs a complex number from a magnitude and angle.</li>
</ul>
<p><strong>Interfaces.</strong> Object attributes, which are a form of message passing, allows
different data types to respond to the same message in different ways.  A
shared set of messages that elicit similar behavior from different classes is a
powerful method of abstraction. An <em>interface</em> is a set of shared attribute
names, along with a specification of their behavior.   In the case of complex
numbers, the interface needed to implement arithmetic consists of four
attributes: <tt class="docutils literal">real</tt>, <tt class="docutils literal">imag</tt>, <tt class="docutils literal">magnitude</tt>, and <tt class="docutils literal">angle</tt>.</p>
<p>For complex arithmetic to be correct, these attributes must be consistent. That
is, the rectangular coordinates <tt class="docutils literal">(real, imag)</tt> and the polar coordinates
<tt class="docutils literal">(magnitude, angle)</tt> must describe the same point on the complex plane.
The <tt class="docutils literal">Complex</tt> class implicitly defines this interface by determining how
these attributes are used to <tt class="docutils literal">add</tt> and <tt class="docutils literal">mul</tt> complex numbers.</p>
<p><strong>Properties.</strong> The requirement that two or more attribute values maintain a
fixed relationship with each other is a new problem. One solution is to store
attribute values for only one representation and compute the other
representation whenever it is needed.</p>
<p>Python has a simple feature for computing attributes on the fly from
zero-argument functions.  The <tt class="docutils literal">@property</tt> decorator allows functions to be
called without call expression syntax (parentheses following an expression).
The <tt class="docutils literal">ComplexRI</tt> class stores <tt class="docutils literal">real</tt> and <tt class="docutils literal">imag</tt> attributes and computes
<tt class="docutils literal">magnitude</tt> and <tt class="docutils literal">angle</tt> on demand.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">atan2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ComplexRI</span><span class="p">(</span><span class="n">Complex</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">):</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">real</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">imag</span>
<span class="gp">    </span>    <span class="nd">@property</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
<span class="gp">    </span>    <span class="nd">@property</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">atan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="s1">'ComplexRI(</span><span class="si">{0:g}</span><span class="s1">, </span><span class="si">{1:g}</span><span class="s1">)'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
</pre></div>

<p>As a result of this implementation, all four attributes needed for complex
arithmetic can be accessed without any call expressions, and changes to
<tt class="docutils literal">real</tt> or <tt class="docutils literal">imag</tt> are reflected in the <tt class="docutils literal">magnitude</tt> and <tt class="docutils literal">angle</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ri</span> <span class="o">=</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ri</span><span class="o">.</span><span class="n">real</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ri</span><span class="o">.</span><span class="n">magnitude</span>
<span class="go">13.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ri</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ri</span><span class="o">.</span><span class="n">real</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ri</span><span class="o">.</span><span class="n">magnitude</span>
<span class="go">15.0</span>
</pre></div>

<p>Similarly, the <tt class="docutils literal">ComplexMA</tt> class stores <tt class="docutils literal">magnitude</tt> and <tt class="docutils literal">angle</tt>, but
computes <tt class="docutils literal">real</tt> and <tt class="docutils literal">imag</tt> whenever those attributes are looked up.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ComplexMA</span><span class="p">(</span><span class="n">Complex</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="n">magnitude</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span>
<span class="gp">    </span>    <span class="nd">@property</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
<span class="gp">    </span>    <span class="nd">@property</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="s1">'ComplexMA(</span><span class="si">{0:g}</span><span class="s1">, </span><span class="si">{1:g}</span><span class="s1"> * pi)'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="o">/</span><span class="n">pi</span><span class="p">)</span>
</pre></div>

<p>Changes to the magnitude or angle are reflected immediately in the <tt class="docutils literal">real</tt> and
<tt class="docutils literal">imag</tt> attributes.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span> <span class="o">=</span> <span class="n">ComplexMA</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">imag</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">real</span>
<span class="go">-2.0</span>
</pre></div>

<p>Our implementation of complex numbers is now complete. Either class
implementing complex numbers can be used for either argument in either
arithmetic function in <tt class="docutils literal">Complex</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ComplexRI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">ComplexMA</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">ComplexRI(1, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ComplexRI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">ComplexMA(1, 1 * pi)</span>
</pre></div>

<p>The interface approach to encoding multiple representations has appealing
properties.  The class for each representation can be developed separately;
they must only agree on the names of the attributes they share, as well as any
behavior conditions for those attributes.  The interface is also <em>additive</em>.
If another programmer wanted to add a third representation of complex numbers
to the same program, they would only have to create another class with the same
attributes.</p>
<p>Multiple representations of data are closely related to the idea of data
abstraction with which we began this chapter. Using data abstraction, we were
able to change the implementation of a data type without changing the meaning
of the program. With interfaces and message passing, we can have multiple
different representations within the same program. In both cases, a set of
names and corresponding behavior conditions define the abstraction that enables
this flexibility.</p>
</div>
<div class="section" id="generic-functions">
<h3>2.7.4   Generic Functions</h3>
<p>Generic functions are methods or functions that apply to arguments of different
types. We have seen many examples already. The <tt class="docutils literal">Complex.add</tt> method is
generic, because it can take either a <tt class="docutils literal">ComplexRI</tt> or <tt class="docutils literal">ComplexMA</tt> as the
value for <tt class="docutils literal">other</tt>. This flexibility was gained by ensuring that both
<tt class="docutils literal">ComplexRI</tt> and <tt class="docutils literal">ComplexMA</tt> share an interface. Using interfaces and
message passing is only one of several methods used to implement generic
functions. We will consider two others in this section: type dispatching and
type coercion.</p>
<p>Suppose that, in addition to our complex number classes, we implement a
<tt class="docutils literal">Rational</tt> class to represent fractions exactly. The <tt class="docutils literal">add</tt> and <tt class="docutils literal">mul</tt>
methods express the same computations as the <tt class="docutils literal">add_rational</tt> and
<tt class="docutils literal">mul_rational</tt> functions from earlier in the chapter.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">gcd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Rational</span><span class="p">(</span><span class="n">Number</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">g</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">numer</span> <span class="o">=</span> <span class="n">numer</span> <span class="o">//</span> <span class="n">g</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">denom</span> <span class="o">=</span> <span class="n">denom</span> <span class="o">//</span> <span class="n">g</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="s1">'Rational(</span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">)'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">denom</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">nx</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">denom</span>
<span class="gp">    </span>        <span class="n">ny</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">numer</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">denom</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Rational</span><span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">+</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">numer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">numer</span>
<span class="gp">    </span>        <span class="n">denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">denom</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">denom</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Rational</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>
</pre></div>

<p>We have implemented the interface of the <tt class="docutils literal">Number</tt> superclass by including
<tt class="docutils literal">add</tt> and <tt class="docutils literal">mul</tt> methods. As a result, we can add and multiply rational
numbers using familiar operators.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Rational</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">Rational(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Rational(1, 6)</span>
</pre></div>

<p>However, we cannot yet add a rational number to a complex number, although in
mathematics such a combination is well-defined. We would like to introduce this
cross-type operation in some carefully controlled way, so that we can support
it without seriously violating our abstraction barriers.  There is a tension
between the outcomes we desire: we would like to be able to add a complex
number to a rational number, and we would like to do so using a generic
<tt class="docutils literal">__add__</tt> method that does the right thing with all numeric types.  At the
same time, we would like to separate the concerns of complex numbers and
rational numbers whenever possible, in order to maintain a modular program.</p>
<p><strong>Type dispatching.</strong> One way to implement cross-type operations is to select
behavior based on the types of the arguments to a function or method.
The idea of type dispatching is to write functions that inspect the type
of arguments they receive, then execute code that is appropriate for
those types.</p>
<p>The built-in function <tt class="docutils literal">isinstance</tt> takes an object and a class. It returns
true if the object has a class that either is or inherits from the given class.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ComplexRI</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Complex</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ComplexMA</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>

<p>A simple example of type dispatching is an <tt class="docutils literal">is_real</tt> function that uses
a different implementation for each type of complex number.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">is_real</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return whether c is a real number with no imaginary part."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ComplexRI</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">imag</span> <span class="o">==</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ComplexMA</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">angle</span> <span class="o">%</span> <span class="n">pi</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">is_real</span><span class="p">(</span><span class="n">ComplexRI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_real</span><span class="p">(</span><span class="n">ComplexMA</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>

<p>Type dispatching is not always performed using <tt class="docutils literal">isinstance</tt>. For arithmetic,
we will give a <tt class="docutils literal">type_tag</tt> attribute to <tt class="docutils literal">Rational</tt> and <tt class="docutils literal">Complex</tt> instances
that has a string value. When two values <tt class="docutils literal">x</tt> and <tt class="docutils literal">y</tt> have the same
<tt class="docutils literal">type_tag</tt>, then we can combine them directly with <tt class="docutils literal">x.add(y)</tt>. If not, we
need a cross-type operation.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Rational</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">=</span> <span class="s1">'rat'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Complex</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">=</span> <span class="s1">'com'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rational</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">==</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">type_tag</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ComplexRI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">==</span> <span class="n">ComplexMA</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">type_tag</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rational</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">==</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">type_tag</span>
<span class="go">False</span>
</pre></div>

<p>To combine complex and rational numbers, we write functions that rely on both
of their representations simultaneously. Below, we rely on the fact that a
<tt class="docutils literal">Rational</tt> can be converted approximately to a <tt class="docutils literal">float</tt> value that is a real
number. The result can be combined with a complex number.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add_complex_and_rational</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">numer</span><span class="o">/</span><span class="n">r</span><span class="o">.</span><span class="n">denom</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
</pre></div>

<p>Multiplication involves a similar conversion. In polar form, a real number in
the complex plane always has a positive magnitude. The angle 0 indicates a
positive number. The angle <tt class="docutils literal">pi</tt> indicates a negative number.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mul_complex_and_rational</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">r_magnitude</span><span class="p">,</span> <span class="n">r_angle</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">numer</span><span class="o">/</span><span class="n">r</span><span class="o">.</span><span class="n">denom</span><span class="p">,</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">r_magnitude</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">r_magnitude</span><span class="p">,</span> <span class="n">r_angle</span> <span class="o">=</span> <span class="o">-</span><span class="n">r_magnitude</span><span class="p">,</span> <span class="n">pi</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">ComplexMA</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">*</span> <span class="n">r_magnitude</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">r_angle</span><span class="p">)</span>
</pre></div>

<p>Both addition and multiplication are commutative, so swapping the argument
order can use the same implementations of these cross-type operations.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add_rational_and_complex</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">add_complex_and_rational</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mul_rational_and_complex</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">mul_complex_and_rational</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>

<p>The role of type dispatching is to ensure that these cross-type operations are
used at appropriate times. Below, we rewrite the <tt class="docutils literal">Number</tt> superclass to use
type dispatching for its <tt class="docutils literal">__add__</tt> and <tt class="docutils literal">__mul__</tt> methods.</p>
<p>We use the <tt class="docutils literal">type_tag</tt> attribute to distinguish types of arguments. One could
directly use the built-in <tt class="docutils literal">isinstance</tt> method as well, but tags simplify the
implementation. Using type tags also illustrates that type dispatching is not
necessarily linked to the Python object system, but instead a general technique
for creating generic functions over heterogeneous domains.</p>
<p>The <tt class="docutils literal">__add__</tt> method considers two cases. First, if two arguments have the
same type tag, then it assumes that <tt class="docutils literal">add</tt> method of the first can take
the second as an argument. Otherwise, it checks whether a dictionary of
cross-type implementations, called <tt class="docutils literal">adders</tt>, contains a function that
can add arguments of those type tags. If there is such a function, the
<tt class="docutils literal">cross_apply</tt> method finds and applies it.  The <tt class="docutils literal">__mul__</tt> method has a
similar structure.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adders</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_apply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">adders</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_apply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">cross_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">cross_fns</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">cross_fn</span> <span class="o">=</span> <span class="n">cross_fns</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">)]</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">cross_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">adders</span> <span class="o">=</span> <span class="p">{(</span><span class="s2">"com"</span><span class="p">,</span> <span class="s2">"rat"</span><span class="p">):</span> <span class="n">add_complex_and_rational</span><span class="p">,</span>
<span class="gp">    </span>              <span class="p">(</span><span class="s2">"rat"</span><span class="p">,</span> <span class="s2">"com"</span><span class="p">):</span> <span class="n">add_rational_and_complex</span><span class="p">}</span>
<span class="gp">    </span>    <span class="n">multipliers</span> <span class="o">=</span> <span class="p">{(</span><span class="s2">"com"</span><span class="p">,</span> <span class="s2">"rat"</span><span class="p">):</span> <span class="n">mul_complex_and_rational</span><span class="p">,</span>
<span class="gp">    </span>                   <span class="p">(</span><span class="s2">"rat"</span><span class="p">,</span> <span class="s2">"com"</span><span class="p">):</span> <span class="n">mul_rational_and_complex</span><span class="p">}</span>
</pre></div>

<p>In this new definition of the <tt class="docutils literal">Number</tt> class, all cross-type implementations
are indexed by pairs of type tags in the <tt class="docutils literal">adders</tt> and <tt class="docutils literal">multipliers</tt>
dictionaries.</p>
<p>This dictionary-based approach to type dispatching is extensible. New
subclasses of <tt class="docutils literal">Number</tt> could install themselves into the system by declaring
a type tag and adding cross-type operations to <tt class="docutils literal">Number.adders</tt> and
<tt class="docutils literal">Number.multipliers</tt>. They could also define their own <tt class="docutils literal">adders</tt> and
<tt class="docutils literal">multipliers</tt> in a subclass.</p>
<p>While we have introduced some complexity to the system, we can now mix types
in addition and multiplication expressions.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ComplexRI</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">ComplexRI(3, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rational</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ComplexMA</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">ComplexMA(2, 1.5 * pi)</span>
</pre></div>

<p><strong>Coercion.</strong> In the general situation of completely unrelated operations acting
on completely unrelated types, implementing explicit cross-type operations,
cumbersome though it may be, is the best that one can hope for. Fortunately, we
can sometimes do better by taking advantage of additional structure that may be
latent in our type system. Often the different data types are not completely
independent, and there may be ways by which objects of one type may be viewed
as being of another type. This process is called <em>coercion</em>. For example, if we
are asked to arithmetically combine a rational number with a complex number, we
can view the rational number as a complex number whose imaginary part is
zero. After doing so, we can use <tt class="docutils literal">Complex.add</tt> and <tt class="docutils literal">Complex.mul</tt> to combine
them.</p>
<p>In general, we can implement this idea by designing coercion functions that
transform an object of one type into an equivalent object of another type. Here
is a typical coercion function, which transforms a rational number to a complex
number with zero imaginary part:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rational_to_complex</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">ComplexRI</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">numer</span><span class="o">/</span><span class="n">r</span><span class="o">.</span><span class="n">denom</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>

<p>The alternative definition of the <tt class="docutils literal">Number</tt> class performs cross-type
operations by attempting to coerce both arguments to the same type.
The <tt class="docutils literal">coercions</tt> dictionary indexes all possible coercions by a pair of type
tags, indicating that the corresponding value coerces a value of the first type
to a value of the second type.</p>
<p>It is not generally possible to coerce an arbitrary data object of each type
into all other types. For example, there is no way to coerce an arbitrary
complex number to a rational number, so there will be no such conversion
implementation in the <tt class="docutils literal">coercions</tt> dictionary.</p>
<p>The <tt class="docutils literal">coerce</tt> method returns two values with the same type tag. It inspects
the type tags of its arguments, compares them to entries in the <tt class="docutils literal">coercions</tt>
dictionary, and converts one argument to the type of the other using
<tt class="docutils literal">coerce_to</tt>. Only one entry in <tt class="docutils literal">coercions</tt> is necessary to complete our
cross-type arithmetic system, replacing the four cross-type functions in the
type-dispatching version of <tt class="docutils literal">Number</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">coerce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coercions</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coerce_to</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">),</span> <span class="n">other</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">type_tag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coercions</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">coerce_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">))</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">coerce_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_tag</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">coercion_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coercions</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_tag</span><span class="p">,</span> <span class="n">other_tag</span><span class="p">)]</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">coercion_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">coercions</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">'rat'</span><span class="p">,</span> <span class="s1">'com'</span><span class="p">):</span> <span class="n">rational_to_complex</span><span class="p">}</span>
</pre></div>

<p>This coercion scheme has some advantages over the method of defining explicit
cross-type operations. Although we still need to write coercion functions to
relate the types, we need to write only one function for each pair of types
rather than a different function for each set of types and each generic
operation. What we are counting on here is the fact that the appropriate
transformation between types depends only on the types themselves, not on the
particular operation to be applied.</p>
<p>Further advantages come from extending coercion.  Some more sophisticated
coercion schemes do not just try to coerce one type into another, but instead
may try to coerce two different types each into a third common type.  Consider
a rhombus and a rectangle: neither is a special case of the other, but both can
be viewed as quadrilaterals. Another extension to coercion is iterative
coercion, in which one data type is coerced into another via intermediate
types.  Consider that an integer can be converted into a real number by first
converting it into a rational number, then converting that rational number into
a real number. Chaining coercion in this way can reduce the total number of
coercion functions that are required by a program.</p>
<p>Despite its advantages, coercion does have potential drawbacks.  For one,
coercion functions can lose information when they are applied.  In our example,
rational numbers are exact representations, but become approximations when they
are converted to complex numbers.</p>
<p>Some programming languages have automatic coercion systems built in.  In fact,
early versions of Python had a <tt class="docutils literal">__coerce__</tt> special method on objects.  In
the end, the complexity of the built-in coercion system did not justify its
use, and so it was removed.  Instead, particular operators apply coercion to
their arguments as needed.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/28-efficiency.html">
  		2.8 Efficiency
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="efficiency">
<h2>2.8   Efficiency</h2>
<p>Decisions of how to represent and process data are often influenced by the
efficiency of alternatives. Efficiency refers to the computational resources
used by a representation or process, such as how much time and memory are
required to compute the result of a function or represent an object. These
amounts can vary widely depending on the details of an implementation.</p>
<div class="section" id="measuring-efficiency">
<h3>2.8.1   Measuring Efficiency</h3>
<p>Measuring exactly how long a program requires to run or how much memory it
consumes is challenging, because the results depend upon many details of how a
computer is configured. A more reliable way to characterize the efficiency of a
program is to measure how many times some event occurs, such as a function
call.</p>
<p>Let's return to our first tree-recursive function, the <tt class="docutils literal">fib</tt> function for
computing numbers in the Fibonacci sequence.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>

<p>Consider the pattern of computation that results from evaluating <tt class="docutils literal">fib(6)</tt>,
depicted below.  To compute <tt class="docutils literal">fib(5)</tt>, we compute <tt class="docutils literal">fib(3)</tt> and <tt class="docutils literal">fib(4)</tt>.
To compute <tt class="docutils literal">fib(3)</tt>, we compute <tt class="docutils literal">fib(1)</tt> and <tt class="docutils literal">fib(2)</tt>.  In general, the
evolved process looks like a tree. Each blue dot indicates a completed
computation of a Fibonacci number in the traversal of this tree.</p>
<div class="figure">
<img alt="" src="../img/fib.png">
</div>
<p>This function is instructive as a prototypical tree recursion, but it is a
terribly inefficient way to compute Fibonacci numbers because it does so much
redundant computation. The entire computation of <tt class="docutils literal">fib(3)</tt> is duplicated.</p>
<p>We can measure this inefficiency. The higher-order <tt class="docutils literal">count</tt> function returns
an equivalent function to its argument that also maintains a <tt class="docutils literal">call_count</tt>
attribute. In this way, we can inspect just how many times <tt class="docutils literal">fib</tt> is called.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">counted</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">counted</span><span class="o">.</span><span class="n">call_count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">counted</span><span class="o">.</span><span class="n">call_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">counted</span>
</pre></div>

<p>By counting the number of calls to <tt class="docutils literal">fib</tt>, we see that the calls required
grows faster than the Fibonacci numbers themselves. This rapid expansion of
calls is characteristic of tree-recursive functions.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">fib</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>
<span class="go">4181</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="o">.</span><span class="n">call_count</span>
<span class="go">13529</span>
</pre></div>

<p><strong>Space.</strong> To understand the space requirements of a function, we must specify
generally how memory is used, preserved, and reclaimed in our environment model
of computation. In evaluating an expression, the interpreter preserves all
<em>active</em> environments and all values and frames referenced by those
environments.  An environment is active if it provides the evaluation context
for some expression being evaluated. An environment becomes inactive whenever
the function call for which its first frame was created finally returns.</p>
<p>For example, when evaluating <tt class="docutils literal">fib</tt>, the interpreter proceeds to compute each
value in the order shown previously, traversing the structure of the tree.  To
do so, it only needs to keep track of those nodes that are above the current
node in the tree at any point in the computation. The memory used to evaluate
the rest of the branches can be reclaimed because it cannot affect future
computation. In general, the space required for tree-recursive functions will
be proportional to the maximum depth of the tree.</p>
<p>The diagram below depicts the environment created by evaluating <tt class="docutils literal">fib(3)</tt>.  In
the process of evaluating the return expression for the initial application of
<tt class="docutils literal">fib</tt>, the expression <tt class="docutils literal"><span class="pre">fib(n-2)</span></tt> is evaluated, yielding a value of 0.
Once this value is computed, the corresponding environment frame (grayed out)
is no longer needed: it is not part of an active environment. Thus, a
well-designed interpreter can reclaim the memory that was used to store this
frame. On the other hand, if the interpreter is currently
evaluating <tt class="docutils literal"><span class="pre">fib(n-1)</span></tt>, then the environment created by this application of
<tt class="docutils literal">fib</tt> (in which <tt class="docutils literal">n</tt> is 2) is active. In turn, the environment
originally created to apply <tt class="docutils literal">fib</tt> to 3 is active because its return value
has not yet been computed.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="8" id="example_26" style="">
def fib(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n-2) + fib(n-1)

result = fib(2)
</div>
<script type="text/javascript">
var example_26_trace = {"code": "def fib(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n-2) + fib(n-1)\n\nresult = fib(2)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 8, "ordered_globals": ["fib"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 1, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 2, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 4, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 6, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}], "stdout": ""}, {"event": "call", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 1, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}, {"encoded_locals": {"n": 0}, "frame_id": 2, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 2, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}, {"encoded_locals": {"n": 0}, "frame_id": 2, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f2"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 3, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}, {"encoded_locals": {"n": 0}, "frame_id": 2, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f2"}], "stdout": ""}, {"event": "return", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 3, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}, {"encoded_locals": {"__return__": 0, "n": 0}, "frame_id": 2, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f2"}], "stdout": ""}, {"event": "call", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 1, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}, {"encoded_locals": {"__return__": 0, "n": 0}, "frame_id": 2, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f2_z"}, {"encoded_locals": {"n": 1}, "frame_id": 3, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 2, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}, {"encoded_locals": {"__return__": 0, "n": 0}, "frame_id": 2, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f2_z"}, {"encoded_locals": {"n": 1}, "frame_id": 3, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 4, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}, {"encoded_locals": {"__return__": 0, "n": 0}, "frame_id": 2, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f2_z"}, {"encoded_locals": {"n": 1}, "frame_id": 3, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f3"}], "stdout": ""}, {"event": "step_line", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 5, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}, {"encoded_locals": {"__return__": 0, "n": 0}, "frame_id": 2, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f2_z"}, {"encoded_locals": {"n": 1}, "frame_id": 3, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f3"}], "stdout": ""}, {"event": "return", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 5, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}, {"encoded_locals": {"__return__": 0, "n": 0}, "frame_id": 2, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f2_z"}, {"encoded_locals": {"__return__": 1, "n": 1}, "frame_id": 3, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f3"}], "stdout": ""}, {"event": "return", "func_name": "fib", "globals": {"fib": ["REF", 1]}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 6, "ordered_globals": ["fib"], "stack_to_render": [{"encoded_locals": {"__return__": 1, "n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f1"}, {"encoded_locals": {"__return__": 0, "n": 0}, "frame_id": 2, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f2_z"}, {"encoded_locals": {"__return__": 1, "n": 1}, "frame_id": 3, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f3_z"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"fib": ["REF", 1], "result": 1}, "heap": {"1": ["FUNCTION", "fib(n)", null]}, "line": 8, "ordered_globals": ["fib", "result"], "stack_to_render": [{"encoded_locals": {"__return__": 1, "n": 2}, "frame_id": 1, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f1_z"}, {"encoded_locals": {"__return__": 0, "n": 0}, "frame_id": 2, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f2_z"}, {"encoded_locals": {"__return__": 1, "n": 1}, "frame_id": 3, "func_name": "fib", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["n", "__return__"], "parent_frame_id_list": [], "unique_hash": "fib_f3_z"}], "stdout": ""}]}</script><p>The higher-order <tt class="docutils literal">count_frames</tt> function tracks <tt class="docutils literal">open_count</tt>, the number of
calls to the function <tt class="docutils literal">f</tt> that have not yet returned. The <tt class="docutils literal">max_count</tt>
attribute is the maximum value ever attained by <tt class="docutils literal">open_count</tt>, and it
corresponds to the maximum number of frames that are ever simultaneously
active during the course of computation.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">count_frames</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">counted</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">counted</span><span class="o">.</span><span class="n">open_count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">    </span>        <span class="n">counted</span><span class="o">.</span><span class="n">max_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">counted</span><span class="o">.</span><span class="n">max_count</span><span class="p">,</span> <span class="n">counted</span><span class="o">.</span><span class="n">open_count</span><span class="p">)</span>
<span class="gp">    </span>        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">    </span>        <span class="n">counted</span><span class="o">.</span><span class="n">open_count</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">result</span>
<span class="gp">    </span>    <span class="n">counted</span><span class="o">.</span><span class="n">open_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="n">counted</span><span class="o">.</span><span class="n">max_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">counted</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span> <span class="o">=</span> <span class="n">count_frames</span><span class="p">(</span><span class="n">fib</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>
<span class="go">4181</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="o">.</span><span class="n">open_count</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="o">.</span><span class="n">max_count</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="go">46368</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="o">.</span><span class="n">max_count</span>
<span class="go">24</span>
</pre></div>

<p>To summarize, the space requirement of the <tt class="docutils literal">fib</tt> function, measured in
active frames, is one less than the input, which tends to be small. The time
requirement measured in total recursive calls is larger than the output, which
tends to be huge.</p>
</div>
<div class="section" id="memoization">
<h3>2.8.2   Memoization</h3>
<p>Tree-recursive computational processes can often be made more efficient through
<em>memoization</em>, a powerful technique for increasing the efficiency of recursive
functions that repeat computation. A memoized function will store the return
value for any arguments it has previously received. A second call to
<tt class="docutils literal">fib(25)</tt> would not re-compute the return value recursively, but instead
return the existing one that has already been constructed.</p>
<p>Memoization can be expressed naturally as a higher-order function, which can
also be used as a decorator. The definition below creates a <em>cache</em> of
previously computed results, indexed by the arguments from which they were
computed. The use of a dictionary requires that the argument to the memoized
function be immutable.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">memo</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">memoized</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">memoized</span>
</pre></div>

<p>If we apply <tt class="docutils literal">memo</tt> to the recursive computation of Fibonacci numbers, a
new pattern of computation evolves, depicted below.</p>
<div class="figure">
<img alt="" src="../img/fib_memo.png">
</div>
<p>In this computation of <tt class="docutils literal">fib(5)</tt>, the results for <tt class="docutils literal">fib(2)</tt> and <tt class="docutils literal">fib(3)</tt>
are reused when computing <tt class="docutils literal">fib(4)</tt> on the right branch of the tree. As a
result, much of the tree-recursive computation is not required at all.</p>
<p>Using <tt class="docutils literal">count</tt>, we can see that the <tt class="docutils literal">fib</tt> function is actually only called
once for each unique input to <tt class="docutils literal">fib</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">counted_fib</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">fib</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span>  <span class="o">=</span> <span class="n">memo</span><span class="p">(</span><span class="n">counted_fib</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>
<span class="go">4181</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counted_fib</span><span class="o">.</span><span class="n">call_count</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mi">34</span><span class="p">)</span>
<span class="go">5702887</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">counted_fib</span><span class="o">.</span><span class="n">call_count</span>
<span class="go">35</span>
</pre></div>

</div>
<div class="section" id="orders-of-growth">
<h3>2.8.3   Orders of Growth</h3>
<p>Processes can differ massively in the rates at which they consume the
computational resources of space and time, as the previous examples illustrate.
However, exactly determining just how much space or time will be used when
calling a function is a very difficult task that depends upon many factors.
A useful way to analyze a process is to categorize it along with a group of
processes that all have similar requirements. A useful categorization is the
<em>order of growth</em> of a process, which expresses in simple terms how the
resource requirements of a process grow as a function of the input.</p>
<p>As an introduction to orders of growth, we will analyze the function
<tt class="docutils literal">count_factors</tt> below, which counts the number of integers that evenly divide
an input <tt class="docutils literal">n</tt>. The function attempts to divide <tt class="docutils literal">n</tt> by every integer less
than or equal to its square root. The implementation takes advantage of the
fact that if <span class="rawlatex">$k$</span> divides <span class="rawlatex">$n$</span> and <span class="rawlatex">$k &lt;
\sqrt{n}$</span> , then there is another factor <span class="rawlatex">$j = n / k$</span> such that
<span class="rawlatex">$j &gt; \sqrt{n}$</span>.</p>
<div class="example" data-output="False" data-showallframelabels="True" data-step="-1" id="example_27" style="">
from math import sqrt
def count_factors(n):
    sqrt_n = sqrt(n)
    k, factors = 1, 0
    while k &lt; sqrt_n:
        if n % k == 0:
            factors += 2
        k += 1
    if k * k == n:
        factors += 1
    return factors

result = count_factors(576)
</div>
<script type="text/javascript">
var example_27_trace = {"code": "from math import sqrt\ndef count_factors(n):\n    sqrt_n = sqrt(n)\n    k, factors = 1, 0\n    while k < sqrt_n:\n        if n % k == 0:\n            factors += 2\n        k += 1\n    if k * k == n:\n        factors += 1\n    return factors\n\nresult = count_factors(576)", "trace": [{"event": "step_line", "func_name": "<module>", "globals": {}, "heap": {}, "line": 1, "ordered_globals": [], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null]}, "line": 2, "ordered_globals": ["sqrt"], "stack_to_render": [], "stdout": ""}, {"event": "step_line", "func_name": "<module>", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 13, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [], "stdout": ""}, {"event": "call", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 2, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"n": 576}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 3, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"n": 576}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 4, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 0, "k": 1, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 0, "k": 1, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 7, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 0, "k": 1, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 2, "k": 1, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 2, "k": 2, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 2, "k": 2, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 7, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 2, "k": 2, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 4, "k": 2, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 4, "k": 3, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 4, "k": 3, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 7, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 4, "k": 3, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 6, "k": 3, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 6, "k": 4, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 6, "k": 4, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 7, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 6, "k": 4, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 8, "k": 4, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 8, "k": 5, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 8, "k": 5, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 8, "k": 5, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 8, "k": 6, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 8, "k": 6, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 7, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 8, "k": 6, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 10, "k": 6, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 10, "k": 7, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 10, "k": 7, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 10, "k": 7, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 10, "k": 8, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 10, "k": 8, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 7, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 10, "k": 8, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 12, "k": 8, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 12, "k": 9, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 12, "k": 9, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 7, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 12, "k": 9, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 14, "k": 9, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 14, "k": 10, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 14, "k": 10, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 14, "k": 10, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 14, "k": 11, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 14, "k": 11, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 14, "k": 11, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 14, "k": 12, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 14, "k": 12, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 7, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 14, "k": 12, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 12, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 13, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 13, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 13, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 14, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 14, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 14, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 15, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 15, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 15, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 16, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 16, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 7, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 16, "k": 16, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 18, "k": 16, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 18, "k": 17, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 18, "k": 17, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 18, "k": 17, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 18, "k": 18, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 18, "k": 18, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 7, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 18, "k": 18, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 18, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 19, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 19, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 19, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 20, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 20, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 20, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 21, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 21, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 21, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 22, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 22, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 22, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 23, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 6, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 23, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 8, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 23, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 5, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 24, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 9, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 24, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 10, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 20, "k": 24, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "step_line", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 11, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"factors": 21, "k": 24, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "return", "func_name": "count_factors", "globals": {"count_factors": ["REF", 2], "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 11, "ordered_globals": ["sqrt", "count_factors"], "stack_to_render": [{"encoded_locals": {"__return__": 21, "factors": 21, "k": 24, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": true, "is_parent": false, "is_zombie": false, "ordered_varnames": ["n", "sqrt_n", "k", "factors", "__return__"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1"}], "stdout": ""}, {"event": "return", "func_name": "<module>", "globals": {"count_factors": ["REF", 2], "result": 21, "sqrt": ["REF", 1]}, "heap": {"1": ["FUNCTION", "sqrt(...)", null], "2": ["FUNCTION", "count_factors(n)", null]}, "line": 13, "ordered_globals": ["sqrt", "count_factors", "result"], "stack_to_render": [{"encoded_locals": {"__return__": 21, "factors": 21, "k": 24, "n": 576, "sqrt_n": ["SPECIAL_FLOAT", "24.0"]}, "frame_id": 1, "func_name": "count_factors", "is_highlighted": false, "is_parent": false, "is_zombie": true, "ordered_varnames": ["n", "sqrt_n", "k", "factors", "__return__"], "parent_frame_id_list": [], "unique_hash": "count_factors_f1_z"}], "stdout": ""}]}</script><p>How much time is required to evaluate <tt class="docutils literal">count_factors</tt>? The exact answer will
vary on different machines, but we can make some useful general
observations about the amount of computation involved.  The total number of
times this process executes the body of the <tt class="docutils literal">while</tt> statement is the greatest
integer less than <span class="rawlatex">$\sqrt{n}$</span>. The statements before and after this
<tt class="docutils literal">while</tt> statement are executed exactly once. So, the total number of
statements executed is <span class="rawlatex">$w \cdot \sqrt{n} + v$</span>, where
<span class="rawlatex">$w$</span> is the number of statements in the <tt class="docutils literal">while</tt> body and
<span class="rawlatex">$v$</span> is the number of statements outside of the <tt class="docutils literal">while</tt> statement.
Although it isn't exact, this formula generally characterizes how much time
will be required to evaluate <tt class="docutils literal">count_factors</tt> as a function of the input
<tt class="docutils literal">n</tt>.</p>
<p>A more exact description is difficult to obtain. The constants <span class="rawlatex">$w$</span>
and <span class="rawlatex">$v$</span> are not constant at all, because the assignment statements
to <tt class="docutils literal">factors</tt> are sometimes executed but sometimes not. An order of growth
analysis allows us to gloss over such details and instead focus on the general
shape of growth. In particular, the order of growth for <tt class="docutils literal">count_factors</tt>
expresses in precise terms that the amount of time required to compute
<tt class="docutils literal">count_factors(n)</tt> scales at the rate <span class="rawlatex">$\sqrt{n}$</span>, within a margin
of some constant factors.</p>
<p><strong>Theta Notation.</strong> Let <span class="rawlatex">$n$</span> be a parameter that measures the
size of the input to some process, and let <span class="rawlatex">$R(n)$</span> be the amount of
some resource that the process requires for an input of size <span class="rawlatex">$n$</span>.
In our previous examples we took <span class="rawlatex">$n$</span> to be the number for which a
given function is to be computed, but there are other possibilities. For
instance, if our goal is to compute an approximation to the square root of a
number, we might take <span class="rawlatex">$n$</span> to be the number of digits of accuracy
required.</p>
<p><span class="rawlatex">$R(n)$</span> might measure the amount of memory used, the number of
elementary machine steps performed, and so on. In computers that do only
a fixed number of steps at a time, the time required to evaluate an
expression will be proportional to the number of elementary steps performed in
the process of evaluation.</p>
<p>We say that <span class="rawlatex">$R(n)$</span> has order of growth <span class="rawlatex">$\Theta(f(n))$</span>,
written <span class="rawlatex">$R(n) = \Theta(f(n))$</span> (pronounced "theta of
<span class="rawlatex">$f(n)$</span>"), if there are positive constants <span class="rawlatex">$k_1$</span> and
<span class="rawlatex">$k_2$</span> independent of <span class="rawlatex">$n$</span> such that</p>
\begin{equation*}
k_1 \cdot f(n) \leq R(n) \leq k_2 \cdot f(n)
\end{equation*}<p>for any value of <span class="rawlatex">$n$</span> larger than some minimum <span class="rawlatex">$m$</span>. In
other words, for large <span class="rawlatex">$n$</span>, the value <span class="rawlatex">$R(n)$</span> is always
sandwiched between two values that both scale with <span class="rawlatex">$f(n)$</span>:</p>
<ul class="simple">
<li>A lower bound <span class="rawlatex">$k_1 \cdot f(n)$</span> and</li>
<li>An upper bound <span class="rawlatex">$k_2 \cdot f(n)$</span>
</li>
</ul>
<p>We can apply this definition to show that the number of steps required to
evaluate <tt class="docutils literal">count_factors(n)</tt> grows as <span class="rawlatex">$\Theta(\sqrt{n})$</span> by
inspecting the function body.</p>
<p>First, we choose <span class="rawlatex">$k_1=1$</span> and <span class="rawlatex">$m=0$</span>, so that the lower
bound states that <tt class="docutils literal">count_factors(n)</tt> requires at least <span class="rawlatex">$1 \cdot
\sqrt{n}$</span> steps for any <span class="rawlatex">$n&gt;0$</span>. There are at least 4 lines executed
outside of the <tt class="docutils literal">while</tt> statement, each of which takes at least 1 step to
execute. There are at least two lines executed within the <tt class="docutils literal">while</tt> body, along
with the while header itself. All of these require at least one step. The
<tt class="docutils literal">while</tt> body is evaluated at least <span class="rawlatex">$\sqrt{n}-1$</span> times. Composing
these lower bounds, we see that the process requires at least <span class="rawlatex">$4 + 3
\cdot (\sqrt{n}-1)$</span> steps, which is always larger than <span class="rawlatex">$k_1 \cdot
\sqrt{n}$</span>.</p>
<p>Second, we can verify the upper bound. We assume that any single line in
the body of <tt class="docutils literal">count_factors</tt> requires at most <tt class="docutils literal">p</tt> steps. This assumption
isn't true for every line of Python, but does hold in this case.
Then, evaluating <tt class="docutils literal">count_factors(n)</tt> can require at most <span class="rawlatex">$p \cdot
(5 + 4 \sqrt{n})$</span>, because there are 5 lines outside of the <tt class="docutils literal">while</tt>
statement and 4 within (including the header). This upper bound holds even if
every <tt class="docutils literal">if</tt> header evaluates to true. Finally, if we choose
<span class="rawlatex">$k_2=5p$</span>, then the steps required is always smaller than
<span class="rawlatex">$k_2 \cdot \sqrt{n}$</span>. Our argument is complete.</p>
</div>
<div class="section" id="example-exponentiation">
<h3>2.8.4   Example: Exponentiation</h3>
<p>Consider the problem of computing the exponential of a given number. We would
like a function that takes as arguments a base <tt class="docutils literal">b</tt> and a positive integer
exponent <tt class="docutils literal">n</tt> and computes <span class="rawlatex">$b^n$</span>. One way to do this is via the
recursive definition</p>
\begin{align*}
b^n &amp;= b \cdot b^{n-1} \\
b^0 &amp;= 1
\end{align*}<p>which translates readily into the recursive function</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">b</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

<p>This is a linear recursive process that requires <span class="rawlatex">$\Theta(n)$</span> steps
and <span class="rawlatex">$\Theta(n)$</span> space. Just as with factorial, we can
readily formulate an equivalent linear iteration that requires a similar number
of steps but constant space.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">exp_iter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">b</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">result</span>
</pre></div>

<p>We can compute exponentials in fewer steps by using successive squaring. For
instance, rather than computing <span class="rawlatex">$b^8$</span> as</p>
\begin{equation*}
b \cdot (b \cdot (b \cdot (b \cdot (b \cdot (b \cdot (b \cdot b))))))
\end{equation*}<p>we can compute it using three multiplications:</p>
\begin{align*}
b^2 &amp;= b \cdot b \\
b^4 &amp;= b^2 \cdot b^2 \\
b^8 &amp;= b^4 \cdot b^4
\end{align*}<p>This method works fine for exponents that are powers of 2. We can also take
advantage of successive squaring in computing exponentials in general if we use
the recursive rule</p>
\begin{equation*}
b^n = \begin{cases} (b^{\frac{1}{2} n})^2 &amp; \text{if $n$ is even} \\
                    b \cdot b^{n-1}     &amp; \text{if $n$ is odd}
                    \end{cases}
\end{equation*}<p>We can express this method as a recursive function as well:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fast_exp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">square</span><span class="p">(</span><span class="n">fast_exp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">b</span> <span class="o">*</span> <span class="n">fast_exp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fast_exp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="go">1267650600228229401496703205376</span>
</pre></div>

<p>The process evolved by <tt class="docutils literal">fast_exp</tt> grows logarithmically with <tt class="docutils literal">n</tt> in both
space and number of steps. To see this, observe that computing
<span class="rawlatex">$b^{2n}$</span> using <tt class="docutils literal">fast_exp</tt> requires only one more multiplication
than computing <span class="rawlatex">$b^n$</span>. The size of the exponent we can compute
therefore doubles (approximately) with every new multiplication we are allowed.
Thus, the number of multiplications required for an exponent of <tt class="docutils literal">n</tt> grows
about as fast as the logarithm of <tt class="docutils literal">n</tt> base 2. The process has
<span class="rawlatex">$\Theta(\log n)$</span> growth. The difference between
<span class="rawlatex">$\Theta(\log n)$</span> growth and <span class="rawlatex">$\Theta(n)$</span> growth becomes
striking as <span class="rawlatex">$n$</span> becomes large. For example, <tt class="docutils literal">fast_exp</tt> for <tt class="docutils literal">n</tt>
of 1000 requires only 14 multiplications instead of 1000.</p>
</div>
<div class="section" id="growth-categories">
<h3>2.8.5   Growth Categories</h3>
<p>Orders of growth are designed to simplify the analysis and comparison of
computational processes. Many different processes can all have equivalent
orders of growth, which indicates that they scale in similar ways. It is an
essential skill of a computer scientist to know and recognize common orders
of growth and identify processes of the same order.</p>
<p><strong>Constants.</strong> Constant terms do not affect the order of growth of a process.
So, for instance, <span class="rawlatex">$\Theta(n)$</span> and <span class="rawlatex">$\Theta(500 \cdot
n)$</span> are the same order of growth. This property follows from the definition
of theta notation, which allows us to choose arbitrary constants
<span class="rawlatex">$k_1$</span> and <span class="rawlatex">$k_2$</span> (such as <span class="rawlatex">$\frac{1}{500}$</span>)
for the upper and lower bounds. For simplicity, constants are always omitted
from orders of growth.</p>
<p><strong>Logarithms.</strong> The base of a logarithm does not affect the order of growth of
a process. For instance, <span class="rawlatex">$\log_2 n$</span> and <span class="rawlatex">$\log_{10} n$</span>
are the same order of growth. Changing the base of a logarithm is equivalent to
multiplying by a constant factor.</p>
<p><strong>Nesting.</strong> When an inner computational process is repeated for each step in
an outer process, then the order of growth of the entire process is a product
of the number of steps in the outer and inner processes.</p>
<p>For example, the function <tt class="docutils literal">overlap</tt> below computes the number of elements in
list <tt class="docutils literal">a</tt> that also appear in list <tt class="docutils literal">b</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">overlap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">count</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">overlap</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">3</span>
</pre></div>

<p>The <tt class="docutils literal">in</tt> operator for lists requires <span class="rawlatex">$\Theta(n)$</span> time, where
<span class="rawlatex">$n$</span> is the length of the list <tt class="docutils literal">b</tt>. It is applied
<span class="rawlatex">$\Theta(m)$</span> times, where <span class="rawlatex">$m$</span> is the length of the list
<tt class="docutils literal">a</tt>. The <tt class="docutils literal">item in b</tt> expression is the inner process, and the <tt class="docutils literal">for item in
a</tt> loop is the outer process. The total order of growth for this function is
<span class="rawlatex">$\Theta(m \cdot n)$</span>.</p>
<p><strong>Lower-order terms.</strong> As the input to a process grows, the fastest growing
part of a computation dominates the total resources used. Theta notation
captures this intuition. In a sum, all but the fastest growing term can be
dropped without changing the order of growth.</p>
<p>For instance, consider the <tt class="docutils literal">one_more</tt> function that returns how many elements
of a list <tt class="docutils literal">a</tt> are one more than some other element of <tt class="docutils literal">a</tt>. That is, in the
list <tt class="docutils literal">[3, 14, 15, 9]</tt>, the element 15 is one more than 14, so <tt class="docutils literal">one_more</tt>
will return 1.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">one_more</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">overlap</span><span class="p">([</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">one_more</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">1</span>
</pre></div>

<p>There are two parts to this computation: the list comprehension and the call
to <tt class="docutils literal">overlap</tt>. For a list <tt class="docutils literal">a</tt> of length <span class="rawlatex">$n$</span>,  list comprehension
requires <span class="rawlatex">$\Theta(n)$</span> steps, while the call to <tt class="docutils literal">overlap</tt> requires
<span class="rawlatex">$\Theta(n^2)$</span> steps. The sum of steps is <span class="rawlatex">$\Theta(n +
n^2)$</span>, but this is not the simplest way of expressing the order of growth.</p>
<p><span class="rawlatex">$\Theta(n^2 + k \cdot n)$</span> and <span class="rawlatex">$\Theta(n^2)$</span> are
equivalent for any constant <span class="rawlatex">$k$</span> because the <span class="rawlatex">$n^2$</span> term
will eventually dominate the total for any <span class="rawlatex">$k$</span>. The fact that
bounds must hold only for <span class="rawlatex">$n$</span> greater than some minimum
<span class="rawlatex">$m$</span> establishes this equivalence. For simplicity, lower-order terms
are always omitted from orders of growth, and so we will never see a sum within
a theta expression.</p>
<p><strong>Common categories.</strong> Given these equivalence properties, a small set of
common categories emerge to describe most computational processes. The most
common are listed below from slowest to fastest growth, along with descriptions
of the growth as the input increases. Examples for each category follow.</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%">
<col width="32%">
<col width="42%">
<col width="13%">
</colgroup>
<thead valign="bottom">
<tr>
<th class="head"><strong>Category</strong></th>
<th class="head"><strong>Theta Notation</strong></th>
<th class="head"><strong>Growth Description</strong></th>
<th class="head"><strong>Example</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td>Constant</td>
<td><span class="rawlatex">$\Theta(1)$</span></td>
<td>Growth is independent of the input</td>
<td><tt class="docutils literal">abs</tt></td>
</tr>
<tr>
<td>Logarithmic</td>
<td><span class="rawlatex">$\Theta(\log{n})$</span></td>
<td>Multiplying input increments resources</td>
<td><tt class="docutils literal">fast_exp</tt></td>
</tr>
<tr>
<td>Linear</td>
<td><span class="rawlatex">$\Theta(n)$</span></td>
<td>Incrementing input increments resources</td>
<td><tt class="docutils literal">exp</tt></td>
</tr>
<tr>
<td>Quadratic</td>
<td><span class="rawlatex">$\Theta(n^2)$</span></td>
<td>Incrementing input adds n resources</td>
<td><tt class="docutils literal">one_more</tt></td>
</tr>
<tr>
<td>Exponential</td>
<td><span class="rawlatex">$\Theta(b^n)$</span></td>
<td>Incrementing input multiplies resources</td>
<td><tt class="docutils literal">fib</tt></td>
</tr>
</tbody>
</table>
<p>Other categories exist, such as the <span class="rawlatex">$\Theta(\sqrt{n})$</span> growth of
<tt class="docutils literal">count_factors</tt>. However, these categories are particularly common.</p>
<p>Exponential growth describes many different orders of growth, because changing
the base <span class="rawlatex">$b$</span> does affect the order of growth.  For instance,
the number of steps in our tree-recursive Fibonacci computation <tt class="docutils literal">fib</tt> grows
exponentially in its input <span class="rawlatex">$n$</span>. In particular, one can show that
the nth Fibonacci number is the closest integer to</p>
\begin{equation*}
\frac{\phi^{n-2}}{\sqrt{5}}
\end{equation*}<p>where <span class="rawlatex">$\phi$</span> is the golden ratio:</p>
\begin{equation*}
\phi = \frac{1 + \sqrt{5}}{2} \approx 1.6180
\end{equation*}<p>We also stated that the number of steps scales with the resulting value, and so
the tree-recursive process requires <span class="rawlatex">$\Theta(\phi^n)$</span> steps, a function
that grows exponentially with <span class="rawlatex">$n$</span>.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/29-recursive-objects.html">
  		2.9 Recursive Objects
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="recursive-objects">
<h2>2.9   Recursive Objects</h2>
<p>Objects can have other objects as attribute values. When an object of some
class has an attribute value of that same class, it is a recursive object.</p>
<div class="section" id="linked-list-class">
<h3>2.9.1   Linked List Class</h3>
<p>A linked list, introduced earlier in this chapter, is composed of a first
element and the rest of the list.  The rest of a linked list is itself a linked
list — a recursive definition.  The empty list is a special case of a linked
list that has no first element or rest.  A linked list is a sequence: it has a
finite length and supports element selection by index.</p>
<p>We can now implement a class with the same behavior. In this version, we will
define its behavior using special method names that allow our class to work with
the built-in <tt class="docutils literal">len</tt> function and element selection operator (square brackets or
<tt class="docutils literal">operator.getitem</tt>) in Python. These built-in functions invoke special method
names of a class: length is computed by <tt class="docutils literal">__len__</tt> and element selection is
computed by <tt class="docutils literal">__getitem__</tt>. The empty linked list is represented by an empty
tuple, which has length 0 and no elements.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Link</span><span class="p">:</span>
<span class="gp">    </span>    <span class="sd">"""A linked list with a first element and the rest."""</span>
<span class="gp">    </span>    <span class="n">empty</span> <span class="o">=</span> <span class="p">()</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="n">empty</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">assert</span> <span class="n">rest</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">Link</span><span class="p">)</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span>
<span class="gp">    </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">4</span>
</pre></div>

<p>The definitions of <tt class="docutils literal">__len__</tt> and <tt class="docutils literal">__getitem__</tt> are in fact recursive.  The
built-in Python function <tt class="docutils literal">len</tt> invokes a method called <tt class="docutils literal">__len__</tt> when
applied to a user-defined object argument. Likewise, the element selection
operator invokes a method called <tt class="docutils literal">__getitem__</tt>. Thus, bodies of these two
methods will call themselves indirectly. For <tt class="docutils literal">__len__</tt>, the base case is
reached when <tt class="docutils literal">self.rest</tt> evaluates to the empty tuple, <tt class="docutils literal">Link.empty</tt>, which
has a length of 0.</p>
<p>The built-in <tt class="docutils literal">isinstance</tt> function returns whether the first argument has a
type that is or inherits from the second argument. <tt class="docutils literal">isinstance(rest, Link)</tt>
is true if <tt class="docutils literal">rest</tt> is a <tt class="docutils literal">Link</tt> instance or an instance of some sub-class of
<tt class="docutils literal">Link</tt>.</p>
<p>Our implementation is complete, but an instance of the <tt class="docutils literal">Link</tt> class is
currently difficult to inspect. To help with debugging, we can also define a
function to convert a <tt class="docutils literal">Link</tt> to a string expression.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">link_expression</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a string that would evaluate to s."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">rest</span> <span class="o">=</span> <span class="s1">''</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">rest</span> <span class="o">=</span> <span class="s1">', '</span> <span class="o">+</span> <span class="n">link_expression</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="s1">'Link(</span><span class="si">{0}{1}</span><span class="s1">)'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">link_expression</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">'Link(3, Link(4, Link(5)))'</span>
</pre></div>

<p>This way of displaying an <tt class="docutils literal">Link</tt> is so convenient that we would like to use
it whenever an <tt class="docutils literal">Link</tt> instance is displayed.  We can ensure this behavior by
setting the <tt class="docutils literal">link_expression</tt> function as the value of the special class
attribute <tt class="docutils literal">__repr__</tt>.  Python displays instances of user-defined classes by
invoking their <tt class="docutils literal">__repr__</tt> method.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Link</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="n">link_expression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">Link(3, Link(4, Link(5)))</span>
</pre></div>

<p>The <tt class="docutils literal">Link</tt> class has the closure property. Just as an element of a list can
itself be a list, a <tt class="docutils literal">Link</tt> can contain a <tt class="docutils literal">Link</tt> as its <tt class="docutils literal">first</tt> element.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s_first</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_first</span>
<span class="go">Link(Link(3, Link(4, Link(5))), Link(6))</span>
</pre></div>

<p>The <tt class="docutils literal">s_first</tt> linked list has only two elements, but its first element is
a linked list with three elements.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s_first</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s_first</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_first</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="go">5</span>
</pre></div>

<p>Recursive functions are particularly well-suited to manipulate linked lists.
For instance, the recursive <tt class="docutils literal">extend_link</tt> function builds a linked list
containing the elements of one <tt class="docutils literal">Link</tt> instance <tt class="docutils literal">s</tt> followed by the elements
of another <tt class="docutils literal">Link</tt> instance <tt class="docutils literal">t</tt>.  Installing this function as the
<tt class="docutils literal">__add__</tt> method of the <tt class="docutils literal">Link</tt> class emulates the addition behavior of a
built-in list.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">extend_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">t</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">extend_link</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extend_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="go">Link(3, Link(4, Link(5, Link(3, Link(4, Link(5))))))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Link</span><span class="o">.</span><span class="fm">__add__</span> <span class="o">=</span> <span class="n">extend_link</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">+</span> <span class="n">s</span>
<span class="go">Link(3, Link(4, Link(5, Link(3, Link(4, Link(5))))))</span>
</pre></div>

<p>Rather than list comprehensions, one linked list can be generated from another
using two higher-order functions: <tt class="docutils literal">map_link</tt> and <tt class="docutils literal">filter_link</tt>. The
<tt class="docutils literal">map_link</tt> function defined below applies a function <tt class="docutils literal">f</tt> to each element of
a linked list <tt class="docutils literal">s</tt> and constructs a linked list containing the results.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">map_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">s</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">),</span> <span class="n">map_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">map_link</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="go">Link(9, Link(16, Link(25)))</span>
</pre></div>

<p>The <tt class="docutils literal">filter_link</tt> function returns a linked list containing all elements of
a linked list <tt class="docutils literal">s</tt> for which <tt class="docutils literal">f</tt> returns a true value. The combination of
<tt class="docutils literal">map_link</tt> and <tt class="docutils literal">filter_link</tt> can express the same logic as a list
comprehension.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">filter_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">s</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">filtered</span> <span class="o">=</span> <span class="n">filter_link</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">):</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">filtered</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">filtered</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">odd</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">map_link</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">filter_link</span><span class="p">(</span><span class="n">odd</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
<span class="go">Link(9, Link(25))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="k">if</span> <span class="n">odd</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="go">[9, 25]</span>
</pre></div>

<p>The <tt class="docutils literal">join_link</tt> function recursively constructs a string that contains the
elements of a linked list seperated by some <tt class="docutils literal">separator</tt> string. The result
is much more compact than the output of <tt class="docutils literal">link_expression</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">join_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">separator</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="s2">""</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">)</span> <span class="o">+</span> <span class="n">separator</span> <span class="o">+</span> <span class="n">join_link</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">separator</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">join_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">", "</span><span class="p">)</span>
<span class="go">'3, 4, 5'</span>
</pre></div>

<p><strong>Recursive Construction.</strong> Linked lists are particularly useful when
constructing sequences incrementally, a situation that arises often in
recursive computations.</p>
<p>The <tt class="docutils literal">count_partitions</tt> function from Chapter 1 counted the number of ways
to partition an integer <tt class="docutils literal">n</tt> using parts up to size <tt class="docutils literal">m</tt> via a tree-recursive
process. With sequences, we can also enumerate these partitions explicitly
using a similar process.</p>
<p>We follow the same recursive analysis of the problem as we did while counting:
partitioning <tt class="docutils literal">n</tt> using integers up to <tt class="docutils literal">m</tt> involves either</p>
<ol class="arabic simple">
<li>partitioning <tt class="docutils literal"><span class="pre">n-m</span></tt> using integers up to <tt class="docutils literal">m</tt>, or</li>
<li>partitioning <tt class="docutils literal">n</tt> using integers up to <tt class="docutils literal"><span class="pre">m-1</span></tt>.</li>
</ol>
<p>For base cases, we find that 0 has an empty partition, while partitioning a
negative integer or using parts smaller than 1 is impossible.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a linked list of partitions of n using parts of up to m.</span>
<span class="gp">    </span><span class="sd">    Each partition is represented as a linked list.</span>
<span class="gp">    </span><span class="sd">    """</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">Link</span><span class="o">.</span><span class="n">empty</span><span class="p">)</span> <span class="c1"># A list containing the empty partition</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">using_m</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">    </span>        <span class="n">with_m</span> <span class="o">=</span> <span class="n">map_link</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">Link</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">using_m</span><span class="p">)</span>
<span class="gp">    </span>        <span class="n">without_m</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">with_m</span> <span class="o">+</span> <span class="n">without_m</span>
</pre></div>

<p>In the recursive case, we construct two sublists of partitions. The first uses
<tt class="docutils literal">m</tt>, and so we add <tt class="docutils literal">m</tt> to each element of the result <tt class="docutils literal">using_m</tt> to
form <tt class="docutils literal">with_m</tt>.</p>
<p>The result of <tt class="docutils literal">partitions</tt> is highly nested: a linked list of linked lists.
Using <tt class="docutils literal">join_link</tt> with appropriate separators, we can display the partitions
in a human-readable manner.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">print_partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">lists</span> <span class="o">=</span> <span class="n">partitions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">strings</span> <span class="o">=</span> <span class="n">map_link</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">join_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">" + "</span><span class="p">),</span> <span class="n">lists</span><span class="p">)</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="n">join_link</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print_partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">4 + 2</span>
<span class="go">4 + 1 + 1</span>
<span class="go">3 + 3</span>
<span class="go">3 + 2 + 1</span>
<span class="go">3 + 1 + 1 + 1</span>
<span class="go">2 + 2 + 2</span>
<span class="go">2 + 2 + 1 + 1</span>
<span class="go">2 + 1 + 1 + 1 + 1</span>
<span class="go">1 + 1 + 1 + 1 + 1 + 1</span>
</pre></div>

</div>
<div class="section" id="tree-class">
<h3>2.9.2   Tree Class</h3>
<p>Trees can also be represented by instances of user-defined classes, rather than
nested instances of built-in sequence types. A tree is any data structure that
has as an attribute a sequence of branches that are also trees.</p>
<p><strong>Internal values.</strong> Previously, we defined trees in such a way that all values
appeared at the leaves of the tree. It is also common to define trees that have
internal values at the roots of each subtree.
An internal value is called an <tt class="docutils literal">label</tt> in the tree. The <tt class="docutils literal">Tree</tt> class below
represents such trees, in which each tree has a sequence of branches that are
also trees.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">branches</span><span class="o">=</span><span class="p">()):</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
<span class="gp">    </span>        <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">branches</span> <span class="o">=</span> <span class="n">branches</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="s1">'Tree(</span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">)'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branches</span><span class="p">))</span>
<span class="gp">    </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="s1">'Tree(</span><span class="si">{0}</span><span class="s1">)'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">branches</span>
</pre></div>

<p>The <tt class="docutils literal">Tree</tt> class can represent, for instance, the values computed in an
expression tree for the recursive implementation of <tt class="docutils literal">fib</tt>, the function for
computing Fibonacci numbers. The function <tt class="docutils literal">fib_tree(n)</tt> below returns a
<tt class="docutils literal">Tree</tt> that has the nth Fibonacci number as its <tt class="docutils literal">label</tt> and a trace of all
previously computed Fibonacci numbers within its branches.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fib_tree</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">left</span> <span class="o">=</span> <span class="n">fib_tree</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">    </span>        <span class="n">right</span> <span class="o">=</span> <span class="n">fib_tree</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">label</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fib_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">Tree(3, (Tree(1, (Tree(0), Tree(1))), Tree(2, (Tree(1), Tree(1, (Tree(0), Tree(1)))))))</span>
</pre></div>

<p>Trees represented in this way are also processed using recursive functions. For
example, we can sum the labels of a tree.  As a base case, we return that an
empty branch has no labels.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sum_labels</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Sum the labels of a Tree instance, which may be None."""</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">sum_labels</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">branches</span><span class="p">])</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sum_labels</span><span class="p">(</span><span class="n">fib_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">10</span>
</pre></div>

<p>We can also apply <tt class="docutils literal">memo</tt> to construct a Fibonacci tree, where repeated
subtrees are only created once by the memoized version of <tt class="docutils literal">fib_tree</tt>, but are
used multiple times as branches of different larger trees.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fib_tree</span> <span class="o">=</span> <span class="n">memo</span><span class="p">(</span><span class="n">fib_tree</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big_fib_tree</span> <span class="o">=</span> <span class="n">fib_tree</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big_fib_tree</span><span class="o">.</span><span class="n">label</span>
<span class="go">5702887</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big_fib_tree</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">big_fib_tree</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">branches</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sum_labels</span> <span class="o">=</span> <span class="n">memo</span><span class="p">(</span><span class="n">sum_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sum_labels</span><span class="p">(</span><span class="n">big_fib_tree</span><span class="p">)</span>
<span class="go">142587180</span>
</pre></div>

<p>The amount of computation time and memory saved by memoization in these cases
is substantial. Instead of creating 18,454,929 different instances of the
<tt class="docutils literal">Tree</tt> class, we now create only 35.</p>
</div>
<div class="section" id="sets">
<h3>2.9.3   Sets</h3>
<p>In addition to the list, tuple, and dictionary, Python has a fourth built-in
container type called a <tt class="docutils literal">set</tt>. Set literals follow the mathematical notation
of elements enclosed in braces.  Duplicate elements are removed upon
construction.  Sets are unordered collections, and so the printed ordering may
differ from the element ordering in the set literal.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">{1, 2, 3, 4}</span>
</pre></div>

<p>Python sets support a variety of operations, including membership tests, length
computation, and the standard set operations of union and intersection</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span> <span class="ow">in</span> <span class="n">s</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">})</span>
<span class="go">{1, 2, 3, 4, 5}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">intersection</span><span class="p">({</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
<span class="go">{3, 4}</span>
</pre></div>

<p>In addition to <tt class="docutils literal">union</tt> and <tt class="docutils literal">intersection</tt>, Python sets support several
other methods. The predicates <tt class="docutils literal">isdisjoint</tt>, <tt class="docutils literal">issubset</tt>, and <tt class="docutils literal">issuperset</tt>
provide set comparison.  Sets are mutable, and can be changed one element at a
time using <tt class="docutils literal">add</tt>, <tt class="docutils literal">remove</tt>, <tt class="docutils literal">discard</tt>, and <tt class="docutils literal">pop</tt>.  Additional methods
provide multi-element mutations, such as <tt class="docutils literal">clear</tt> and <tt class="docutils literal">update</tt>. The Python
<a class="reference external" href="http://docs.python.org/py3k/library/stdtypes.html#set">documentation for sets</a> should be
sufficiently intelligible at this point of the course to fill in the details.</p>
<p><strong>Implementing sets.</strong> Abstractly, a set is a collection of distinct objects
that supports membership testing, union, intersection, and adjunction.
Adjoining an element and a set returns a new set that contains all of the
original set's elements along with the new element, if it is distinct. Union
and intersection return the set of elements that appear in either or both sets,
respectively. As with any data abstraction, we are free to implement any
functions over any representation of sets that provides this collection of
behaviors.</p>
<p>In the remainder of this section, we consider three different methods of
implementing sets that vary in their representation. We will characterize the
efficiency of these different representations by analyzing the order of growth
of set operations.  We will use our <tt class="docutils literal">Link</tt> and <tt class="docutils literal">Tree</tt> classes from earlier
in this section, which allow for simple and elegant recursive solutions for
elementary set operations.</p>
<p><strong>Sets as unordered sequences.</strong> One way to represent a set is as a sequence in
which no element appears more than once.  The empty set is represented by the
empty sequence. Membership testing walks recursively through the list.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">set_contains</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return True if and only if set s contains v."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">empty</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="kc">True</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>

<p>This implementation of <tt class="docutils literal">set_contains</tt> requires <span class="rawlatex">$\Theta(n)$</span> time
on average to test membership of an element, where <span class="rawlatex">$n$</span> is the size
of the set <tt class="docutils literal">s</tt>. Using this linear-time function for membership, we can adjoin
an element to a set, also in linear time.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">adjoin_set</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a set containing all elements of s and element v."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">s</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">adjoin_set</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span>
<span class="go">Link(2, Link(4, Link(1, Link(5))))</span>
</pre></div>

<p>In designing a representation, one of the issues with which we should be
concerned is efficiency.  Intersecting two sets <tt class="docutils literal">set1</tt> and <tt class="docutils literal">set2</tt> also
requires membership testing, but this time each element of <tt class="docutils literal">set1</tt> must be
tested for membership in <tt class="docutils literal">set2</tt>, leading to a quadratic order of growth in
the number of steps, <span class="rawlatex">$\Theta(n^2)$</span>, for two sets of size
<span class="rawlatex">$n$</span>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">intersect_set</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a set containing all elements common to set1 and set2."""</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">keep_if_link</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">set2</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">intersect_set</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">apply_to_all_link</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">square</span><span class="p">))</span>
<span class="go">Link(4, Link(1))</span>
</pre></div>

<p>When computing the union of two sets, we must be careful not to include any
element twice.  The <tt class="docutils literal">union_set</tt> function also requires a linear number of
membership tests, creating a process that also includes <span class="rawlatex">$\Theta(n^2)$</span>
steps.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">union_set</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Return a set containing all elements either in set1 or set2."""</span>
<span class="gp">    </span>    <span class="n">set1_not_set2</span> <span class="o">=</span> <span class="n">keep_if_link</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="ow">not</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">set2</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">extend_link</span><span class="p">(</span><span class="n">set1_not_set2</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">union_set</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="go">Link(2, Link(4, Link(1, Link(5))))</span>
</pre></div>

<p><strong>Sets as ordered sequences.</strong> One way to speed up our set operations is to change
the representation so that the set elements are listed in increasing order. To
do this, we need some way to compare two objects so that we can say which is
bigger. In Python, many different types of objects can be compared using <tt class="docutils literal">&lt;</tt>
and <tt class="docutils literal">&gt;</tt> operators, but we will concentrate on numbers in this example. We will
represent a set of numbers by listing its elements in increasing order.</p>
<p>One advantage of ordering shows up in <tt class="docutils literal">set_contains</tt>: In checking for the
presence of an object, we no longer have to scan the entire set. If we reach a
set element that is larger than the item we are looking for, then we know that
the item is not in the set:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">set_contains</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">empty</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">first</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="kc">True</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_contains</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_contains</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>

<p>How many steps does this save? In the worst case, the item we are looking for
may be the largest one in the set, so the number of steps is the same as for
the unordered representation. On the other hand, if we search for items of many
different sizes we can expect that sometimes we will be able to stop searching
at a point near the beginning of the list and that other times we will still
need to examine most of the list. On average we should expect to have to
examine about half of the items in the set. Thus, the average number of steps
required will be about <span class="rawlatex">$\frac{n}{2}$</span>. This is still
<span class="rawlatex">$\Theta(n)$</span> growth, but it does save us some time in practice over
the previous implementation.</p>
<p>We can obtain a more impressive speedup by re-implementing <tt class="docutils literal">intersect_set</tt>.
In the unordered representation, this operation required <span class="rawlatex">$\Theta(n^2)$</span>
steps because we performed a complete scan of <tt class="docutils literal">set2</tt> for each element of
<tt class="docutils literal">set1</tt>. But with the ordered representation, we can use a more clever method.
We iterate through both sets simultaneously, tracking an element <tt class="docutils literal">e1</tt> in
<tt class="docutils literal">set1</tt> and <tt class="docutils literal">e2</tt> in <tt class="docutils literal">set2</tt>.  When <tt class="docutils literal">e1</tt> and <tt class="docutils literal">e2</tt> are equal, we include
that element in the intersection.</p>
<p>Suppose, however, that <tt class="docutils literal">e1</tt> is less than <tt class="docutils literal">e2</tt>. Since <tt class="docutils literal">e2</tt> is smaller than
the remaining elements of <tt class="docutils literal">set2</tt>, we can immediately conclude that <tt class="docutils literal">e1</tt>
cannot appear anywhere in the remainder of <tt class="docutils literal">set2</tt> and hence is not in the
intersection. Thus, we no longer need to consider <tt class="docutils literal">e1</tt>; we discard it and
proceed to the next element of <tt class="docutils literal">set1</tt>.  Similar logic advances through the
elements of <tt class="docutils literal">set2</tt> when <tt class="docutils literal">e2 &lt; e1</tt>. Here is the function:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">intersect_set</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">empty</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">empty</span><span class="p">(</span><span class="n">set2</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Link</span><span class="o">.</span><span class="n">empty</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">set1</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">set2</span><span class="o">.</span><span class="n">first</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">Link</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">intersect_set</span><span class="p">(</span><span class="n">set1</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">set2</span><span class="o">.</span><span class="n">rest</span><span class="p">))</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="n">e1</span> <span class="o">&lt;</span> <span class="n">e2</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">intersect_set</span><span class="p">(</span><span class="n">set1</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="n">e2</span> <span class="o">&lt;</span> <span class="n">e1</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">intersect_set</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="o">.</span><span class="n">rest</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">intersect_set</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">)</span>
<span class="go">Link(4, Link(5))</span>
</pre></div>

<p>To estimate the number of steps required by this process, observe that in each
step we shrink the size of at least one of the sets. Thus, the number of steps
required is at most the sum of the sizes of <tt class="docutils literal">set1</tt> and <tt class="docutils literal">set2</tt>, rather than
the product of the sizes, as with the unordered representation. This is
<span class="rawlatex">$\Theta(n)$</span> growth rather than <span class="rawlatex">$\Theta(n^2)$</span> -- a considerable
speedup, even for sets of moderate size. For example, the intersection of two
sets of size 100 will take around 200 steps, rather than 10,000 for
the unordered representation.</p>
<p>Adjunction and union for sets represented as ordered sequences can also be
computed in linear time.  These implementations are left as an exercise.</p>
<p><strong>Sets as binary search trees.</strong> We can do better than the ordered-list
representation by arranging the set elements in the form of a tree with exactly
two branches. The <tt class="docutils literal">entry</tt> of the root of the tree holds one element of the
set. The entries within the <tt class="docutils literal">left</tt> branch include all elements smaller than
the one at the root. Entries in the <tt class="docutils literal">right</tt> branch include all elements
greater than the one at the root. The figure below shows some trees that
represent the set <tt class="docutils literal">{1, 3, 5, 7, 9, 11}</tt>. The same set may be represented by a
tree in a number of different ways. In all binary search trees, all elements in the <tt class="docutils literal">left</tt> branch be smaller than
the <tt class="docutils literal">entry</tt> at the root, and that all elements in the <tt class="docutils literal">right</tt> subtree be larger.</p>
<div class="figure">
<img alt="" src="../img/set_trees.png">
</div>
<p>The advantage of the tree representation is this: Suppose we want to check
whether a value <tt class="docutils literal">v</tt> is contained in a set. We begin by comparing <tt class="docutils literal">v</tt> with
<tt class="docutils literal">entry</tt>. If <tt class="docutils literal">v</tt> is less than this, we know that we need only search the
<tt class="docutils literal">left</tt> subtree; if <tt class="docutils literal">v</tt> is greater, we need only search the <tt class="docutils literal">right</tt>
subtree. Now, if the tree is "balanced," each of these subtrees will be about
half the size of the original. Thus, in one step we have reduced the problem of
searching a tree of size <span class="rawlatex">$n$</span> to searching a tree of size
<span class="rawlatex">$\frac{n}{2}$</span>. Since the size of the tree is halved at each step, we
should expect that the number of steps needed to search a tree grows as
<span class="rawlatex">$\Theta(\log n)$</span>. For large sets, this will be a significant
speedup over the previous representations.  This <tt class="docutils literal">set_contains</tt> function
exploits the ordering structure of the tree-structured set.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">set_contains</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">entry</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="kc">True</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">entry</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">entry</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">set_contains</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

<p>Adjoining an item to a set is implemented similarly and also requires
<span class="rawlatex">$\Theta(\log n)$</span> steps. To adjoin a value <tt class="docutils literal">v</tt>, we compare <tt class="docutils literal">v</tt> with
<tt class="docutils literal">entry</tt> to determine whether <tt class="docutils literal">v</tt> should be added to the <tt class="docutils literal">right</tt> or to the
<tt class="docutils literal">left</tt> branch, and having adjoined <tt class="docutils literal">v</tt> to the appropriate branch we piece
this newly constructed branch together with the original <tt class="docutils literal">entry</tt> and the
other branch.  If <tt class="docutils literal">v</tt> is equal to the <tt class="docutils literal">entry</tt>, we just return the node. If
we are asked to adjoin <tt class="docutils literal">v</tt> to an empty tree, we generate a <tt class="docutils literal">Tree</tt> that has
<tt class="docutils literal">v</tt> as the <tt class="docutils literal">entry</tt> and empty <tt class="docutils literal">right</tt> and <tt class="docutils literal">left</tt> branches. Here is the
function:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">adjoin_set</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">entry</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">s</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">entry</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">entry</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">adjoin_set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">entry</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">entry</span><span class="p">,</span> <span class="n">adjoin_set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">adjoin_set</span><span class="p">(</span><span class="n">adjoin_set</span><span class="p">(</span><span class="n">adjoin_set</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Tree(2, Tree(1), Tree(3))</span>
</pre></div>

<p>Our claim that searching the tree can be performed in a logarithmic number
of steps rests on the assumption that the tree is "balanced," i.e., that the
left and the right subtree of every tree have approximately the same number of
elements, so that each subtree contains about half the elements of its parent.
But how can we be certain that the trees we construct will be balanced? Even if
we start with a balanced tree, adding elements with <tt class="docutils literal">adjoin_set</tt> may produce
an unbalanced result. Since the position of a newly adjoined element depends on
how the element compares with the items already in the set, we can expect that
if we add elements "randomly" the tree will tend to be balanced on the average.</p>
<p>But this is not a guarantee. For example, if we start with an empty set and
adjoin the numbers 1 through 7 in sequence we end up with a highly unbalanced
tree in which all the left subtrees are empty, so it has no advantage over a
simple ordered list. One way to solve this problem is to define an operation
that transforms an arbitrary tree into a balanced tree with the same elements.
We can perform this transformation after every few <tt class="docutils literal">adjoin_set</tt> operations to
keep our set in balance.</p>
<p>Intersection and union operations can be performed on tree-structured sets
in linear time by converting them to ordered lists and back. The details are
left as an exercise.</p>
<p><strong>Python set implementation.</strong> The <tt class="docutils literal">set</tt> type that is built into Python does
not use any of these representations internally.  Instead, Python uses a
representation that gives constant-time membership tests and adjoin operations
based on a technique called <em>hashing</em>, which is a topic for another course.
Built-in Python sets cannot contain mutable data types, such as lists,
dictionaries, or other sets.  To allow for nested sets, Python also includes a
built-in immutable <tt class="docutils literal">frozenset</tt> class that shares methods with the <tt class="docutils literal">set</tt>
class but excludes mutation methods and operators.</p>
</div>
</div>
      </div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
	<h1>Chapter 3: Interpreting Computer Programs</h1>
  <div class="section" id="introduction">
<h2>3.1   Introduction</h2>
<p>Chapters 1 and 2 describe the close connection between two fundamental
elements of programming: functions and data.  We saw how functions can be
manipulated as data using higher-order functions. We also saw how data can be
endowed with behavior using message passing and an object system. We have also
studied techniques for organizing large programs, such as functional
abstraction, data abstraction, class inheritance, and generic functions. These
core concepts constitute a strong foundation upon which to build modular,
maintainable, and extensible programs.</p>
<p>This chapter focuses on the third fundamental element of programming: programs
themselves. A Python program is just a collection of text.  Only through the
process of interpretation do we perform any meaningful computation based on
that text.  A programming language like Python is useful because we can define
an <em>interpreter</em>, a program that carries out Python's evaluation and execution
procedures.  It is no exaggeration to regard this as the most fundamental idea
in programming, that an interpreter, which determines the meaning of
expressions in a programming language, is just another program.</p>
<p>To appreciate this point is to change our images of ourselves as programmers.
We come to see ourselves as designers of languages, rather than only users of
languages designed by others.</p>
<div class="section" id="programming-languages">
<h3>3.1.1   Programming Languages</h3>
<p>Programming languages vary widely in their syntactic structures, features, and
domain of application. Among general purpose programming languages, the
constructs of function definition and function application are pervasive.  On
the other hand, powerful languages exist that do not include an object system,
higher-order functions, assignment,  or even control constructs such as
<tt class="docutils literal">while</tt> and <tt class="docutils literal">for</tt> statements. As an example of a powerful language with a
minimal set of features, we will introduce the <a class="reference external" href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>
programming language. The subset of Scheme introduced in this text does not
allow mutable values at all.</p>
<p>In this chapter, we study the design of interpreters and the computational
processes that they create when executing programs. The prospect of designing
an interpreter for a general programming language may seem daunting. After all,
interpreters are programs that can carry out any possible computation,
depending on their input.  However, many interpreters have an elegant common
structure: two mutually recursive functions.  The first evaluates expressions
in environments; the second applies functions to arguments.</p>
<p>These functions are recursive in that they are defined in terms of each other:
applying a function requires evaluating the expressions in its body, while
evaluating an expression may involve applying one or more functions.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/32-functional-programming.html">
  		3.2 Functional Programming
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="functional-programming">
<h2>3.2   Functional Programming</h2>
<p>The software running on any modern computer is written in a variety of
programming languages. There are physical languages, such as the machine
languages for particular computers. These languages are concerned with the
representation of data and control in terms of individual bits of storage and
primitive machine instructions. The machine-language programmer is concerned
with using the given hardware to erect systems and utilities for the efficient
implementation of resource-limited computations. High-level languages, erected
on a machine-language substrate, hide concerns about the representation of data
as collections of bits and the representation of programs as sequences of
primitive instructions. These languages have means of combination and
abstraction, such as function definition, that are appropriate to the
larger-scale organization of software systems.</p>
<p>In this section, we introduce a high-level programming language that encourages
a functional style.  Our object of study, a subset of the Scheme language,
employs a very similar model of computation to Python's, but uses only
expressions (no statements), specializes in symbolic computation, and employs
only immutable values.</p>
<p>Scheme is a dialect of <a class="reference external" href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>, the second-oldest
programming language that is still widely used today (after <a class="reference external" href="http://en.wikipedia.org/wiki/Fortran">Fortran</a>). The community of Lisp programmers
has continued to thrive for decades, and new dialects of Lisp such as <a class="reference external" href="http://en.wikipedia.org/wiki/Clojure">Clojure</a> have some of the fastest growing
communities of developers of any modern programming language. To follow along
with the examples in this text, you can <a class="reference external" href="http://inst.eecs.berkeley.edu/~scheme/">download a Scheme interpreter</a>.</p>
<div class="section" id="expressions">
<h3>3.2.1   Expressions</h3>
<p>Scheme programs consist of expressions, which are either call expressions or
special forms. A call expression consists of an operator expression followed
by zero or more operand sub-expressions, as in Python. Both the operator and
operand are contained within parentheses:</p>
<pre id="Coding-JS-quotient">
(quotient 10 2)
</pre>
<script>$c.prompt("Coding-JS-quotient", [], "scheme");</script>
<p>Scheme exclusively uses prefix notation.  Operators are often symbols, such as
<tt class="docutils literal">+</tt> and <tt class="docutils literal">*</tt>. Call expressions can be nested, and they may span more than
one line:</p>
<pre id="Coding-JS-expr">
(+ (* 3 5) (- 10 6))
</pre>
<script>$c.prompt("Coding-JS-expr", [], "scheme");</script>
<pre id="Coding-JS-multiline-expr">
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
</pre>
<script>$c.prompt("Coding-JS-multiline-expr", [], "scheme");</script>
<p>As in Python, Scheme expressions may be primitives or combinations.  Number
literals are primitives, while call expressions are combined forms that include
arbitrary sub-expressions. The evaluation procedure of call expressions matches
that of Python: first the operator and operand expressions are evaluated, and
then the function that is the value of the operator is applied to the arguments
that are the values of the operands.</p>
<p>The <tt class="docutils literal">if</tt> expression in Scheme is a <em>special form</em>, meaning that while it
looks syntactically like a call expression, it has a different evaluation
procedure.   The general form of an <tt class="docutils literal">if</tt> expression is:</p>
<pre id="Coding-JS-if-expression">
(if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)
</pre>
<script>$c.no_output_frozen_prompt("Coding-JS-if-expression", [], "scheme");</script>
<p>To evaluate an <tt class="docutils literal">if</tt> expression, the interpreter starts by evaluating the
<tt class="docutils literal">&lt;predicate&gt;</tt> part of the expression. If the <tt class="docutils literal">&lt;predicate&gt;</tt> evaluates to a
true value, the interpreter then evaluates the <tt class="docutils literal">&lt;consequent&gt;</tt> and returns its
value.  Otherwise it evaluates the <tt class="docutils literal">&lt;alternative&gt;</tt> and returns its value.</p>
<p>Numerical values can be compared using familiar comparison operators, but
prefix notation is used in this case as well:</p>
<pre id="Coding-JS-comparison">
(&gt;= 2 1)
</pre>
<script>$c.prompt("Coding-JS-comparison", [], "scheme");</script>
<p>The boolean values <tt class="docutils literal">#t</tt> (or <tt class="docutils literal">true</tt>) and <tt class="docutils literal">#f</tt> (or <tt class="docutils literal">false</tt>) in Scheme can
be combined with boolean special forms, which have evaluation procedures
similar to those in Python.</p>
<blockquote>
<ul class="simple">
<li>
<tt class="docutils literal">(and &lt;e1&gt; ... &lt;en&gt;)</tt> The interpreter evaluates the expressions <tt class="docutils literal">&lt;e&gt;</tt>
one at a time, in left-to-right order. If any <tt class="docutils literal">&lt;e&gt;</tt> evaluates to <tt class="docutils literal">false</tt>,
the value of the <tt class="docutils literal">and</tt> expression is <tt class="docutils literal">false</tt>, and the rest of the
<tt class="docutils literal">&lt;e&gt;</tt>'s are not evaluated. If all <tt class="docutils literal">&lt;e&gt;</tt>'s evaluate to true values, the
value of the <tt class="docutils literal">and</tt> expression is the value of the last one.</li>
<li>
<tt class="docutils literal">(or &lt;e1&gt; ... &lt;en&gt;)</tt> The interpreter evaluates the expressions <tt class="docutils literal">&lt;e&gt;</tt> one
at a time, in left-to-right order. If any <tt class="docutils literal">&lt;e&gt;</tt> evaluates to a true value,
that value is returned as the value of the <tt class="docutils literal">or</tt> expression, and the rest
of the <tt class="docutils literal">&lt;e&gt;</tt>'s are not evaluated. If all <tt class="docutils literal">&lt;e&gt;</tt>'s evaluate to <tt class="docutils literal">false</tt>, the
value of the <tt class="docutils literal">or</tt> expression is <tt class="docutils literal">false</tt>.</li>
<li>
<tt class="docutils literal">(not &lt;e&gt;)</tt> The value of a not expression is <tt class="docutils literal">true</tt> when the expression
<tt class="docutils literal">&lt;e&gt;</tt> evaluates to <tt class="docutils literal">false</tt>, and <tt class="docutils literal">false</tt> otherwise.</li>
</ul>
</blockquote>
</div>
<div class="section" id="definitions">
<h3>3.2.2   Definitions</h3>
<p>Values can be named using the <tt class="docutils literal">define</tt> special form:</p>
<pre id="Coding-JS-pi">
(define pi 3.14)
(* pi 2)
</pre>
<script>$c.prompt("Coding-JS-pi", [], "scheme");</script>
<p>New functions (called <em>procedures</em> in Scheme) can be defined using a second
version of the <tt class="docutils literal">define</tt> special form. For example, to define squaring, we
write:</p>
<pre id="Coding-JS-square">
(define (square x) (* x x))
</pre>
<script>$c.prompt("Coding-JS-square", [], "scheme");</script>
<p>The general form of a procedure definition is:</p>
<pre id="Coding-JS-define-syntax">
(define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;)
</pre>
<script>$c.no_output_frozen_prompt("Coding-JS-define-syntax", [], "scheme");</script>
<p>The <tt class="docutils literal">&lt;name&gt;</tt> is a symbol to be associated with the procedure definition in
the environment. The <tt class="docutils literal">&lt;formal parameters&gt;</tt> are the names used within the body
of the procedure to refer to the corresponding arguments of the procedure. The
<tt class="docutils literal">&lt;body&gt;</tt> is an expression that will yield the value of the procedure
application when the formal parameters are replaced by the actual arguments to
which the procedure is applied. The <tt class="docutils literal">&lt;name&gt;</tt> and the <tt class="docutils literal">&lt;formal parameters&gt;</tt>
are grouped within parentheses, just as they would be in an actual call to the
procedure being defined.</p>
<p>Having defined square, we can now use it in call expressions:</p>
<pre id="Coding-JS-square-eg-1">
(square 21)
</pre>
<script>$c.prompt("Coding-JS-square-eg-1", ["Coding-JS-square"], "scheme");</script>
<pre id="Coding-JS-square-eg-2">
(square (+ 2 5))
</pre>
<script>$c.prompt("Coding-JS-square-eg-2", ["Coding-JS-square"], "scheme");</script>
<pre id="Coding-JS-square-eg-3">
(square (square 3))
</pre>
<script>$c.prompt("Coding-JS-square-eg-3", ["Coding-JS-square"], "scheme");</script>
<p>User-defined functions can take multiple arguments and include special forms:</p>
<pre id="Coding-JS-ave-def">
(define (average x y)
  (/ (+ x y) 2))
</pre>
<script>$c.prompt("Coding-JS-ave-def", [], "scheme");</script>
<pre id="Coding-JS-ave-eg">
(average 1 3)
</pre>
<script>$c.prompt("Coding-JS-ave-eg", ["Coding-JS-ave-def"], "scheme");</script>
<pre id="Coding-JS-abs-def">
(define (abs x)
    (if (&lt; x 0)
        (- x)
        x))
</pre>
<script>$c.prompt("Coding-JS-abs-def", [], "scheme");</script>
<pre id="Coding-JS-abs-eg">
(abs -3)
</pre>
<script>$c.prompt("Coding-JS-abs-eg", ["Coding-JS-abs-def"], "scheme");</script>
<p>Scheme supports local definitions with the same lexical scoping rules as
Python. Below, we define an iterative procedure for computing square roots
using nested definitions and recursion:</p>
<pre id="Coding-JS-sqrt">
(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
(sqrt 9)
</pre>
<script>$c.prompt("Coding-JS-sqrt", ["Coding-JS-ave-def", "Coding-JS-abs-def", "Coding-JS-square"], "scheme");</script>
<p>Anonymous functions are created using the <tt class="docutils literal">lambda</tt> special form.  <tt class="docutils literal">Lambda</tt>
is used to create procedures in the same way as <tt class="docutils literal">define</tt>, except that
no name is specified for the procedure:</p>
<pre id="Coding-JS-lambda">
(lambda (&lt;formal-parameters&gt;) &lt;body&gt;)
</pre>
<script>$c.no_output_frozen_prompt("Coding-JS-lambda", [], "scheme");</script>
<p>The resulting procedure is just as much a procedure as one that is created
using <tt class="docutils literal">define</tt>. The only difference is that it has not been associated with
any name in the environment. In fact, the following expressions are
equivalent:</p>
<pre id="Coding-JS-define-equiv">
(define (plus4 x) (+ x 4))
(define plus4 (lambda (x) (+ x 4)))
</pre>
<script>$c.prompt("Coding-JS-define-equiv", [], "scheme");</script>
<p>Like any expression that has a procedure as its value, a lambda expression can
be used as the operator in a call expression:</p>
<pre id="Coding-JS-lambda-call">
((lambda (x y z) (+ x y (square z))) 1 2 3)
</pre>
<script>$c.prompt("Coding-JS-lambda-call", ["Coding-JS-square"], "scheme");</script>
</div>
<div class="section" id="compound-values">
<h3>3.2.3   Compound values</h3>
<p>Pairs are built into the Scheme language. For historical
reasons, pairs are created with the <tt class="docutils literal">cons</tt> built-in function, and the
elements of a pair are accessed with <tt class="docutils literal">car</tt> and <tt class="docutils literal">cdr</tt>:</p>
<pre id="Coding-JS-cons-eg-def">
(define x (cons 1 2))
</pre>
<script>$c.prompt("Coding-JS-cons-eg-def", [], "scheme");</script>
<pre id="Coding-JS-cons-eg">
x
</pre>
<script>$c.prompt("Coding-JS-cons-eg", ["Coding-JS-cons-eg-def"], "scheme");</script>
<pre id="Coding-JS-car-eg">
(car x)
</pre>
<script>$c.prompt("Coding-JS-car-eg", ["Coding-JS-cons-eg-def"], "scheme");</script>
<pre id="Coding-JS-cdr-eg">
(cdr x)
</pre>
<script>$c.prompt("Coding-JS-cdr-eg", ["Coding-JS-cons-eg-def"], "scheme");</script>
<p>Recursive lists are also built into the language, using pairs. A special value
denoted <tt class="docutils literal">nil</tt> or <tt class="docutils literal">'()</tt> represents the empty list. A recursive list value is
rendered by placing its elements within parentheses, separated by spaces:</p>
<pre id="Coding-JS-list-1">
(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
</pre>
<script>$c.prompt("Coding-JS-list-1", [], "scheme");</script>
<pre id="Coding-JS-list-2">
(list 1 2 3 4)
</pre>
<script>$c.prompt("Coding-JS-list-2", [], "scheme");</script>
<pre id="Coding-JS-1-4-def">
(define one-through-four (list 1 2 3 4))
</pre>
<script>$c.prompt("Coding-JS-1-4-def", [], "scheme");</script>
<pre id="Coding-JS-list-3">
(car one-through-four)
</pre>
<script>$c.prompt("Coding-JS-list-3", ["Coding-JS-1-4-def"], "scheme");</script>
<pre id="Coding-JS-list-4">
(cdr one-through-four)
</pre>
<script>$c.prompt("Coding-JS-list-4", ["Coding-JS-1-4-def"], "scheme");</script>
<pre id="Coding-JS-list-5">
(car (cdr one-through-four))
</pre>
<script>$c.prompt("Coding-JS-list-5", ["Coding-JS-1-4-def"], "scheme");</script>
<pre id="Coding-JS-list-6">
(cons 10 one-through-four)
</pre>
<script>$c.prompt("Coding-JS-list-6", ["Coding-JS-1-4-def"], "scheme");</script>
<pre id="Coding-JS-list-7">
(cons 5 one-through-four)
</pre>
<script>$c.prompt("Coding-JS-list-7", ["Coding-JS-1-4-def"], "scheme");</script>
<p>Whether a list is empty can be determined using the primitive <tt class="docutils literal">null?</tt>
predicate. Using it, we can define the standard sequence operations for
computing <tt class="docutils literal">length</tt> and selecting elements:</p>
<pre id="Coding-JS-selection-def">
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define (getitem items n)
  (if (= n 0)
      (car items)
      (getitem (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))
</pre>
<script>$c.prompt("Coding-JS-selection-def", [], "scheme");</script>
<pre id="Coding-JS-length-eg">
(length squares)
</pre>
<script>$c.prompt("Coding-JS-length-eg", ["Coding-JS-selection-def"], "scheme");</script>
<pre id="Coding-JS-getitem-eg">
(getitem squares 3)
</pre>
<script>$c.prompt("Coding-JS-getitem-eg", ["Coding-JS-selection-def"], "scheme");</script>
</div>
<div class="section" id="symbolic-data">
<h3>3.2.4   Symbolic Data</h3>
<p>All the compound data objects we have used so far were
constructed ultimately from numbers. One of Scheme's strengths is working
with arbitrary symbols as data.</p>
<p>In order to manipulate symbols we need a new element in our language: the
ability to <em>quote</em> a data object. Suppose we want to construct the list <tt class="docutils literal">(a
b)</tt>. We can't accomplish this with <tt class="docutils literal">(list a b)</tt>, because this expression
constructs a list of the values of <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> rather than the symbols
themselves. In Scheme, we refer to the symbols <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> rather than
their values by preceding them with a single quotation mark:</p>
<pre id="Coding-JS-quote-def">
(define a 1)
(define b 2)
</pre>
<script>$c.prompt("Coding-JS-quote-def", [], "scheme");</script>
<pre id="Coding-JS-quote-eg-1">
(list a b)
</pre>
<script>$c.prompt("Coding-JS-quote-eg-1", ["Coding-JS-quote-def"], "scheme");</script>
<pre id="Coding-JS-quote-eg-2">
(list 'a 'b)
</pre>
<script>$c.prompt("Coding-JS-quote-eg-2", ["Coding-JS-quote-def"], "scheme");</script>
<pre id="Coding-JS-quote-eg-3">
(list 'a b)
</pre>
<script>$c.prompt("Coding-JS-quote-eg-3", ["Coding-JS-quote-def"], "scheme");</script>
<p>In Scheme, any expression that is not evaluated is said to be <em>quoted</em>. This
notion of quotation is derived from a classic philosophical distinction between
a thing, such as a dog, which runs around and barks, and the word "dog" that is
a linguistic construct for designating such things. When we use "dog" in
quotation marks, we do not refer to some dog in particular but instead to a
word. In language, quotation allow us to talk about language itself, and so it
is in Scheme:</p>
<pre id="Coding-JS-code-as-data">
(list 'define 'list)
</pre>
<script>$c.prompt("Coding-JS-code-as-data", [], "scheme");</script>
<p>Quotation also allows us to type in compound objects, using the conventional
printed representation for lists:</p>
<pre id="Coding-JS-quoted-list-1">
(car '(a b c))
</pre>
<script>$c.prompt("Coding-JS-quoted-list-1", [], "scheme");</script>
<pre id="Coding-JS-quoted-list-2">
(cdr '(a b c))
</pre>
<script>$c.prompt("Coding-JS-quoted-list-2", [], "scheme");</script>
<p>The full Scheme language contains additional features, such as mutation
operations, vectors, and maps. However, the subset we have introduced so far
provides a rich functional programming language capable of implementing many of
the ideas we have discussed so far in this text.</p>
</div>
<div class="section" id="turtle-graphics">
<h3>3.2.5   Turtle graphics</h3>
<p>The implementation of Scheme that serves as a companion to this text includes
Turtle graphics, an illustrating environment developed as part of the Logo
language (another Lisp dialect). This turtle begins in the center of a canvas,
moves and turns based on procedures, and draws lines behind it as it moves.
While the turtle was invented to engage children in the act of programming, it
remains an engaging graphical tool for even advanced programmers.</p>
<p>At any moment during the course of executing a Scheme program, the turtle has a
position and heading on the canvas. Single-argument procedures such as
<tt class="docutils literal">forward</tt> and <tt class="docutils literal">right</tt> change the position and heading of the turtle. Common
procedures have abbreviations: <tt class="docutils literal">forward</tt> can also be called as <tt class="docutils literal">fd</tt>, etc.
The <tt class="docutils literal">begin</tt> special form in Scheme allows a single expression to include
multiple sub-expressions.  This form is useful for issuing multiple commands:</p>
<pre class="literal-block">
&gt; (define (repeat k fn) (if (&gt; k 0)
                            (begin (fn) (repeat (- k 1) fn))
                            nil))
&gt; (repeat 5
          (lambda () (fd 100)
                     (repeat 5
                             (lambda () (fd 20) (rt 144)))
                     (rt 144)))
nil
</pre>
<div class="figure">
<img alt="" src="../img/star.png">
</div>
<p>The full repertoire of Turtle procedures is also built into Python as the
<a class="reference external" href="http://docs.python.org/py3k/library/turtle.html">turtle library module</a>.</p>
<p>As a final example, Scheme can express recursive drawings using its turtle
graphics in a remarkably compact form.  Sierpinski's triangle is a fractal that
draws each triangle as three neighboring triangles that have vertexes at the
midpoints of the legs of the triangle that contains them.  It can be drawn to a
finite recursive depth by this Scheme program:</p>
<pre class="literal-block">
&gt; (define (repeat k fn)
    (if (&gt; k 0)
        (begin (fn) (repeat (- k 1) fn))
        nil))

&gt; (define (tri fn)
    (repeat 3 (lambda () (fn) (lt 120))))

&gt; (define (sier d k)
    (tri (lambda ()
           (if (= k 1) (fd d) (leg d k)))))

&gt; (define (leg d k)
    (sier (/ d 2) (- k 1))
    (penup)
    (fd d)
    (pendown))
</pre>
<p>The <tt class="docutils literal">triangle</tt> procedure is a general method for repeating a drawing
procedure three times with a left turn following each repetition.  The
<tt class="docutils literal">sier</tt> procedure takes a length <tt class="docutils literal">d</tt> and a recursive depth <tt class="docutils literal">k</tt>.  It draws
a plain triangle if the depth is 1, and otherwise draws a triangle made up
of calls to <tt class="docutils literal">leg</tt>.  The <tt class="docutils literal">leg</tt> procedure draws a single leg of a recursive
Sierpinski triangle by a recursive call to <tt class="docutils literal">sier</tt> that fills the first half
of the length of the leg, then by moving the turtle to the next vertex.  The
procedures <tt class="docutils literal">penup</tt> and <tt class="docutils literal">pendown</tt> stop the turtle from drawing as it moves
by lifting its pen up and the placing it down again. The mutual recursion
between <tt class="docutils literal">sier</tt> and <tt class="docutils literal">leg</tt> yields this result:</p>
<pre class="literal-block">
&gt; (sier 400 6)
</pre>
<div class="figure">
<img alt="" src="../img/sier.png">
</div>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/33-exceptions.html">
  		3.3 Exceptions
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="exceptions">
<h2>3.3   Exceptions</h2>
<p>Programmers must be always mindful of possible errors that may arise in their
programs. Examples abound: a function may not receive arguments that it is
designed to accept, a necessary resource may be missing, or a connection across
a network may be lost. When designing a program, one must anticipate the
exceptional circumstances that may arise and take appropriate measures to
handle them.</p>
<p>There is no single correct approach to handling errors in a program.  Programs
designed to provide some persistent service like a web server should be robust
to errors, logging them for later consideration but continuing to service new
requests as long as possible. On the other hand, the Python interpreter handles
errors by terminating immediately and printing an error message, so that
programmers can address issues as soon as they arise. In any case, programmers
must make conscious choices about how their programs should react to
exceptional conditions.</p>
<p><em>Exceptions</em>, the topic of this section, provides a general mechanism for
adding error-handling logic to programs. <em>Raising an exception</em> is a technique
for interrupting the normal flow of execution in a program, signaling that
some exceptional circumstance has arisen, and returning directly to an
enclosing part of the program that was designated to react to that
circumstance.  The Python interpreter raises an exception each time it detects
an error in an expression or statement.  Users can also raise exceptions with
<tt class="docutils literal">raise</tt> and <tt class="docutils literal">assert</tt> statements.</p>
<p><strong>Raising exceptions.</strong> An exception is a object instance with a class that
inherits, either directly or indirectly, from the <tt class="docutils literal">BaseException</tt> class. The
<tt class="docutils literal">assert</tt> statement introduced in Chapter 1 raises an exception with the class
<tt class="docutils literal">AssertionError</tt>.  In general, any exception instance can be raised with the <tt class="docutils literal">raise</tt>
statement. The general form of raise statements are described in the <a class="reference external" href="http://docs.python.org/py3k/reference/simple_stmts.html#raise">Python
docs</a>. The
most common use of <tt class="docutils literal">raise</tt> constructs an exception instance and raises it.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'An error occurred'</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">Exception</span>: <span class="n">an error occurred</span>
</pre></div>

<p>When an exception is raised, no further statements in the current block of code
are executed. Unless the exception is <em>handled</em> (described below), the
interpreter will return directly to the interactive read-eval-print loop, or
terminate entirely if Python was started with a file argument. In addition, the
interpreter will print a <em>stack backtrace</em>, which is a structured block of text
that describes the nested set of active function calls in the branch of
execution in which the exception was raised. In the example above, the file
name <tt class="docutils literal">&lt;stdin&gt;</tt> indicates that the exception was raised by the user in an
interactive session, rather than from code in a file.</p>
<p><strong>Handling exceptions.</strong> An exception can be handled by an enclosing <tt class="docutils literal">try</tt>
statement. A <tt class="docutils literal">try</tt> statement consists of multiple clauses; the first begins
with <tt class="docutils literal">try</tt> and the rest begin with <tt class="docutils literal">except</tt>:</p>
<pre class="literal-block">
try:
    &lt;try suite&gt;
except &lt;exception class&gt; as &lt;name&gt;:
    &lt;except suite&gt;
...
</pre>
<p>The <tt class="docutils literal">&lt;try suite&gt;</tt> is always executed immediately when the <tt class="docutils literal">try</tt> statement
is executed.  Suites of the <tt class="docutils literal">except</tt> clauses are only executed when an
exception is raised during the course of executing the <tt class="docutils literal">&lt;try suite&gt;</tt>. Each
<tt class="docutils literal">except</tt> clause specifies the particular class of exception to handle. For
instance, if the <tt class="docutils literal">&lt;exception class&gt;</tt> is <tt class="docutils literal">AssertionError</tt>, then any instance
of a class inheriting from <tt class="docutils literal">AssertionError</tt> that is raised during the course
of executing the <tt class="docutils literal">&lt;try suite&gt;</tt> will be handled by the following <tt class="docutils literal">&lt;except
suite&gt;</tt>. Within the <tt class="docutils literal">&lt;except suite&gt;</tt>, the identifier <tt class="docutils literal">&lt;name&gt;</tt> is bound to
the exception object that was raised, but this binding does not persist beyond
the <tt class="docutils literal">&lt;except suite&gt;</tt>.</p>
<p>For example, we can handle a <tt class="docutils literal">ZeroDivisionError</tt> exception using a <tt class="docutils literal">try</tt>
statement that binds the name <tt class="docutils literal">x</tt> to 0 when the exception is raised.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">    </span>    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="gp">    </span><span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'handling a'</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
<span class="gp">    </span>    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="go">handling a &lt;class 'ZeroDivisionError'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">0</span>
</pre></div>

<p>A <tt class="docutils literal">try</tt> statement will handle exceptions that occur within the body of a
function that is applied (either directly or indirectly) within the <tt class="docutils literal">&lt;try
suite&gt;</tt>.  When an exception is raised, control jumps directly to the body of
the <tt class="docutils literal">&lt;except suite&gt;</tt> of the most recent <tt class="docutils literal">try</tt> statement that handles that
type of exception.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span>  <span class="c1"># Raises a ZeroDivisionError if x is 0</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'Never printed if x is 0'</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">result</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">invert_safe</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">invert</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invert_safe</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Never printed if x is 0</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_safe</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">'division by zero'</span>
</pre></div>

<p>This example illustrates that the <tt class="docutils literal">print</tt> expression in <tt class="docutils literal">invert</tt> is never
evaluated, and instead control is transferred to the suite of the <tt class="docutils literal">except</tt>
clause in <tt class="docutils literal">invert_safe</tt>. Coercing the <tt class="docutils literal">ZeroDivisionError</tt> <tt class="docutils literal">e</tt> to a
string gives the human-interpretable string returned by <tt class="docutils literal">invert_safe</tt>:
<tt class="docutils literal">'division by zero'</tt>.</p>
<div class="section" id="exception-objects">
<h3>3.3.1   Exception Objects</h3>
<p>Exception objects themselves can have attributes, such as the error message
stated in an <tt class="docutils literal">assert</tt> statement and information about where in the course of
execution the exception was raised. User-defined exception classes can have
additional attributes.</p>
<p>In Chapter 1, we implemented Newton's method to find the zeros of arbitrary
functions. The following example defines an exception class that returns the
best guess discovered in the course of iterative improvement whenever a
<tt class="docutils literal">ValueError</tt> occurs. A math domain error (a type of <tt class="docutils literal">ValueError</tt>) is raised
when <tt class="docutils literal">sqrt</tt> is applied to a negative number. This exception is handled by
raising an <tt class="docutils literal">IterImproveError</tt> that stores the most recent guess from Newton's
method as an attribute.</p>
<p>First, we define a new class that inherits from <tt class="docutils literal">Exception</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">IterImproveError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">last_guess</span><span class="p">):</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">last_guess</span> <span class="o">=</span> <span class="n">last_guess</span>
</pre></div>

<p>Next, we define a version of <tt class="docutils literal">improve</tt>, our generic iterative improvement
algorithm.  This version handles any <tt class="docutils literal">ValueError</tt> by raising an
<tt class="docutils literal">IterImproveError</tt> that stores the most recent guess. As before,
<tt class="docutils literal">improve</tt> takes as arguments two functions, each of which takes a
single numerical argument. The <tt class="docutils literal">update</tt> function returns new guesses, while
the <tt class="docutils literal">done</tt> function returns a boolean indicating that improvement has
converged to a correct value.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">improve</span><span class="p">(</span><span class="n">update</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">guess</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_updates</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">max_updates</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">guess</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
<span class="gp">    </span>            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">guess</span>
<span class="gp">    </span>    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">raise</span> <span class="n">IterImproveError</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
</pre></div>

<p>Finally, we define <tt class="docutils literal">find_zero</tt>, which returns the result of <tt class="docutils literal">improve</tt>
applied to a Newton update function returned by <tt class="docutils literal">newton_update</tt>, which is
defined in Chapter 1 and requires no changes for this example. This version of
<tt class="docutils literal">find_zero</tt> handles an <tt class="docutils literal">IterImproveError</tt> by returning its last guess.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">find_zero</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">guess</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">improve</span><span class="p">(</span><span class="n">newton_update</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">done</span><span class="p">,</span> <span class="n">guess</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">except</span> <span class="n">IterImproveError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">last_guess</span>
</pre></div>

<p>Consider applying <tt class="docutils literal">find_zero</tt> to find the zero of the function
<span class="rawlatex">$2x^2 + \sqrt{x}$</span>. This function has a zero at 0, but evaluating
it on any negative number will raise a <tt class="docutils literal">ValueError</tt>. Our Chapter 1
implementation of Newton's Method would raise that error and fail to return any
guess of the zero. Our revised implementation returns the last guess found
before the error.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_zero</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-0.030211203830201594</span>
</pre></div>

<p>Although this approximation is still far from the correct answer of 0, some
applications would prefer this coarse approximation to a <tt class="docutils literal">ValueError</tt>.</p>
<p>Exceptions are another technique that help us as programs to separate the
concerns of our program into modular parts.  In this example, Python's
exception mechanism allowed us to separate the logic for iterative improvement,
which appears unchanged in the suite of the <tt class="docutils literal">try</tt> clause, from the logic for
handling errors, which appears in <tt class="docutils literal">except</tt> clauses. We will also find that
exceptions are a useful feature when implementing interpreters in Python.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/34-interpreters-for-languages-with-combination.html">
  		3.4 Interpreters for Languages with Combination
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="interpreters-for-languages-with-combination">
<h2>3.4   Interpreters for Languages with Combination</h2>
<p>We now embark on a tour of the technology by which languages are established in
terms of other languages.  <em>Metalinguistic abstraction</em> — establishing new
languages — plays an important role in all branches of engineering design. It
is particularly important to computer programming, because in programming not
only can we formulate new languages but we can also implement these languages
by constructing interpreters. An interpreter for a programming language is a
function that, when applied to an expression of the language, performs the
actions required to evaluate that expression.</p>
<p>We will first define an interpreter for a language that is a limited subset of
Scheme, called Calculator.  Then, we will develop a sketch of an interpreter
for Scheme as a whole.  The interpreter we create will be complete in the sense
that it will allow us to write fully general programs in Scheme. To do so, it
will implement the same environment model of evaluation that we introduced for
Python programs in Chapter 1.</p>
<p>Many of the examples in this section are contained in the companion
<a class="reference external" href="../examples/scalc/scalc.html">Scheme-Syntax Calculator example</a>, as they are
too complex to fit naturally in the format of this text.</p>
<div class="section" id="a-scheme-syntax-calculator">
<h3>3.4.1   A Scheme-Syntax Calculator</h3>
<p>The Scheme-Syntax Calculator (or simply Calculator) is an expression language
for the arithmetic operations of addition, subtraction, multiplication, and
division. Calculator shares Scheme's call expression syntax and operator
behavior. Addition (<tt class="docutils literal">+</tt>) and multiplication (<tt class="docutils literal">*</tt>) operations each take an
arbitrary number of arguments:</p>
<pre class="literal-block">
&gt; (+ 1 2 3 4)
10
&gt; (+)
0
&gt; (* 1 2 3 4)
24
&gt; (*)
1
</pre>
<p>Subtraction (<tt class="docutils literal">-</tt>) has two behaviors.  With one argument, it negates the
argument.  With at least two arguments, it subtracts all but the first from the
first.  Division (<tt class="docutils literal">/</tt>) has a similar pair of two behaviors: compute the
multiplicative inverse of a single argument or divide all but the first into the
first:</p>
<pre class="literal-block">
&gt; (- 10 1 2 3)
4
&gt; (- 3)
-3
&gt; (/ 15 12)
1.25
&gt; (/ 30 5 2)
3
&gt; (/ 10)
0.1
</pre>
<p>A call expression is evaluated by evaluating its operand sub-expressions, then
applying the operator to the resulting arguments:</p>
<pre class="literal-block">
&gt; (- 100 (* 7 (+ 8 (/ -12 -3))))
16.0
</pre>
<p>We will implement an interpreter for the Calculator language in Python.  That
is, we will write a Python program that takes string lines as input and returns
the result of evaluating those lines as a Calculator expression.  Our
interpreter will raise an appropriate exception if the calculator expression is
not well formed.</p>
</div>
<div class="section" id="expression-trees">
<h3>3.4.2   Expression Trees</h3>
<p>Until this point in the course, expression trees have been conceptual entities
to which we have referred in describing the process of evaluation; we have
never before explicitly represented expression trees as data in our programs.
In order to write an interpreter, we must operate on expressions as data.</p>
<p>A primitive expression is just a number or a string in Calculator: either an
<tt class="docutils literal">int</tt> or <tt class="docutils literal">float</tt> or an operator symbol. All combined expressions
are call expressions.  A call expression is a Scheme list with a first element
(the operator) followed by zero or more operand expressions.</p>
<p><strong>Scheme Pairs.</strong> In Scheme, lists are nested pairs, but not all pairs are
lists.  To represent Scheme pairs and lists in Python, we will define a class
<tt class="docutils literal">Pair</tt> that is similar to the <tt class="docutils literal">Rlist</tt> class earlier in the chapter. The
implementation appears in <a class="reference external" href="../examples/scalc/scheme_reader.py.html">scheme_reader</a>.</p>
<p>The empty list is represented by an object called <tt class="docutils literal">nil</tt>, which is an instance
of the class <tt class="docutils literal">nil</tt>. We assume that only one <tt class="docutils literal">nil</tt> instance will ever be
created.</p>
<p>The <tt class="docutils literal">Pair</tt> class and <tt class="docutils literal">nil</tt> object are Scheme values represented in Python.
They have <tt class="docutils literal">repr</tt> strings that are Python expressions and <tt class="docutils literal">str</tt> strings that
are Scheme expressions.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Pair</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nil</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">Pair(1, Pair(2, nil))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">(1 2)</span>
</pre></div>

<p>They implement the basic Python sequence interface of length and element
selection, as well as a <tt class="docutils literal">map</tt> method that returns a Scheme list.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">4</span><span class="p">))</span>
<span class="go">(5 6)</span>
</pre></div>

<p><strong>Nested Lists.</strong> Nested pairs can represent lists, but the elements of a
list can also be lists themselves. Pairs are therefore sufficient to represent
Scheme expressions, which are in fact nested lists.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">Pair</span><span class="p">(</span><span class="s1">'+'</span><span class="p">,</span> <span class="n">Pair</span><span class="p">(</span><span class="n">Pair</span><span class="p">(</span><span class="s1">'*'</span><span class="p">,</span> <span class="n">Pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Pair</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">nil</span><span class="p">))),</span> <span class="n">Pair</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">nil</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
<span class="go">(+ (* 3 4) 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
<span class="go">(* 3 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">first</span>
<span class="go">3</span>
</pre></div>

<p>This example demonstrates that all Calculator expressions are nested Scheme
lists. Our Calculator interpreter will read in nested Scheme lists, convert
them into expression trees represented as nested <tt class="docutils literal">Pair</tt> instances (<em>Parsing
expressions</em> below), and then evaluate the expression trees to produce values
(<em>Calculator evaluation</em> below).</p>
</div>
<div class="section" id="parsing-expressions">
<h3>3.4.3   Parsing Expressions</h3>
<p>Parsing is the process of generating expression trees from raw text input.  A
parser is a composition of two components: a lexical analyzer and a syntactic
analyzer.  First, the <em>lexical analyzer</em> partitions the input string into
<em>tokens</em>, which are the minimal syntactic units of the language such as names
and symbols. Second, the <em>syntactic analyzer</em> constructs an expression tree
from this sequence of tokens.  The sequence of tokens produced by the lexical
analyzer is consumed by the syntactic analyzer.</p>
<p><strong>Lexical analysis.</strong> The component that interprets a string as a token
sequence is called a <em>tokenizer</em> or <em>lexical analyzer</em>. In our implementation,
the tokenizer is a function called <tt class="docutils literal">tokenize_line</tt> in <a class="reference external" href="../examples/scalc/scheme_tokens.py.html">scheme_tokens</a>. Scheme
tokens are delimited by white space, parentheses, dots, or single quotation
marks.  Delimiters are tokens, as are symbols and numerals. The tokenizer
analyzes a line character by character, validating the format of symbols and
numerals.</p>
<p>Tokenizing a well-formed Calculator expression separates all symbols and
delimiters, but identifies multi-character numbers (e.g., 2.3) and converts
them into numeric types.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tokenize_line</span><span class="p">(</span><span class="s1">'(+ 1 (* 2.3 45))'</span><span class="p">)</span>
<span class="go">['(', '+', 1, '(', '*', 2.3, 45, ')', ')']</span>
</pre></div>

<p>Lexical analysis is an iterative process, and it can be applied to each line of
an input program in isolation.</p>
<p><strong>Syntactic analysis.</strong> The component that interprets a token sequence as an
expression tree is called a <em>syntactic analyzer</em>. Syntactic analysis is a
tree-recursive process, and it must consider an entire expression that may span
multiple lines.</p>
<p>Syntactic analysis is implemented by the <tt class="docutils literal">scheme_read</tt> function in
<a class="reference external" href="../examples/scalc/scheme_reader.py.html">scheme_reader</a>. It is tree-recursive because analyzing a sequence of tokens
often involves analyzing a subsequence of those tokens into a subexpression,
which itself serves as a branch (e.g., operand) of a larger expression tree.
Recursion generates the hierarchical structures consumed by the evaluator.</p>
<p>The <tt class="docutils literal">scheme_read</tt> function expects its input <tt class="docutils literal">src</tt> to be a <tt class="docutils literal">Buffer</tt>
instance that gives access to a sequence of tokens. A <tt class="docutils literal">Buffer</tt>, defined in
the <a class="reference external" href="../examples/scalc/buffer.py.html">buffer</a> module, collects tokens that span multiple lines into a single
object that can be analyzed syntactically.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'(+ 1'</span><span class="p">,</span> <span class="s1">'   (* 2.3 45))'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expression</span> <span class="o">=</span> <span class="n">scheme_read</span><span class="p">(</span><span class="n">Buffer</span><span class="p">(</span><span class="n">tokenize_lines</span><span class="p">(</span><span class="n">lines</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expression</span>
<span class="go">Pair('+', Pair(1, Pair(Pair('*', Pair(2.3, Pair(45, nil))), nil)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
<span class="go">(+ 1 (* 2.3 45))</span>
</pre></div>

<p>The <tt class="docutils literal">scheme_read</tt> function first checks for various base cases, including
empty input (which raises an end-of-file exception, called <tt class="docutils literal">EOFError</tt> in
Python) and primitive expressions. A recursive call to <tt class="docutils literal">read_tail</tt> is invoked
whenever a <tt class="docutils literal">(</tt> token indicates the beginning of a list.</p>
<p>The <tt class="docutils literal">read_tail</tt> function continues to read from the same input <tt class="docutils literal">src</tt>, but
expects to be called after a list has begun.  Its base cases are an empty input
(an error) or a closing parenthesis that terminates the list.  Its recursive
call reads the first element of the list with <tt class="docutils literal">scheme_read</tt>, reads the rest
of the list with <tt class="docutils literal">read_tail</tt>, and then returns a list represented as a
<tt class="docutils literal">Pair</tt>.</p>
<p>This implementation of <tt class="docutils literal">scheme_read</tt> can read well-formed Scheme lists, which
are all we need for the Calculator language. Parsing dotted lists and quoted
forms is left as an exercise.</p>
<p>Informative syntax errors improve the usability of an interpreter
substantially. The <tt class="docutils literal">SyntaxError</tt> exceptions that are raised include
a description of the problem encountered.</p>
</div>
<div class="section" id="calculator-evaluation">
<h3>3.4.4   Calculator Evaluation</h3>
<p>The <a class="reference external" href="../examples/scalc/scalc.py.html">scalc</a> module implements an evaluator for the Calculator language.  The
<tt class="docutils literal">calc_eval</tt> function takes an expression as an argument and
returns its value. Definitions of the helper functions <tt class="docutils literal">simplify</tt>,
<tt class="docutils literal">reduce</tt>, and <tt class="docutils literal">as_scheme_list</tt> appear in the model and are used below.</p>
<p>For Calculator, the only two legal syntactic forms of expressions are numbers
and call expressions, which are <tt class="docutils literal">Pair</tt> instances representing well-formed
Scheme lists.  Numbers are <em>self-evaluating</em>; they can be returned directly
from <tt class="docutils literal">calc_eval</tt>. Call expressions require function application.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">calc_eval</span><span class="p">(</span><span class="n">exp</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Evaluate a Calculator expression."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">Pair</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">arguments</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">calc_eval</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">calc_apply</span><span class="p">(</span><span class="n">exp</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">arguments</span><span class="p">))</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">exp</span> <span class="o">+</span> <span class="s1">' is not a number or call expression'</span><span class="p">)</span>
</pre></div>

<p>Call expressions are evaluated by first recursively mapping the <tt class="docutils literal">calc_eval</tt>
function to the list of operands, which computes a list of <tt class="docutils literal">arguments</tt>.
Then, the operator is applied to those arguments in a second function,
<tt class="docutils literal">calc_apply</tt>.</p>
<p>The Calculator language is simple enough that we can easily express the logic
of applying each operator in the body of a single function.  In <tt class="docutils literal">calc_apply</tt>,
each conditional clause corresponds to applying one operator.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">calc_apply</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Apply the named operator to a list of args."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span> <span class="o">+</span> <span class="s1">' is not a symbol'</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">'+'</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">'-'</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">operator</span> <span class="o">+</span> <span class="s1">' requires at least 1 argument'</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="o">-</span><span class="n">args</span><span class="o">.</span><span class="n">first</span>
<span class="gp">    </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">'*'</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">'/'</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">operator</span> <span class="o">+</span> <span class="s1">' requires at least 1 argument'</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">args</span><span class="o">.</span><span class="n">first</span>
<span class="gp">    </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">truediv</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">operator</span> <span class="o">+</span> <span class="s1">' is an unknown operator'</span><span class="p">)</span>
</pre></div>

<p>Above, each suite computes the result of a different operator or raises an
appropriate <tt class="docutils literal">TypeError</tt> when the wrong number of arguments is given. The
<tt class="docutils literal">calc_apply</tt> function can be applied directly, but it must be passed a list
of <em>values</em> as arguments rather than a list of operand expressions.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">calc_apply</span><span class="p">(</span><span class="s1">'+'</span><span class="p">,</span> <span class="n">as_scheme_list</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calc_apply</span><span class="p">(</span><span class="s1">'-'</span><span class="p">,</span> <span class="n">as_scheme_list</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calc_apply</span><span class="p">(</span><span class="s1">'*'</span><span class="p">,</span> <span class="n">nil</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calc_apply</span><span class="p">(</span><span class="s1">'*'</span><span class="p">,</span> <span class="n">as_scheme_list</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">120</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calc_apply</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="n">as_scheme_list</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">8.0</span>
</pre></div>

<p>The role of <tt class="docutils literal">calc_eval</tt> is to make proper calls to <tt class="docutils literal">calc_apply</tt> by first
computing the value of operand sub-expressions before passing them as arguments
to <tt class="docutils literal">calc_apply</tt>. Thus, <tt class="docutils literal">calc_eval</tt> can accept a nested expression.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="go">(+ (* 3 4) 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calc_eval</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="go">17</span>
</pre></div>

<p>The structure of <tt class="docutils literal">calc_eval</tt> is an example of dispatching on type: the form
of the expression. The first form of expression is a number, which requires no
additional evaluation step. In general, primitive expressions that do not
require an additional evaluation step are called <em>self-evaluating</em>. The only
self-evaluating expressions in our Calculator language are numbers, but a
general programming language might also include strings, boolean values, etc.</p>
<p><strong>Read-eval-print loops.</strong> A typical approach to interacting with an
interpreter is through a read-eval-print loop, or REPL, which is a mode of
interaction that reads an expression, evaluates it, and prints the result for
the user.  The Python interactive session is an example of such a loop.</p>
<p>An implementation of a REPL can be largely independent of the interpreter it
uses. The function <tt class="docutils literal">read_eval_print_loop</tt> below buffers input from the user,
constructs an expression using the language-specific <tt class="docutils literal">scheme_read</tt> function,
then prints the result of applying <tt class="docutils literal">calc_eval</tt> to that expression.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">read_eval_print_loop</span><span class="p">():</span>
<span class="gp">    </span>    <span class="sd">"""Run a read-eval-print loop for calculator."""</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">src</span> <span class="o">=</span> <span class="n">buffer_input</span><span class="p">()</span>
<span class="gp">    </span>        <span class="k">while</span> <span class="n">src</span><span class="o">.</span><span class="n">more_on_line</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">expression</span> <span class="o">=</span> <span class="n">scheme_read</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
<span class="gp">    </span>            <span class="nb">print</span><span class="p">(</span><span class="n">calc_eval</span><span class="p">(</span><span class="n">expression</span><span class="p">))</span>
</pre></div>

<p>This version of <tt class="docutils literal">read_eval_print_loop</tt> contains all of the essential
components of an interactive interface.  An example session would look like:</p>
<pre class="literal-block">
&gt; (* 1 2 3)
6
&gt; (+)
0
&gt; (+ 2 (/ 4 8))
2.5
&gt; (+ 2 2) (* 3 3)
4
9
&gt; (+ 1
     (- 23)
     (* 4 2.5))
-12
</pre>
<p>This loop implementation has no mechanism for termination or error handling.
We can improve the interface by reporting errors to the user. We can also allow
the user to exit the loop by signalling a keyboard interrupt (<tt class="docutils literal"><span class="pre">Control-C</span></tt> on
UNIX) or end-of-file exception (<tt class="docutils literal"><span class="pre">Control-D</span></tt> on UNIX). To enable these
improvements, we place the original suite of the <tt class="docutils literal">while</tt> statement within a
<tt class="docutils literal">try</tt> statement.  The first <tt class="docutils literal">except</tt> clause handles <tt class="docutils literal">SyntaxError</tt> and
<tt class="docutils literal">ValueError</tt> exceptions raised by <tt class="docutils literal">scheme_read</tt> as well as <tt class="docutils literal">TypeError</tt>
and <tt class="docutils literal">ZeroDivisionError</tt> exceptions raised by <tt class="docutils literal">calc_eval</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">read_eval_print_loop</span><span class="p">():</span>
<span class="gp">    </span>    <span class="sd">"""Run a read-eval-print loop for calculator."""</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">    </span>            <span class="n">src</span> <span class="o">=</span> <span class="n">buffer_input</span><span class="p">()</span>
<span class="gp">    </span>            <span class="k">while</span> <span class="n">src</span><span class="o">.</span><span class="n">more_on_line</span><span class="p">:</span>
<span class="gp">    </span>                <span class="n">expression</span> <span class="o">=</span> <span class="n">scheme_read</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
<span class="gp">    </span>                <span class="nb">print</span><span class="p">(</span><span class="n">calc_eval</span><span class="p">(</span><span class="n">expression</span><span class="p">))</span>
<span class="gp">    </span>        <span class="k">except</span> <span class="p">(</span><span class="ne">SyntaxError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">ZeroDivisionError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
<span class="gp">    </span>            <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">':'</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyboardInterrupt</span><span class="p">,</span> <span class="ne">EOFError</span><span class="p">):</span>  <span class="c1"># &lt;Control&gt;-D, etc.</span>
<span class="gp">    </span>            <span class="nb">print</span><span class="p">(</span><span class="s1">'Calculation completed.'</span><span class="p">)</span>
<span class="gp">    </span>            <span class="k">return</span>
</pre></div>

<p>This loop implementation reports errors without exiting the loop.  Rather than
exiting the program on an error, restarting the loop after an error message
lets users revise their expressions. Upon importing the <tt class="docutils literal">readline</tt> module,
users can even recall their previous inputs using the up arrow or
<tt class="docutils literal"><span class="pre">Control-P</span></tt>. The final result provides an informative error reporting
interface:</p>
<pre class="literal-block">
&gt; )
SyntaxError: unexpected token: )
&gt; 2.3.4
ValueError: invalid numeral: 2.3.4
&gt; +
TypeError: + is not a number or call expression
&gt; (/ 5)
TypeError: / requires exactly 2 arguments
&gt; (/ 1 0)
ZeroDivisionError: division by zero
</pre>
<p>As we generalize our interpreter to new languages other than Calculator, we
will see that the <tt class="docutils literal">read_eval_print_loop</tt> is parameterized by a parsing
function, an evaluation function, and the exception types handled by the <tt class="docutils literal">try</tt>
statement.  Beyond these changes, all REPLs can be implemented using the same
structure.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/35-interpreters-for-languages-with-abstraction.html">
  		3.5 Interpreters for Languages with Abstraction
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="interpreters-for-languages-with-abstraction">
<h2>3.5   Interpreters for Languages with Abstraction</h2>
<p>The Calculator language provides a means of combination through nested call
expressions. However, there is no way to define new operators, give names to
values, or express general methods of computation. Calculator does not support
abstraction in any way. As a result, it is not a particularly powerful or
general programming language. We now turn to the task of defining a general
programming language that supports abstraction by binding names to values and
defining new operations.</p>
<p>Unlike the previous section, which presented a complete interpreter as Python
source code, this section takes a descriptive approach. The companion project
asks you to implement the ideas presented here by building a fully functional
Scheme interpreter.</p>
<div class="section" id="structure">
<h3>3.5.1   Structure</h3>
<p>This section describes the general structure of a Scheme interpreter. Completing
that project will produce a working implementation of the interpreter described
here.</p>
<p>An interpreter for Scheme can share much of the same structure as the
Calculator interpreter.  A parser produces an expression that is interpreted by
an evaluator. The evaluation function inspects the form of an expression, and
for call expressions it calls a function to apply a procedure to some
arguments. Much of the difference in evaluators is associated with special
forms, user-defined functions, and implementing the environment model of
computation.</p>
<p><strong>Parsing.</strong> The <a class="reference external" href="../examples/scalc/scheme_reader.py.html">scheme_reader</a> and <a class="reference external" href="../examples/scalc/scheme_tokens.py.html">scheme_tokens</a> modules from the Calculator
interpreter are nearly sufficient to parse any valid Scheme expression.
However, it does not yet support quotation or dotted lists.  A full Scheme
interpreter should be able to parse the following input expression.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">read_line</span><span class="p">(</span><span class="s2">"(car '(1 . 2))"</span><span class="p">)</span>
<span class="go">Pair('car', Pair(Pair('quote', Pair(Pair(1, 2), nil)), nil))</span>
</pre></div>

<p>Your first task in implementing the Scheme interpreter will be to extend
<a class="reference external" href="../examples/scalc/scheme_reader.py.html">scheme_reader</a> to correctly parse dotted lists and quotation.</p>
<p><strong>Evaluation.</strong> Scheme is evaluated one expression at a time. A skeleton
implementation of the evaluator is defined in <tt class="docutils literal">scheme.py</tt> of the companion
project. Each expression returned from <tt class="docutils literal">scheme_read</tt> is passed to the
<tt class="docutils literal">scheme_eval</tt> function, which evaluates an expression <tt class="docutils literal">expr</tt> in the current
environment <tt class="docutils literal">env</tt>.</p>
<p>The <tt class="docutils literal">scheme_eval</tt> function evaluates the different forms of expressions in
Scheme: primitives, special forms, and call expressions.  The form of a
combination in Scheme can be determined by inspecting its first element.  Each
special form has its own evaluation rule.  A simplified implementation of
<tt class="docutils literal">scheme_eval</tt> appears below. Some error checking and special form handling
has been removed in order to focus our discussion. A complete implementation
appears in the companion project.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">scheme_eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Evaluate Scheme expression expr in environment env."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">scheme_symbolp</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">env</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">scheme_atomp</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">expr</span>
<span class="gp">    </span>    <span class="n">first</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">second</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">first</span> <span class="o">==</span> <span class="s2">"lambda"</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">do_lambda_form</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">first</span> <span class="o">==</span> <span class="s2">"define"</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">do_define_form</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="kc">None</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">procedure</span> <span class="o">=</span> <span class="n">scheme_eval</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
<span class="gp">    </span>        <span class="n">args</span> <span class="o">=</span> <span class="n">rest</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">operand</span><span class="p">:</span> <span class="n">scheme_eval</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">scheme_apply</span><span class="p">(</span><span class="n">procedure</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
</pre></div>

<p><strong>Procedure application.</strong> The final case above invokes a second process,
procedure application, that is implemented by the function <tt class="docutils literal">scheme_apply</tt>.
The procedure application process in Scheme is considerably more general than
the <tt class="docutils literal">calc_apply</tt> function in Calculator. It applies two kinds of arguments:
a <tt class="docutils literal">PrimtiveProcedure</tt> or a <tt class="docutils literal">LambdaProcedure</tt>. A <tt class="docutils literal">PrimitiveProcedure</tt> is
implemented in Python; it has an instance attribute <tt class="docutils literal">fn</tt> that is bound to a
Python function. In addition, it may or may not require access to the current
environment. This Python function is called whenever the procedure is applied.</p>
<p>A <tt class="docutils literal">LambdaProcedure</tt> is implemented in Scheme.  It has a <tt class="docutils literal">body</tt> attribute
that is a Scheme expression, evaluated whenever the procedure is applied.
To apply the procedure to a list of arguments, the body expression is evaluated
in a new environment.  To construct this environment, a new frame is added to
the environment, in which the formal parameters of the procedure are bound to
the arguments. The body is evaluated using <tt class="docutils literal">scheme_eval</tt>.</p>
<p><strong>Eval/apply recursion.</strong> The functions that implement the evaluation process,
<tt class="docutils literal">scheme_eval</tt> and <tt class="docutils literal">scheme_apply</tt>, are mutually recursive. Evaluation
requires application whenever a call expression is encountered.  Application
uses evaluation to evaluate operand expressions into arguments, as well as to
evaluate the body of user-defined procedures. The general structure of this
mutually recursive process appears in interpreters quite generally: evaluation
is defined in terms of application and application is defined in terms of
evaluation.</p>
<p>This recursive cycle ends with language primitives. Evaluation has a base case
that is evaluating a primitive expression. Some special forms also constitute
base cases without recursive calls. Function application has a base case that
is applying a primitive procedure. This mutually recursive structure, between
an eval function that processes expression forms and an apply function that
processes functions and their arguments, constitutes the essence of the
evaluation process.</p>
</div>
<div class="section" id="environments">
<h3>3.5.2   Environments</h3>
<p>Now that we have described the structure of our Scheme interpreter, we turn to
implementing the <tt class="docutils literal">Frame</tt> class that forms environments. Each <tt class="docutils literal">Frame</tt> instance
represents an environment in which symbols are bound to values. A frame has a
dictionary of <tt class="docutils literal">bindings</tt>, as well as a <tt class="docutils literal">parent</tt> frame that is <tt class="docutils literal">None</tt> for
the global frame.</p>
<p>Bindings are not accessed directly, but instead through two <tt class="docutils literal">Frame</tt>
methods: <tt class="docutils literal">lookup</tt> and <tt class="docutils literal">define</tt>. The first implements the look-up procedure
of the environment model of computation described in Chapter 1. A symbol is
matched against the <tt class="docutils literal">bindings</tt> of the current frame.  If it is found, the
value to which it is bound is returned. If it is not found, look-up proceeds to
the <tt class="docutils literal">parent</tt> frame.  On the other hand, the <tt class="docutils literal">define</tt> method always binds a
symbol to a value in the current frame.</p>
<p>The implementation of <tt class="docutils literal">lookup</tt> and the use of <tt class="docutils literal">define</tt> are left as
exercises.  As an illustration of their use, consider the following example
Scheme program:</p>
<pre id="Coding-JS-factorial-def">
(define (factorial n)
  (if (= n 0) 1 (* n (factorial (- n 1)))))
</pre>
<script>$c.prompt("Coding-JS-factorial-def", [], "scheme");</script>
<pre id="Coding-JS-factorial-eg">
(factorial 5)
</pre>
<script>$c.prompt("Coding-JS-factorial-eg", ["Coding-JS-factorial-def"], "scheme");</script>
<p>The first input expression is a <tt class="docutils literal">define</tt> special form, evaluated by the
<tt class="docutils literal">do_define_form</tt> Python function.  Defining a function has several steps:</p>
<ol class="arabic simple">
<li>Check the format of the expression to ensure that it is a well-formed Scheme
list with at least two elements following the keyword <tt class="docutils literal">define</tt>.</li>
<li>Analyze the first element, in this case a <tt class="docutils literal">Pair</tt>, to find the function
name <tt class="docutils literal">factorial</tt> and formal parameter list <tt class="docutils literal">(n)</tt>.</li>
<li>Create a <tt class="docutils literal">LambdaProcedure</tt> with the supplied formal parameters, body,
and parent environment.</li>
<li>Bind the symbol <tt class="docutils literal">factorial</tt> to this function, in the first frame of the
current environment. In this case, the environment consists only of the
global frame.</li>
</ol>
<p>The second input is a call expression. The <tt class="docutils literal">procedure</tt> passed to <tt class="docutils literal">scheme_apply</tt>
is the <tt class="docutils literal">LambdaProcedure</tt> just created and bound to the symbol <tt class="docutils literal">factorial</tt>.
The <tt class="docutils literal">args</tt> passed is a one-element Scheme list <tt class="docutils literal">(5)</tt>. To apply the
procedure, a new frame is created that extends the global frame (the parent
environment of the <tt class="docutils literal">factorial</tt> procedure).  In this frame, the symbol <tt class="docutils literal">n</tt>
is bound to the value 5. Then, the body of <tt class="docutils literal">factorial</tt> is evaluated in
that environment, and its value is returned.</p>
</div>
<div class="section" id="data-as-programs">
<h3>3.5.3   Data as Programs</h3>
<p>In thinking about a program that evaluates Scheme expressions, an analogy
might be helpful. One operational view of the meaning of a program is that a
program is a description of an abstract machine. For example, consider again
this procedure to compute factorials:</p>
<pre id="Coding-JS-factorial-def-2">
(define (factorial n)
  (if (= n 0) 1 (* n (factorial (- n 1)))))
</pre>
<script>$c.prompt("Coding-JS-factorial-def-2", [], "scheme");</script>
<p>We could express an equivalent program in Python as well, using a conditional
expression.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

<p>We may regard this program as the description of a machine containing parts
that decrement, multiply, and test for equality, together with a two-position
switch and another factorial machine. (The factorial machine is infinite
because it contains another factorial machine within it.) The figure below is a
flow diagram for the factorial machine, showing how the parts are wired
together.</p>
<div class="figure">
<img alt="" src="../img/factorial_machine.png">
</div>
<p>In a similar way, we can regard the Scheme interpreter as a very special machine
that takes as input a description of a machine. Given this input, the
interpreter configures itself to emulate the machine described. For example, if
we feed our evaluator the definition of factorial the evaluator will be able to
compute factorials.</p>
<p>From this perspective, our Scheme interpreter is seen to be a universal machine.
It mimics other machines when these are described as Scheme programs.
It acts as a bridge between the data objects that are manipulated by our
programming language and the programming language itself. Image that a user
types a Scheme expression into our running Scheme interpreter. From the perspective
of the user, an input expression such as <tt class="docutils literal">(+ 2 2)</tt> is an expression in the
programming language, which the interpreter should evaluate. From the
perspective of the Scheme interpreter, however, the expression is simply a
sentence of words that is to be manipulated according to a well-defined set of
rules.</p>
<p>That the user's programs are the interpreter's data need not be a source of
confusion. In fact, it is sometimes convenient to ignore this distinction, and
to give the user the ability to explicitly evaluate a data object as an
expression. In Scheme, we use this facility whenever employing the <tt class="docutils literal">run</tt>
procedure.  Similar functions exist in Python: the <tt class="docutils literal">eval</tt> function will
evaluate a Python expression and the <tt class="docutils literal">exec</tt> function will execute a Python
statement. Thus,</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">eval</span><span class="p">(</span><span class="s1">'2+2'</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>

<p>and</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span>
<span class="go">4</span>
</pre></div>

<p>both return the same result. Evaluating expressions that are constructed as a
part of execution is a common and powerful feature in dynamic programming
languages. In few languages is this practice as common as in Scheme, but the
ability to construct and evaluate expressions during the course of execution of
a program can prove to be a valuable tool for any programmer.</p>
</div>
<div class="section" id="macros">
<h3>3.5.4   Macros</h3>
<p>Scheme combinations are represented as Scheme lists. The expression <tt class="docutils literal">(+ 2 x)</tt>
is a three-element list containing the symbol <tt class="docutils literal">+</tt>, the number 2, and the
symbol <tt class="docutils literal">x</tt>.  Likewise, the expression <tt class="docutils literal">(map abs <span class="pre">'(-1</span> <span class="pre">-2))</span></tt> is a
three-element list containing the symbol <tt class="docutils literal">map</tt>, the symbol <tt class="docutils literal">abs</tt>, and a list
containing -1 and -2.</p>
<p>Because expressions in the language are structured data, it is convenient to
write Scheme expressions that build other Scheme expressions. Scheme programs
are just lists of expressions, and so it is possible to write programs that
output and even execute other programs.</p>
<p>The fact that expressions are lists allows us to use list manipulation
procedures, such as <tt class="docutils literal">list</tt>, <tt class="docutils literal">cons</tt>, <tt class="docutils literal">car</tt>, and <tt class="docutils literal">cdr</tt>, to construct
expressions. The built-in <tt class="docutils literal">eval</tt> procedure allows a constructed expression to
be evaluated.</p>
<pre id="Coding-JS-code-as-data-1">
(cons '+ (list 1 2))
</pre>
<script>$c.prompt("Coding-JS-code-as-data-1", [], "scheme");</script>
<pre id="Coding-JS-code-as-data-2">
(eval (cons '+ (list 1 2)))
</pre>
<script>$c.prompt("Coding-JS-code-as-data-2", [], "scheme");</script>
<p>Macros are procedures that take expressions as input and return Scheme
expressions as output. Macros exist in many programming languages but are
particularly powerful in Scheme and other Lisp dialects because Scheme
expressions are lists, and Scheme has good built-in procedures for manipulating
lists. In Scheme, there are several different built-in special forms related to
macros, but this text will focus on just one: <tt class="docutils literal"><span class="pre">define-macro</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">define-macro</span></tt> special form is similar to the <tt class="docutils literal">define</tt> special form used
to create user-defined procedures.</p>
<p><tt class="docutils literal"><span class="pre">(define-macro</span> (twice f) (list 'begin f f))</tt></p>
<p>Evaluating this <tt class="docutils literal"><span class="pre">define-macro</span></tt> expression creates a new macro and binds it to
the name <tt class="docutils literal">twice</tt> in the first frame of the current environment. A macro is
called like a procedure using a call expression, but the evaluation procedure
for macro call expressions is different from the regular procedure for call
expressions.</p>
<p>To evaluate a macro call expression, such as <tt class="docutils literal">(twice (print 2))</tt>, Scheme does
the following:</p>
<ol class="arabic simple">
<li>Evaluate the operator sub-expression, which evaluates to a macro.</li>
<li>Apply the macro procedure on the operands <em>without</em> evaluating the operands first.</li>
<li>Evaluate the expression returned from the macro procedure.</li>
</ol>
<p>For example, calling <tt class="docutils literal">(twice (print 2))</tt> will pass the expression
<tt class="docutils literal">(print 2)</tt>,
which is a two-element list containing the symbol <tt class="docutils literal">print</tt> and the number 2, as
an argument to <tt class="docutils literal">twice</tt>. Evaluating the body of <tt class="docutils literal">twice</tt> in an environment in
which <tt class="docutils literal">f</tt> is bound to <tt class="docutils literal">(print 2)</tt> creates the expression
<tt class="docutils literal">(begin (print 2) (print 2))</tt>, which is then evaluated. Evaluating this output
expression displays 2 twice. Hence, this macro evaluates its operand twice.</p>
<p><tt class="docutils literal"><span class="pre">(twice-macro</span> (print 2))</tt></p>
<p><tt class="docutils literal">2</tt></p>
<p><tt class="docutils literal">2</tt></p>
</div>
<div class="section" id="quasiquotation">
<h3>3.5.5   Quasiquotation</h3>
<p>In Scheme, a <em>quote</em> prevents an expression from being evaluated. It's possible
to use the symbol <tt class="docutils literal">quote</tt> or its syntactic abbreviation, an apostrophe. Both
of the expressions below evaluate to the three-element list <tt class="docutils literal">(+ x y)</tt>.</p>
<p><tt class="docutils literal">(quote (+ x y))</tt></p>
<p><tt class="docutils literal">'(+ x y)</tt></p>
<p>Similarly, a <em>quasiquote</em>, denoted using a backtick symbol, prevents an expression
from being evaluated. However, parts of that expression can be <em>unquoted</em>,
denoted using a comma, and those unquoted parts are evaluated. Suppose <tt class="docutils literal">b</tt> is
bound to 10.</p>
<p><tt class="docutils literal">(define b 10)</tt></p>
<p>Quoting or quasiquoting the expression <tt class="docutils literal">(+ a b)</tt> will evaluate to this
three-element list, which contains the symbols <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt>.</p>
<p><tt class="docutils literal">'(+ a b)</tt></p>
<p><tt class="docutils literal">`(+ a b)</tt></p>
<p>In the final example below, <tt class="docutils literal">b</tt> is unquoted and therefore evaluated, while the whole list remains quoted, and so no addition is performed. Instead, the expression evaluates to the list <tt class="docutils literal">(+ a 10)</tt>.</p>
<p><tt class="docutils literal">`(+ ,b c)</tt></p>
<p>With quasiquotes and unquotes, it is often the case that a macro definition
requires less work to express.  For example, we can simplify <tt class="docutils literal"><span class="pre">twice-macro</span></tt>
from the previous section as follows:</p>
<p><tt class="docutils literal"><span class="pre">(define-macro</span> (twice f) `(begin ,f ,f))</tt></p>
</div>
</div>
      </div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
	<h1>Chapter 4: Data Processing</h1>
  <div class="section" id="introduction">
<h2>4.1   Introduction</h2>
<p>Modern computers can process vast amounts of data representing many aspects of
the world.  From these big data sets, we can learn about human behavior in
unprecedented ways: how language is used, what photos are taken, what topics are
discussed, and how people engage with their surroundings.  To process large data
sets efficiently, programs are organized into pipelines of manipulations on
sequential streams of data. In this chapter, we consider a suite of techniques
process and manipulate sequential data streams efficiently.</p>
<p>In Chapter 2, we introduced a sequence interface, implemented in Python by
built-in data types such as <tt class="docutils literal">list</tt> and <tt class="docutils literal">range</tt>. In this chapter, we extend
the concept of sequential data to include collections that have unbounded or
even infinite size. Two mathematical examples of infinite sequences are the
positive integers and the Fibonacci numbers. Sequential data sets of unbounded
length also appear in other computational domains. For instance, the sequence
of telephone calls sent through a cell tower, the sequence of mouse movements
made by a computer user, and the sequence of acceleration measurements from
sensors on an aircraft all continue to grow as the world evolves.</p>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/42-implicit-sequences.html">
  		4.2 Implicit Sequences
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="implicit-sequences">
<h2>4.2   Implicit Sequences</h2>
<p>A sequence can be represented without each element being stored explicitly
in the memory of the computer. That is, we can construct an object that provides
access to all of the elements of some sequential dataset without computing the
value of each element in advance. Instead, we compute elements on demand.</p>
<p>An example of this idea arises in the <tt class="docutils literal">range</tt> container type introduced in
Chapter 2. A <tt class="docutils literal">range</tt> represents a consecutive, bounded sequence of integers.
However, it is not the case that each element of that sequence is represented
explicitly in memory.  Instead, when an element is requested from a <tt class="docutils literal">range</tt>,
it is computed. Hence, we can represent very large ranges of integers without
using large blocks of memory. Only the end points of the range are stored as
part of the <tt class="docutils literal">range</tt> object.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">1000000000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="mi">45006230</span><span class="p">]</span>
<span class="go">45016230</span>
</pre></div>

<p>In this example, not all 999,990,000 integers in this range are stored when the
range instance is constructed.  Instead, the range object adds the first element
10,000 to the index 45,006,230 to produce the element 45,016,230. Computing
values on demand, rather than retrieving them from an existing representation,
is an example of <em>lazy</em> computation. In computer science, lazy computation
describes any program that delays the computation of a value until that value is
needed.</p>
<div class="section" id="iterators">
<h3>4.2.1   Iterators</h3>
<p><strong>Note:</strong> This content on iterators and generators now also appears in Chapter 2.</p>
<p>Python and many other programming languages provide a unified way to process
elements of a container value sequentially, called an iterator.  An <em>iterator</em>
is an object that provides sequential access to values, one by one.</p>
<p>The iterator abstraction has two components: a mechanism for retrieving the next
element in the sequence being processed and a mechanism for signaling that the
end of the sequence has been reached and no further elements remain. For any
container, such as a list or range, an iterator can be obtained by calling the
built-in <tt class="docutils literal">iter</tt> function. The contents of the iterator can be accessed by
calling the built-in <tt class="docutils literal">next</tt> function.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">primes</span><span class="p">)</span>
<span class="go">&lt;class 'list'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">primes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">&lt;class 'list_iterator'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>

<p>Python signals that there are no more values available by raising a
<tt class="docutils literal">StopIteration</tt> exception when <tt class="docutils literal">next</tt> is called. This exception can be
handled using a <tt class="docutils literal">try</tt> statement.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">    </span>    <span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="gp">    </span><span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'No more values'</span><span class="p">)</span>
<span class="go">No more values</span>
</pre></div>

<p>An iterator maintains local state to represent its position in a sequence. Each
time <tt class="docutils literal">next</tt> is called, that position advances. Two separate iterators can
track two different positions in the same sequence. However, two names for the
same iterator will share a position because they share the same value.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># 1st iterator over r</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># 2nd iterator over r</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">t</span>        <span class="c1"># Alternate name for the 2nd iterator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>

<p>Advancing the second iterator does not affect the first. Since the last value
returned from the first iterator was 4, it is positioned to return 5 next. On
the other hand, the second iterator is positioned to return 7 next.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>

<p>Calling <tt class="docutils literal">iter</tt> on an iterator will return that iterator, not a copy. This
behavior is included in Python so that a programmer can call <tt class="docutils literal">iter</tt> on a
value to get an iterator without having to worry about whether it is an iterator
or a container.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># Another alterante name for the 2nd iterator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>

<p>The usefulness of iterators is derived from the fact that the underlying
series of data for an iterator may not be represented explicitly in memory.
An iterator provides a mechanism for considering each of a series of values in
turn, but all of those elements do not need to be stored simultaneously.
Instead, when the next element is requested from an iterator, that element may
be computed on demand instead of being retrieved from an existing memory
source.</p>
<p>Ranges are able to compute the elements of a sequence lazily because the
sequence represented is uniform, and any element is easy to compute from the
starting and ending bounds of the range. Iterators allow for lazy generation of
a much broader class of underlying sequential datasets because they do not need
to provide access to arbitrary elements of the underlying series. Instead,
iterators are only required to compute the next element of the series, in order,
each time another element is requested. While not as flexible as <em>random access</em>
(accessing arbitrary elements of a sequence in any order), <em>sequential access</em>
to sequential data is often sufficient for data processing applications.</p>
</div>
<div class="section" id="iterables">
<h3>4.2.2   Iterables</h3>
<p>Any value that can produce iterators is called an <em>iterable</em> value. In Python,
an iterable value is anything that can be passed to the built-in <tt class="docutils literal">iter</tt>
function. Iterables include sequence values such as strings and tuples, as well
as other containers such as sets and dictionaries. Iterators are also iterables
because they can be passed to the <tt class="docutils literal">iter</tt> function.</p>
<p>Even unordered collections such as dictionaries must define an ordering over
their contents when they produce iterators. Dictionaries and sets are unordered
because the programmer has no control over the order of iteration, but Python
does guarantee certain properties about their order in its specification.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'one'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'two'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'three'</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{'one': 1, 'three': 3, 'two': 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="go">'one'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="go">'three'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>

<p>If a dictionary changes in structure because a key is added or removed, then all
iterators become invalid, and future iterators may exhibit arbitrary changes to
the order of their contents. On the other hand, changing the value of an
existing key does not invalidate iterators or change the order of their
contents.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'two'</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="gp">    </span><span class="o">   </span>
<span class="go">RuntimeError: dictionary changed size during iteration</span>
<span class="gt">Traceback (most recent call last):</span>
</pre></div>

</div>
<div class="section" id="built-in-iterators">
<h3>4.2.3   Built-in Iterators</h3>
<p>Several built-in functions take as arguments iterable values and return
iterators. These functions are used extensively for lazy sequence processing.</p>
<p>The <tt class="docutils literal">map</tt> function is lazy: calling it does not perform the computation
required to compute elements of its result. Instead, an iterator object is
created that can return results if queried using <tt class="docutils literal">next</tt>. We can observe this
fact in the following example, in which the call to <tt class="docutils literal">print</tt> is delayed until
the corresponding element is requested from the <tt class="docutils literal">doubled</tt> iterator.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">double_and_print</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'***'</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">'=&gt;'</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="s1">'***'</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doubled</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">double_and_print</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>  <span class="c1"># double_and_print not yet called</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">doubled</span><span class="p">)</span>                       <span class="c1"># double_and_print called once</span>
<span class="go">*** 3 =&gt; 6 ***</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">doubled</span><span class="p">)</span>                       <span class="c1"># double_and_print called again</span>
<span class="go">*** 4 =&gt; 8 ***</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">doubled</span><span class="p">)</span>                       <span class="c1"># double_and_print called twice more</span>
<span class="go">*** 5 =&gt; 10 ***</span>
<span class="go">*** 6 =&gt; 12 ***</span>
<span class="go">[10, 12]</span>
</pre></div>

<p>The <tt class="docutils literal">filter</tt> function returns an iterator over a subset of the values in
another iterable. The <tt class="docutils literal">zip</tt> function returns an iterator over tuples of values
that combine one value from each of multiple iterables.</p>
</div>
<div class="section" id="for-statements">
<h3>4.2.4   For Statements</h3>
<p>The <tt class="docutils literal">for</tt> statement in Python operates on iterators. Objects are <em>iterable</em>
(an interface) if they have an <tt class="docutils literal">__iter__</tt> method that returns an <em>iterator</em>.
Iterable objects can be the value of the <tt class="docutils literal">&lt;expression&gt;</tt> in the header of a
<tt class="docutils literal">for</tt> statement:</p>
<pre class="literal-block">
for &lt;name&gt; in &lt;expression&gt;:
    &lt;suite&gt;
</pre>
<p>To execute a <tt class="docutils literal">for</tt> statement, Python evaluates the header <tt class="docutils literal">&lt;expression&gt;</tt>,
which must yield an iterable value.  Then, the <tt class="docutils literal">iter</tt> function is applied to
that value. Until a <tt class="docutils literal">StopIteration</tt> exception is raised, Python repeatedly
calls <tt class="docutils literal">next</tt> on that iterator and binds the result to the <tt class="docutils literal">&lt;name&gt;</tt> in the
<tt class="docutils literal">for</tt> statement. Then, it executes the <tt class="docutils literal">&lt;suite&gt;</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
</pre></div>

<p>In the above example, the <tt class="docutils literal">for</tt> statement implicitly calls <tt class="docutils literal">iter(counts)</tt>,
which returns an iterator over its contents. The <tt class="docutils literal">for</tt> statement then calls
<tt class="docutils literal">next</tt> on that iterator repeatedly, and assigns the returned value to <tt class="docutils literal">item</tt>
each time. This process continues until the iterator raises a <tt class="docutils literal">StopIteration</tt>
exception, at which point execution of the <tt class="docutils literal">for</tt> statement concludes.</p>
<p>With our knowledge of iterators, we can implement the execution rule of a
<tt class="docutils literal">for</tt> statement in terms of <tt class="docutils literal">while</tt>, assignment, and <tt class="docutils literal">try</tt> statements.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">item</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
<span class="gp">    </span>        <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="gp">    </span><span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
<span class="gp">    </span>    <span class="k">pass</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
</pre></div>

<p>Above, the iterator returned by calling <tt class="docutils literal">iter</tt> on <tt class="docutils literal">counts</tt> is bound to a
name <tt class="docutils literal">items</tt> so that it can be queried for each element in turn.  The handling
clause for the <tt class="docutils literal">StopIteration</tt> exception does nothing, but handling the
exception provides a control mechanism for exiting the <tt class="docutils literal">while</tt> loop.</p>
</div>
<div class="section" id="generators">
<h3>4.2.5   Generators</h3>
<p>Generators allow us to define iterations over arbitrary sequences, even infinite
sequences, by leveraging the features of the Python interpreter.</p>
<p>A <em>generator</em> is an iterator returned by a special class of function called a
<em>generator function</em>. Generator functions are distinguished from regular
functions in that rather than containing <tt class="docutils literal">return</tt> statements in their body,
they use <tt class="docutils literal">yield</tt> statements to return elements of a series.</p>
<p>Generators do not use attributes of an object to track their progress through a
series. Instead, they control the execution of the generator function, which
runs until the next <tt class="docutils literal">yield</tt> statement is executed each time <tt class="docutils literal">next</tt> is called
on the generator. For example, the <tt class="docutils literal">letters_generator</tt> function below returns a generator over the letters a, b, c, and then d.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">letters_generator</span><span class="p">():</span>
<span class="gp">    </span>    <span class="n">current</span> <span class="o">=</span> <span class="s1">'a'</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="n">current</span> <span class="o">&lt;=</span> <span class="s1">'d'</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">yield</span> <span class="n">current</span>
<span class="gp">    </span>        <span class="n">current</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">current</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">letters_generator</span><span class="p">():</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
<span class="go">a</span>
<span class="go">b</span>
<span class="go">c</span>
<span class="go">d</span>
</pre></div>

<p>The <tt class="docutils literal">yield</tt> statement indicates that we are defining a generator function,
rather than a regular function.  When called, a generator function doesn't
return a particular yielded value, but instead a <tt class="docutils literal">generator</tt> (which is a type
of iterator) that itself can return the yielded values. Calling <tt class="docutils literal">next</tt> on the
generator continues execution of the generator function from wherever it left
off previously until another <tt class="docutils literal">yield</tt> statement is executed.</p>
<p>The first time <tt class="docutils literal">next</tt> is called, the program executes statements from
the body of the <tt class="docutils literal">letters_generator</tt> function until it encounters the
<tt class="docutils literal">yield</tt> statement. Then, it pauses and returns the value of <tt class="docutils literal">current</tt>.
<tt class="docutils literal">yield</tt> statements do not destroy the newly created environment; they
preserve it for later. When <tt class="docutils literal">next</tt> is called again, execution resumes
where it left off. The values of <tt class="docutils literal">current</tt> and of any other bound names in
the scope of <tt class="docutils literal">letters_generator</tt> are preserved across subsequent calls to
<tt class="docutils literal">next</tt>.</p>
<p>We can walk through the generator by manually calling <tt class="docutils literal">next()</tt>:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span> <span class="o">=</span> <span class="n">letters_generator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="go">&lt;class 'generator'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="go">'a'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="go">'b'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="go">'c'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="go">'d'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>
</pre></div>

<p>The generator does not start executing any of the body statements of its
generator function until the first time <tt class="docutils literal">next</tt> is called. The generator
raises a <tt class="docutils literal">StopIteration</tt> exception whenever its generator function returns.</p>
</div>
<div class="section" id="python-streams">
<h3>4.2.6   Python Streams</h3>
<p><em>Streams</em> offer another way to represent sequential data implicitly.  A stream
is a lazily computed linked list.  Like the <tt class="docutils literal">Link</tt> class from Chapter 2,
a <tt class="docutils literal">Stream</tt> instance responds to requests for its <tt class="docutils literal">first</tt> element and the
<tt class="docutils literal">rest</tt> of the stream. Like an <tt class="docutils literal">Link</tt>, the <tt class="docutils literal">rest</tt> of a <tt class="docutils literal">Stream</tt> is
itself a <tt class="docutils literal">Stream</tt>.  Unlike an <tt class="docutils literal">Link</tt>, the <tt class="docutils literal">rest</tt> of a stream is only
computed when it is looked up, rather than being stored in advance. That is,
the <tt class="docutils literal">rest</tt> of a stream is computed lazily.</p>
<p>To achieve this lazy evaluation, a stream stores a function that computes the
rest of the stream.  Whenever this function is called, its returned value is
cached as part of the stream in an attribute called <tt class="docutils literal">_rest</tt>, named with an
underscore to indicate that it should not be accessed directly.</p>
<p>The accessible attribute <tt class="docutils literal">rest</tt> is a property method that returns the rest of
the stream, computing it if necessary.  With this design, a stream stores <em>how
to compute</em> the rest of the stream, rather than always storing the rest
explicitly.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Stream</span><span class="p">:</span>
<span class="gp">    </span>    <span class="sd">"""A lazily computed linked list."""</span>
<span class="gp">    </span>    <span class="k">class</span> <span class="nc">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>            <span class="k">return</span> <span class="s1">'Stream.empty'</span>
<span class="gp">    </span>    <span class="n">empty</span> <span class="o">=</span> <span class="n">empty</span><span class="p">()</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">compute_rest</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">empty</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">compute_rest</span><span class="p">),</span> <span class="s1">'compute_rest must be callable.'</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span>
<span class="gp">    </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_rest</span> <span class="o">=</span> <span class="n">compute_rest</span>
<span class="gp">    </span>    <span class="nd">@property</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">rest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>        <span class="sd">"""Return the rest of the stream, computing it if necessary."""</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_rest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">    </span>            <span class="bp">self</span><span class="o">.</span><span class="n">_rest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_rest</span><span class="p">()</span>
<span class="gp">    </span>            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_rest</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rest</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="s1">'Stream(</span><span class="si">{0}</span><span class="s1">, &lt;...&gt;)'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">))</span>
</pre></div>

<p>A linked list is defined using a nested expression.  For example,
we can create an <tt class="docutils literal">Link</tt> that represents the elements 1 then 5 as
follows:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">Link</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">Link</span><span class="p">(</span><span class="mi">9</span><span class="p">)))</span>
</pre></div>

<p>Likewise, we can create a <tt class="docutils literal">Stream</tt> representing the same series.  The
<tt class="docutils literal">Stream</tt> does not actually compute the second element 5 until the rest of the
stream is requested. We achieve this effect by creating anonymous functions.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">Stream</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">Stream</span><span class="p">(</span><span class="mi">9</span><span class="p">)))</span>
</pre></div>

<p>Here, 1 is the first element of the stream, and the <tt class="docutils literal">lambda</tt> expression
that follows returns a function for computing the rest of the stream.</p>
<p>Accessing the elements of linked list <tt class="docutils literal">r</tt> and stream <tt class="docutils literal">s</tt> proceed
similarly.  However, while 5 is stored within <tt class="docutils literal">r</tt>, it is computed on
demand for <tt class="docutils literal">s</tt> via addition, the first time that it is requested.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">first</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">first</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">first</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">first</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">rest</span>
<span class="go">Link(5, Link(9))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">rest</span>
<span class="go">Stream(5, &lt;...&gt;)</span>
</pre></div>

<p>While the <tt class="docutils literal">rest</tt> of <tt class="docutils literal">r</tt> is a two-element linked list, the <tt class="docutils literal">rest</tt> of
<tt class="docutils literal">s</tt> includes a function to compute the rest; the fact that it will return the
empty stream may not yet have been discovered.</p>
<p>When a <tt class="docutils literal">Stream</tt> instance is constructed, the field <tt class="docutils literal">self._rest</tt> is <tt class="docutils literal">None</tt>,
signifying that the rest of the <tt class="docutils literal">Stream</tt> has not yet been computed. When the
<tt class="docutils literal">rest</tt> attribute is requested via a dot expression, the <tt class="docutils literal">rest</tt> property
method is invoked, which triggers computation with <tt class="docutils literal">self._rest =
self._compute_rest()</tt>.  Because of the caching mechanism within a <tt class="docutils literal">Stream</tt>,
the <tt class="docutils literal">compute_rest</tt> function is only ever called once, then discarded.</p>
<p>The essential properties of a <tt class="docutils literal">compute_rest</tt> function are that it takes no
arguments, and it returns a <tt class="docutils literal">Stream</tt> or <tt class="docutils literal">Stream.empty</tt>.</p>
<p>Lazy evaluation gives us the ability to represent infinite sequential datasets
using streams. For example, we can represent increasing integers, starting at
any <tt class="docutils literal">first</tt> value.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">integer_stream</span><span class="p">(</span><span class="n">first</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">compute_rest</span><span class="p">():</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">integer_stream</span><span class="p">(</span><span class="n">first</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">Stream</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">compute_rest</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">positives</span> <span class="o">=</span> <span class="n">integer_stream</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">positives</span>
<span class="go">Stream(1, &lt;...&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">positives</span><span class="o">.</span><span class="n">first</span>
<span class="go">1</span>
</pre></div>

<p>When <tt class="docutils literal">integer_stream</tt> is called for the first time, it returns a stream whose
<tt class="docutils literal">first</tt> is the first integer in the sequence. However, <tt class="docutils literal">integer_stream</tt> is
actually recursive because this stream's <tt class="docutils literal">compute_rest</tt> calls
<tt class="docutils literal">integer_stream</tt> again, with an incremented argument. We say that
<tt class="docutils literal">integer_stream</tt>  is lazy because the recursive call to <tt class="docutils literal">integer_stream</tt> is
only made whenever the <tt class="docutils literal">rest</tt> of an integer stream is requested.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">positives</span><span class="o">.</span><span class="n">first</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">positives</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">first</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">positives</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">rest</span>
<span class="go">Stream(3, &lt;...&gt;)</span>
</pre></div>

<p>The same higher-order functions that manipulate sequences -- <tt class="docutils literal">map</tt> and
<tt class="docutils literal">filter</tt> -- also apply to streams, although their implementations must change
to apply their argument functions lazily.  The function <tt class="docutils literal">map_stream</tt> maps a
function over a stream, which produces a new stream.  The locally defined
<tt class="docutils literal">compute_rest</tt> function ensures that the function will be mapped onto the
rest of the stream whenever the rest is computed.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">map_stream</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">Stream</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">s</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">compute_rest</span><span class="p">():</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">map_stream</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">Stream</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">),</span> <span class="n">compute_rest</span><span class="p">)</span>
</pre></div>

<p>A stream can be filtered by defining a <tt class="docutils literal">compute_rest</tt> function that applies
the filter function to the rest of the stream.  If the filter function rejects
the first element of the stream, the rest is computed immediately.  Because
<tt class="docutils literal">filter_stream</tt> is recursive, the rest may be computed multiple times until a
valid <tt class="docutils literal">first</tt> element is found.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">filter_stream</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">Stream</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">s</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">compute_rest</span><span class="p">():</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">filter_stream</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">fn</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Stream</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">compute_rest</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">compute_rest</span><span class="p">()</span>
</pre></div>

<p>The <tt class="docutils literal">map_stream</tt> and <tt class="docutils literal">filter_stream</tt> functions exhibit a common pattern in
stream processing: a locally defined <tt class="docutils literal">compute_rest</tt> function recursively
applies a processing function to the rest of the stream whenever the rest is
computed.</p>
<p>To inspect the contents of a stream, we can coerce up to the first <tt class="docutils literal">k</tt>
elements to a Python <tt class="docutils literal">list</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">first_k_as_list</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">    </span>    <span class="n">first_k</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">    </span>    <span class="k">while</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Stream</span><span class="o">.</span><span class="n">empty</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">    </span>        <span class="n">first_k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
<span class="gp">    </span>        <span class="n">s</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">rest</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">first_k</span>
</pre></div>

<p>These convenience functions allow us to verify our <tt class="docutils literal">map_stream</tt>
implementation with a simple example that squares the integers from 3 to
7.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">integer_stream</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">Stream(3, &lt;...&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">map_stream</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">Stream(9, &lt;...&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">first_k_as_list</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">[9, 16, 25, 36, 49]</span>
</pre></div>

<p>We can use our <tt class="docutils literal">filter_stream</tt> function to define a stream of prime numbers
using the sieve of Eratosthenes, which filters a stream of integers to remove
all numbers that are multiples of its first element.  By successively filtering
with each prime, all composite numbers are removed from the stream.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">primes</span><span class="p">(</span><span class="n">pos_stream</span><span class="p">):</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">not_divible</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="n">pos_stream</span><span class="o">.</span><span class="n">first</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="gp">    </span>    <span class="k">def</span> <span class="nf">compute_rest</span><span class="p">():</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">primes</span><span class="p">(</span><span class="n">filter_stream</span><span class="p">(</span><span class="n">not_divible</span><span class="p">,</span> <span class="n">pos_stream</span><span class="o">.</span><span class="n">rest</span><span class="p">))</span>
<span class="gp">    </span>    <span class="k">return</span> <span class="n">Stream</span><span class="p">(</span><span class="n">pos_stream</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">compute_rest</span><span class="p">)</span>
</pre></div>

<p>By truncating the <tt class="docutils literal">primes</tt> stream, we can enumerate any prefix of the prime
numbers.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prime_numbers</span> <span class="o">=</span> <span class="n">primes</span><span class="p">(</span><span class="n">integer_stream</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">first_k_as_list</span><span class="p">(</span><span class="n">prime_numbers</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">[2, 3, 5, 7, 11, 13, 17]</span>
</pre></div>

<p>Streams contrast with iterators in that they can be passed to pure functions
multiple times and yield the same result each time.  The primes stream is not
"used up" by converting it to a list.  That is, the <tt class="docutils literal">first</tt> element of
<tt class="docutils literal">prime_numbers</tt> is still 2 after converting the prefix of the stream to a
list.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prime_numbers</span><span class="o">.</span><span class="n">first</span>
<span class="go">2</span>
</pre></div>

<p>Just as linked lists provide a simple implementation of the sequence
abstraction, streams provide a simple, functional, recursive data structure
that implements lazy evaluation through the use of higher-order functions.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/43-declarative-programming.html">
  		4.3 Declarative Programming
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="declarative-programming">
<h2>4.3   Declarative Programming</h2>
<p>In addition to streams, data values are often stored in large repositories
called databases.  A database consists of a data store containing the data
values along with an interface for retrieving and transforming those values.
Each value stored in a database is called a <em>record</em>. Records with similar
structure are grouped into tables. Records are retrieved and transformed using
queries, which are statements in a query language.  By far the most ubiquitous
query language in use today is called Structured Query Language or SQL
(pronounced "sequel").</p>
<p>SQL is an example of a declarative programming language. Statements do not
describe computations directly, but instead describe the desired result of
some computation.  It is the role of the <em>query interpreter</em> of the database
system to design and perform a computational process to produce such a result.</p>
<p>This interaction differs substantially from the procedural programming paradigm
of Python or Scheme. In Python, computational processes are described directly
by the programmer. A declarative language abstracts away procedural details,
instead focusing on the form of the result.</p>
<div class="section" id="tables">
<h3>4.3.1   Tables</h3>
<p>The SQL language is standardized, but most database systems implement some
custom variant of the language that is endowed with proprietary features. In
this text, we will describe a small subset of SQL as it is implemented in
<a class="reference external" href="http://sqlite.org">Sqlite</a>. You can follow along by <a class="reference external" href="http://sqlite.org/download.html">downloading Sqlite</a> or by using this
<a class="reference external" href="http://kripken.github.io/sql.js/GUI/">online SQL interpreter</a>.</p>
<p>A table, also called a <em>relation</em>, has a fixed number of named and typed
columns. Each row of a table represents a data record and has one value for
each column. For example, a table of cities might have columns <tt class="docutils literal">latitude</tt>
<tt class="docutils literal">longitude</tt> that both hold numeric values, as well as a column <tt class="docutils literal">name</tt>
that holds a string. Each row would represent a city location position by its
latitude and longitude values.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%">
<col width="36%">
<col width="31%">
</colgroup>
<thead valign="bottom">
<tr>
<th class="head"><strong>Latitude</strong></th>
<th class="head"><strong>Longitude</strong></th>
<th class="head"><strong>Name</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td>38</td>
<td>122</td>
<td>Berkeley</td>
</tr>
<tr>
<td>42</td>
<td>71</td>
<td>Cambridge</td>
</tr>
<tr>
<td>45</td>
<td>93</td>
<td>Minneapolis</td>
</tr>
</tbody>
</table>
<p>A table with a single row can be created in the SQL language using a <tt class="docutils literal">select</tt>
statement, in which the row values are separated by commas and the column names
follow the keyword "as". All SQL statements end in a semicolon.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="mi">38</span> <span class="k">as</span> <span class="n">latitude</span><span class="p">,</span> <span class="mi">122</span> <span class="k">as</span> <span class="n">longitude</span><span class="p">,</span> <span class="ss">"Berkeley"</span> <span class="k">as</span> <span class="n">name</span><span class="p">;</span>
<span class="go">38|122|Berkeley</span>
</pre></div>
<p>The second line is the output, which includes one line per row with columns
separated by a vertical bar.</p>
<p>A multi-line table can be constructed by <cite>union</cite>, which combines the rows of
two tables. The column names of the left table are used in the constructed
table. Spacing within a line does not affect the result.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="mi">38</span> <span class="k">as</span> <span class="n">latitude</span><span class="p">,</span> <span class="mi">122</span> <span class="k">as</span> <span class="n">longitude</span><span class="p">,</span> <span class="ss">"Berkeley"</span> <span class="k">as</span> <span class="n">name</span> <span class="k">union</span>
<span class="gp">   ...&gt; </span><span class="k">select</span> <span class="mi">42</span><span class="p">,</span>             <span class="mi">71</span><span class="p">,</span>               <span class="ss">"Cambridge"</span>        <span class="k">union</span>
<span class="gp">   ...&gt; </span><span class="k">select</span> <span class="mi">45</span><span class="p">,</span>             <span class="mi">93</span><span class="p">,</span>               <span class="ss">"Minneapolis"</span><span class="p">;</span>
<span class="go">38|122|Berkeley</span>
<span class="go">42|71|Cambridge</span>
<span class="go">45|93|Minneapolis</span>
</pre></div>
<p>A table can be given a name using a <tt class="docutils literal">create table</tt> statement. While this
statement can also be used to create empty tables, we will focus on the form
that gives a name to an existing table defined by a <tt class="docutils literal">select</tt> statement.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">create</span> <span class="k">table</span> <span class="n">cities</span> <span class="k">as</span>
<span class="gp">   ...&gt; </span>   <span class="k">select</span> <span class="mi">38</span> <span class="k">as</span> <span class="n">latitude</span><span class="p">,</span> <span class="mi">122</span> <span class="k">as</span> <span class="n">longitude</span><span class="p">,</span> <span class="ss">"Berkeley"</span> <span class="k">as</span> <span class="n">name</span> <span class="k">union</span>
<span class="gp">   ...&gt; </span>   <span class="k">select</span> <span class="mi">42</span><span class="p">,</span>             <span class="mi">71</span><span class="p">,</span>               <span class="ss">"Cambridge"</span>        <span class="k">union</span>
<span class="gp">   ...&gt; </span>   <span class="k">select</span> <span class="mi">45</span><span class="p">,</span>             <span class="mi">93</span><span class="p">,</span>               <span class="ss">"Minneapolis"</span><span class="p">;</span>
</pre></div>
<p>Once a table is named, that name can be used in a <tt class="docutils literal">from</tt> clause within a
<tt class="docutils literal">select</tt> statement. All columns of a table can be displayed using the
special <tt class="docutils literal">select *</tt> form.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">cities</span><span class="p">;</span>
<span class="go">38|122|Berkeley</span>
<span class="go">42|71|Cambridge</span>
<span class="go">45|93|Minneapolis</span>
</pre></div>
</div>
<div class="section" id="select-statements">
<h3>4.3.2   Select Statements</h3>
<p>A <tt class="docutils literal">select</tt> statement defines a new table either by listing the values in a
single row or, more commonly, by projecting an existing table using a <tt class="docutils literal">from</tt>
clause:</p>
<pre class="literal-block">
select [column description] from [existing table name]
</pre>
<p>The columns of the resulting table are described by a comma-separated list of
expressions that are each evaluated for each row of the existing input table.</p>
<p>For example, we can create a two-column table that describes each city by how
far north or south it is of Berkeley. Each degree of latitude measures 60
nautical miles to the north.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="n">name</span><span class="p">,</span> <span class="mi">60</span><span class="o">*</span><span class="k">abs</span><span class="p">(</span><span class="n">latitude</span><span class="o">-</span><span class="mi">38</span><span class="p">)</span> <span class="k">from</span> <span class="n">cities</span><span class="p">;</span>
<span class="go">Berkeley|0</span>
<span class="go">Cambridge|240</span>
<span class="go">Minneapolis|420</span>
</pre></div>
<p>Column descriptions are expressions in a language that shares many properties
with Python: infix operators such as + and %, built-in functions such as
<tt class="docutils literal">abs</tt> and <tt class="docutils literal">round</tt>, and parentheses that describe evaluation order.
Names in these expressions, such as <tt class="docutils literal">latitude</tt> above, evaluate to the column
value in the row being projected.</p>
<p>Optionally, each expression can be followed by the keyword <tt class="docutils literal">as</tt> and a column
name. When the entire table is given a name, it is often helpful to give each
column a name so that it can be referenced in future <tt class="docutils literal">select</tt> statements.
Columns described by a simple name are named automatically.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">create</span> <span class="k">table</span> <span class="n">distances</span> <span class="k">as</span>
<span class="gp">   ...&gt; </span>  <span class="k">select</span> <span class="n">name</span><span class="p">,</span> <span class="mi">60</span><span class="o">*</span><span class="k">abs</span><span class="p">(</span><span class="n">latitude</span><span class="o">-</span><span class="mi">38</span><span class="p">)</span> <span class="k">as</span> <span class="n">distance</span> <span class="k">from</span> <span class="n">cities</span><span class="p">;</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="n">distance</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="n">name</span> <span class="k">from</span> <span class="n">distances</span><span class="p">;</span>
<span class="go">0|Berkeley</span>
<span class="go">48|Cambridge</span>
<span class="go">84|Minneapolis</span>
</pre></div>
<p><strong>Where Clauses.</strong> A <tt class="docutils literal">select</tt> statement can also include a <tt class="docutils literal">where</tt> clause
with a filtering expression. This expression filters the rows that are
projected. Only a row for which the filtering expression evaluates to a true
value will be used to produce a row in the resulting table.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">create</span> <span class="k">table</span> <span class="n">cold</span> <span class="k">as</span>
<span class="gp">   ...&gt; </span>  <span class="k">select</span> <span class="n">name</span> <span class="k">from</span> <span class="n">cities</span> <span class="k">where</span> <span class="n">latitude</span> <span class="o">&gt;</span> <span class="mi">43</span><span class="p">;</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="n">name</span><span class="p">,</span> <span class="ss">"is cold!"</span> <span class="k">from</span> <span class="n">cold</span><span class="p">;</span>
<span class="go">Minneapolis|is cold!</span>
</pre></div>
<p><strong>Order Clauses.</strong> A <tt class="docutils literal">select</tt> statement can also express an ordering over the
resulting table. An <tt class="docutils literal">order</tt> clause contains an ordering expression
that is evaluated for each unfiltered row. The resulting values of this
expression are used as a sorting criterion for the result table.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="n">distance</span><span class="p">,</span> <span class="n">name</span> <span class="k">from</span> <span class="n">distances</span> <span class="k">order</span> <span class="k">by</span> <span class="o">-</span><span class="n">distance</span><span class="p">;</span>
<span class="go">84|Minneapolis</span>
<span class="go">48|Cambridge</span>
<span class="go">0|Berkeley</span>
</pre></div>
<p>The combination of these features allows a <tt class="docutils literal">select</tt> statement to express a
wide range of projections of an input table into a related output table.</p>
</div>
<div class="section" id="joins">
<h3>4.3.3   Joins</h3>
<p>Databases typically contain multiple tables, and queries can require
information contained within different tables to compute a desired result. For
instance, we may have a second table describing the mean daily high temperature
of different cities.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">create</span> <span class="k">table</span> <span class="n">temps</span> <span class="k">as</span>
<span class="gp">   ...&gt; </span>  <span class="k">select</span> <span class="ss">"Berkeley"</span> <span class="k">as</span> <span class="n">city</span><span class="p">,</span> <span class="mi">68</span> <span class="k">as</span> <span class="n">temp</span> <span class="k">union</span>
<span class="gp">   ...&gt; </span>  <span class="k">select</span> <span class="ss">"Chicago"</span>         <span class="p">,</span> <span class="mi">59</span>         <span class="k">union</span>
<span class="gp">   ...&gt; </span>  <span class="k">select</span> <span class="ss">"Minneapolis"</span>     <span class="p">,</span> <span class="mi">55</span><span class="p">;</span>
</pre></div>
<p>Data are combined by <em>joining</em> multiple tables together into one, a fundamental
operation in database systems. There are many methods of joining, all closely
related, but we will focus on just one method in this text. When tables are
joined, the resulting table contains a new row for each combination of rows in
the input tables. If two tables are joined and the left table has <span class="rawlatex">$m$</span> rows and
the right table has <span class="rawlatex">$n$</span> rows, then the joined table will have <span class="rawlatex">$m \cdot n$</span> rows.
Joins are expressed in SQL by separating table names by commas in the <tt class="docutils literal">from</tt>
clause of a <tt class="docutils literal">select</tt> statement.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">cities</span><span class="p">,</span> <span class="n">temps</span><span class="p">;</span>
<span class="go">38|122|Berkeley|Berkeley|68</span>
<span class="go">38|122|Berkeley|Chicago|59</span>
<span class="go">38|122|Berkeley|Minneapolis|55</span>
<span class="go">42|71|Cambridge|Berkeley|68</span>
<span class="go">42|71|Cambridge|Chicago|59</span>
<span class="go">42|71|Cambridge|Minneapolis|55</span>
<span class="go">45|93|Minneapolis|Berkeley|68</span>
<span class="go">45|93|Minneapolis|Chicago|59</span>
<span class="go">45|93|Minneapolis|Minneapolis|55</span>
</pre></div>
<p>Joins are typically accompanied by a <tt class="docutils literal">where</tt> clause that expresses a
relationship between the two tables. For example, if we wanted to collect data
into a table that would allow us to correlate latitude and temperature, we
would select rows from the join where the same city is mentioned in each.
Within the <tt class="docutils literal">cities</tt> table, the city name is stored in a column called
<tt class="docutils literal">name</tt>. Within the <tt class="docutils literal">temps</tt> table, the city name is stored in a column
called <tt class="docutils literal">city</tt>. The <tt class="docutils literal">where</tt> clause can select for rows in the joined table
in which these values are equal. In SQL, numeric equality is tested with a
single <tt class="docutils literal">=</tt> symbol.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="n">name</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">temp</span> <span class="k">from</span> <span class="n">cities</span><span class="p">,</span> <span class="n">temps</span> <span class="k">where</span> <span class="n">name</span> <span class="o">=</span> <span class="n">city</span><span class="p">;</span>
<span class="go">Berkeley|38|68</span>
<span class="go">Minneapolis|45|55</span>
</pre></div>
<p>Tables may have overlapping column names, and so we need a method for
disambiguating column names by table. A table may also be joined with itself,
and so we need a method for disambiguating tables. To do so, SQL allows us to
give aliases to tables within a <tt class="docutils literal">from</tt> clause using the keyword <tt class="docutils literal">as</tt> and to
refer to a column within a particular table using a dot expression. The
following <tt class="docutils literal">select</tt> statement computes the temperature difference between
pairs of unequal cities. The alphabetical ordering constraint in the <tt class="docutils literal">where</tt>
clause ensures that each pair will only appear once in the result.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="n">a</span><span class="p">.</span><span class="n">city</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">city</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">temp</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">temp</span>
<span class="gp">   ...&gt; </span>       <span class="k">from</span> <span class="n">temps</span> <span class="k">as</span> <span class="n">a</span><span class="p">,</span> <span class="n">temps</span> <span class="k">as</span> <span class="n">b</span> <span class="k">where</span> <span class="n">a</span><span class="p">.</span><span class="n">city</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">city</span><span class="p">;</span>
<span class="go">Berkeley|Chicago|10</span>
<span class="go">Berkeley|Minneapolis|15</span>
<span class="go">Chicago|Minneapolis|5</span>
</pre></div>
<p>Our two means of combining tables in SQL, join and union, allow for a great
deal of expressive power in the language.</p>
</div>
<div class="section" id="aggregation-and-grouping">
<h3>4.3.4   Aggregation and Grouping</h3>
<p>The <tt class="docutils literal">select</tt> statements introduced so far can join, project, and manipulate
individual rows. In addition, a <tt class="docutils literal">select</tt> statement can perform aggregation
operations over multiple rows. The aggregate functions <tt class="docutils literal">max</tt>,
<tt class="docutils literal">min</tt>, <tt class="docutils literal">count</tt>, and <tt class="docutils literal">sum</tt> return the maximum, minimum, number, and sum
of the values in a column. Multiple aggregate functions can be applied to the
same set of rows by defining more than one column. Only columns that are
included by the <tt class="docutils literal">where</tt> clause are considered in the aggreagation.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">create</span> <span class="k">table</span> <span class="n">animals</span> <span class="k">as</span>
<span class="go">  ....&gt;   select "dog" as name, 4 as legs, 20 as weight union</span>
<span class="go">  ....&gt;   select "cat"        , 4        , 10           union</span>
<span class="go">  ....&gt;   select "ferret"     , 4        , 10           union</span>
<span class="go">  ....&gt;   select "t-rex"      , 2        , 12000        union</span>
<span class="go">  ....&gt;   select "penguin"    , 2        , 10           union</span>
<span class="go">  ....&gt;   select "bird"       , 2        , 6;</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="k">max</span><span class="p">(</span><span class="n">legs</span><span class="p">)</span> <span class="k">from</span> <span class="n">animals</span><span class="p">;</span>
<span class="go">4</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="k">sum</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="k">from</span> <span class="n">animals</span><span class="p">;</span>
<span class="go">12056</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="k">min</span><span class="p">(</span><span class="n">legs</span><span class="p">),</span> <span class="k">max</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="k">from</span> <span class="n">animals</span> <span class="k">where</span> <span class="n">name</span> <span class="o">&lt;&gt;</span> <span class="ss">"t-rex"</span><span class="p">;</span>
<span class="go">2|20</span>
</pre></div>
<p>The <tt class="docutils literal">distinct</tt> keyword ensures that no repeated values in a column are
included in the aggregation. Only two distinct values of <tt class="docutils literal">legs</tt> appear
in the <tt class="docutils literal">animals</tt> table. The special <tt class="docutils literal"><span class="pre">count(*)</span></tt> syntax counts the number of
rows.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="n">legs</span><span class="p">)</span> <span class="k">from</span> <span class="n">animals</span><span class="p">;</span>
<span class="go">6</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">animals</span><span class="p">;</span>
<span class="go">6</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="n">legs</span><span class="p">)</span> <span class="k">from</span> <span class="n">animals</span><span class="p">;</span>
<span class="go">2</span>
</pre></div>
<p>Each of these <tt class="docutils literal">select</tt> statements has produced a table with a single row.
The <tt class="docutils literal">group by</tt> and <tt class="docutils literal">having</tt> clauses of a <tt class="docutils literal">select</tt> statement are used to
partition rows into groups and select only a subset of the groups. Any
aggregate functions in the <tt class="docutils literal">having</tt> clause or column description will apply
to each group independently, rather than the entire set of rows in the table.</p>
<p>For example, to compute the maximum weight of both a four-legged and a
two-legged animal from this table, the first statement below groups together
dogs and cats as one group and birds as a separate group. The result indicates
that the maximum weight for a two-legged animal is 3 (the bird) and for a
four-legged animal is 20 (the dog). The second query lists the values in the
<tt class="docutils literal">legs</tt> column for which there are at least two distinct names.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="n">legs</span><span class="p">,</span> <span class="k">max</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="k">from</span> <span class="n">animals</span> <span class="k">group</span> <span class="k">by</span> <span class="n">legs</span><span class="p">;</span>
<span class="go">2|12000</span>
<span class="go">4|20</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="n">weight</span> <span class="k">from</span> <span class="n">animals</span> <span class="k">group</span> <span class="k">by</span> <span class="n">weight</span> <span class="k">having</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span>
<span class="go">10</span>
</pre></div>
<p>Multiple columns and full expressions can appear in the <tt class="docutils literal">group by</tt> clause,
and groups will be formed for every unique combination of values that result.
Typically, the expression used for grouping also appears in the column
description, so that it is easy to identify which result row resulted from
each group.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="k">max</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">from</span> <span class="n">animals</span> <span class="k">group</span> <span class="k">by</span> <span class="n">legs</span><span class="p">,</span> <span class="n">weight</span> <span class="k">order</span> <span class="k">by</span> <span class="n">name</span><span class="p">;</span>
<span class="go">bird</span>
<span class="go">dog</span>
<span class="go">ferret</span>
<span class="go">penguin</span>
<span class="go">t-rex</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="k">max</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">legs</span><span class="p">,</span> <span class="n">weight</span> <span class="k">from</span> <span class="n">animals</span> <span class="k">group</span> <span class="k">by</span> <span class="n">legs</span><span class="p">,</span> <span class="n">weight</span>
<span class="go">  ....&gt;   having max(weight) &lt; 100;</span>
<span class="go">bird|2|6</span>
<span class="go">penguin|2|10</span>
<span class="go">ferret|4|10</span>
<span class="go">dog|4|20</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="n">weight</span><span class="o">/</span><span class="n">legs</span> <span class="k">from</span> <span class="n">animals</span> <span class="k">group</span> <span class="k">by</span> <span class="n">weight</span><span class="o">/</span><span class="n">legs</span><span class="p">;</span>
<span class="go">2|2</span>
<span class="go">1|3</span>
<span class="go">2|5</span>
<span class="go">1|6000</span>
</pre></div>
<p>A <tt class="docutils literal">having</tt> clause can contain the same filtering as a <tt class="docutils literal">where</tt> clause, but
can also include calls to aggregate functions. For the fastest execution and
clearest use of the language, a condition that filters individual rows based
on their contents should appear in a <tt class="docutils literal">where</tt> clause, while a <tt class="docutils literal">having</tt>
clause should be used only when aggregation is required in the condition (such
as specifying a minimum <tt class="docutils literal">count</tt> for a group).</p>
<p>When using a <tt class="docutils literal">group by</tt> clause, column descriptions can contain expressions
that do not aggregate. In some cases, the SQL interpreter will choose the value
from a row that corresponds to another column that includes aggregation. For
example, the following statement gives the <tt class="docutils literal">name</tt> of an animal with maximal
<tt class="docutils literal">weight</tt>.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="n">name</span><span class="p">,</span> <span class="k">max</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="k">from</span> <span class="n">animals</span><span class="p">;</span>
<span class="go">t-rex|12000</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="n">name</span><span class="p">,</span> <span class="n">legs</span><span class="p">,</span> <span class="k">max</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="k">from</span> <span class="n">animals</span> <span class="k">group</span> <span class="k">by</span> <span class="n">legs</span><span class="p">;</span>
<span class="go">t-rex|2|12000</span>
<span class="go">dog|4|20</span>
</pre></div>
<p>However, whenever the row that corresponds to aggregation is unclear (for
instance, when aggregating with <tt class="docutils literal">count</tt> instead of <tt class="docutils literal">max</tt>), the value chosen
may be arbitrary. For the clearest and most predictable use of the language, a
<tt class="docutils literal">select</tt> statement that includes a <tt class="docutils literal">group by</tt> clause should include at
least one aggregate column and only include non-aggregate columns if their
contents is predictable from the aggregation.</p>
</div>
<div class="section" id="create-table-and-drop-table">
<h3>4.3.5   Create Table and Drop Table</h3>
<p>The <tt class="docutils literal">create table</tt> statement creates a new table in our database. As we saw
earlier, we can combine the <tt class="docutils literal">create table</tt> statement with the <tt class="docutils literal">select</tt>
statement to give a name to an existing table, but we can also use the <tt class="docutils literal">create
table</tt> statement along with a list of column names to create an empty table.
For each column, we can optionally include the <tt class="docutils literal">unique</tt> keyword, which
indicates that the column can only contain unique values, or the <tt class="docutils literal">default</tt>
keyword, which gives a default value for an item in the column. For the entire
<tt class="docutils literal">create table</tt> statement, including the optional <tt class="docutils literal">if not exists</tt> clause will
prevent an error if we attempt to create duplicate tables.</p>
<p>The <tt class="docutils literal">drop table</tt> statement deletes a table from our database. Including the optional <tt class="docutils literal">if exists</tt> clause will prevent an error if we attempt to drop a non-existing table.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">create</span> <span class="k">table</span> <span class="n">primes</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">prime</span><span class="p">);</span>
<span class="gp">sqlite&gt; </span><span class="k">drop</span> <span class="k">table</span> <span class="n">primes</span><span class="p">;</span>
<span class="gp">sqlite&gt; </span><span class="k">drop</span> <span class="k">table</span> <span class="k">if</span> <span class="k">exists</span> <span class="n">primes</span><span class="p">;</span>
<span class="gp">sqlite&gt; </span><span class="k">create</span> <span class="k">table</span> <span class="n">primes</span> <span class="p">(</span><span class="n">n</span> <span class="k">unique</span><span class="p">,</span> <span class="n">prime</span> <span class="k">default</span> <span class="mi">1</span><span class="p">);</span>
<span class="gp">sqlite&gt; </span><span class="k">create</span> <span class="k">table</span> <span class="k">if</span> <span class="k">not</span> <span class="k">exists</span> <span class="n">primes</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">prime</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="modifying-tables">
<h3>4.3.6   Modifying Tables</h3>
<p>The <tt class="docutils literal">insert into</tt> statement allows us to add rows to a table in our database.
In particular, we can insert values into all columns of our table, or we can add
to one specific column, which will set the other columns to their default
values. By combining the <tt class="docutils literal">insert into</tt> and <tt class="docutils literal">select</tt> statements, we can add
the rows of an existing table to our table.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">insert</span> <span class="k">into</span> <span class="n">primes</span> <span class="k">values</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">primes</span><span class="p">;</span>
<span class="go">2|1</span>
<span class="go">3|1</span>
<span class="gp">sqlite&gt; </span><span class="k">insert</span> <span class="k">into</span> <span class="n">primes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">primes</span><span class="p">;</span>
<span class="go">2|1</span>
<span class="go">3|1</span>
<span class="go">4|1</span>
<span class="go">5|1</span>
<span class="gp">sqlite&gt; </span><span class="k">insert</span> <span class="k">into</span> <span class="n">primes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">select</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">4</span> <span class="k">from</span> <span class="n">primes</span><span class="p">;</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">primes</span><span class="p">;</span>
<span class="go">2|1</span>
<span class="go">3|1</span>
<span class="go">4|1</span>
<span class="go">5|1</span>
<span class="go">6|1</span>
<span class="go">7|1</span>
<span class="go">8|1</span>
<span class="go">9|1</span>
</pre></div>
<p>The <tt class="docutils literal">update</tt> statement sets all entries in certain columns of a table to new
values for a subset of rows as indicated by an optional <tt class="docutils literal">where</tt> clause. We can
update all rows by omitting the optional <tt class="docutils literal">where</tt> clause.</p>
<p>The <tt class="docutils literal">delete from</tt> statement deletes a subset of rows of a table as indicated
by an optional <tt class="docutils literal">where</tt> clause. If we do not include a <tt class="docutils literal">where</tt> clause, then
we will delete all rows, but an empty table would remain in our database.</p>
<div class="highlight"><pre><span></span><span class="gp">sqlite&gt; </span><span class="k">update</span> <span class="n">primes</span> <span class="k">set</span> <span class="n">prime</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">where</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">and</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="gp">sqlite&gt; </span><span class="k">update</span> <span class="n">primes</span> <span class="k">set</span> <span class="n">prime</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">where</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="k">and</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">primes</span><span class="p">;</span>
<span class="go">2|1</span>
<span class="go">3|1</span>
<span class="go">4|0</span>
<span class="go">5|1</span>
<span class="go">6|0</span>
<span class="go">7|1</span>
<span class="go">8|0</span>
<span class="go">9|0</span>
<span class="gp">sqlite&gt; </span><span class="k">delete</span> <span class="k">from</span> <span class="n">primes</span> <span class="k">where</span> <span class="n">prime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="gp">sqlite&gt; </span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">primes</span><span class="p">;</span>
<span class="go">2|1</span>
<span class="go">3|1</span>
<span class="go">5|1</span>
<span class="go">7|1</span>
</pre></div>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/44-logic-programming.html">
  		4.4 Logic Programming
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="logic-programming">
<h2>4.4   Logic Programming</h2>
<p>In this section, we introduce a declarative query language called <tt class="docutils literal">logic</tt>,
designed specifically for this text.  It is based upon <a class="reference external" href="http://en.wikipedia.org/wiki/Prolog">Prolog</a> and the declarative language in
<a class="reference external" href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.1">Structure and Interpretation of Computer Programs</a>.
Data records are expressed as Scheme lists, and queries are expressed as Scheme
values. The <a class="reference external" href="http://composingprograms.com/examples/logic/logic.py.html">logic</a> interpreter is a complete implementation that depends
upon the Scheme project of the previous chapter.</p>
<div class="section" id="facts-and-queries">
<h3>4.4.1   Facts and Queries</h3>
<p>Databases store records that represent facts in the system.  The
purpose of the query interpreter is to retrieve collections of facts drawn
directly from database records, as well as to deduce new facts from the
database using logical inference. A <tt class="docutils literal">fact</tt> statement in the <tt class="docutils literal">logic</tt>
language consists of one or more lists following the keyword <tt class="docutils literal">fact</tt>.  A
simple fact is a single list. A dog breeder with an interest in U.S. Presidents
might record the genealogy of her collection of dogs using the <tt class="docutils literal">logic</tt>
language as follows:</p>
<pre id="Coding-JS-parent-def">
(fact (parent abraham barack))
(fact (parent abraham clinton))
(fact (parent delano herbert))
(fact (parent fillmore abraham))
(fact (parent fillmore delano))
(fact (parent fillmore grover))
(fact (parent eisenhower fillmore))
</pre>
<script>$c.prompt("Coding-JS-parent-def", [], "logic");</script>
<p>Each fact is not a procedure application, as in a Scheme expression, but
instead a <em>relation</em> that is declared.  "The dog Abraham is the parent of
Barack," declares the first fact. Relation types do not need to be defined in
advance. Relations are not applied, but instead matched to queries.</p>
<p>A query also consists of one or more lists, but begins with the keyword
<tt class="docutils literal">query</tt>. A query may contain variables, which are symbols that begin with a
question mark.  Variables are matched to facts by the query interpreter:</p>
<pre id="Coding-JS-parent-eg">
(query (parent abraham ?child))
</pre>
<script>$c.prompt("Coding-JS-parent-eg", ["Coding-JS-parent-def"], "logic");</script>
<p>The query interpreter responds with <tt class="docutils literal">Success!</tt> to indicate that the query
matches some fact.  The following lines show substitutions of the variable
<tt class="docutils literal"><span class="pre">?child</span></tt> that match the query to the facts in the database.</p>
<p><strong>Compound facts.</strong> Facts may also contain variables as well as multiple
sub-expressions. A multi-expression fact begins with a conclusion, followed by
hypotheses.  For the conclusion to be true, all of the hypotheses must be
satisfied:</p>
<pre id="Coding-JS-fact-syntax">
(fact &lt;conclusion&gt; &lt;hypothesis0&gt; &lt;hypothesis1&gt; ... &lt;hypothesisN&gt;)
</pre>
<script>$c.no_output_frozen_prompt("Coding-JS-fact-syntax", [], "logic");</script>
<p>For example, facts about children can be declared based on the facts about
parents already in the database:</p>
<pre id="Coding-JS-child-def">
(fact (child ?c ?p) (parent ?p ?c))
</pre>
<script>$c.prompt("Coding-JS-child-def", [], "logic");</script>
<p>The fact above can be read as: "<tt class="docutils literal"><span class="pre">?c</span></tt> is the child of <tt class="docutils literal"><span class="pre">?p</span></tt>, provided that
<tt class="docutils literal"><span class="pre">?p</span></tt> is the parent of <tt class="docutils literal"><span class="pre">?c</span></tt>." A query can now refer to this fact:</p>
<pre id="Coding-JS-child-eg-1">
(query (child ?child fillmore))
</pre>
<script>$c.prompt("Coding-JS-child-eg-1", ["Coding-JS-child-def", "Coding-JS-parent-def"], "logic");</script>
<p>The query above requires the query interpreter to combine the fact that defines
<tt class="docutils literal">child</tt> with the various parent facts about <tt class="docutils literal">fillmore</tt>. The user of the
language does not need to know how this information is combined, but only that
the result has a particular form.  It is up to the query interpreter to prove
that <tt class="docutils literal">(child abraham fillmore)</tt> is true, given the available facts.</p>
<p>A query is not required to include variables; it may simply verify a fact:</p>
<pre id="Coding-JS-child-eg-2">
(query (child herbert delano))
</pre>
<script>$c.prompt("Coding-JS-child-eg-2", ["Coding-JS-child-def", "Coding-JS-parent-def"], "logic");</script>
<p>A query that does not match any facts will return failure:</p>
<pre id="Coding-JS-child-eg-3">
(query (child eisenhower ?parent))
</pre>
<script>$c.prompt("Coding-JS-child-eg-3", ["Coding-JS-child-def", "Coding-JS-parent-def"], "logic");</script>
<p><strong>Negation.</strong> We can check if some query does not match any fact by using the
special keyword <tt class="docutils literal">not</tt>:</p>
<pre id="Coding-JS-negation-syntax">
(query (not &lt;relation&gt;))
</pre>
<script>$c.no_output_frozen_prompt("Coding-JS-negation-syntax", [], "logic");</script>
<p>This query succeeds if <tt class="docutils literal">&lt;relation&gt;</tt> fails, and fails if <tt class="docutils literal">&lt;relation&gt;</tt>
succeeds. This idea is known as <em>negation as failure</em>.</p>
<pre id="Coding-JS-negation-eg">
(query (not (parent abraham clinton)))
</pre>
<script>$c.prompt("Coding-JS-negation-eg", ["Coding-JS-parent-def"], "logic");</script>
<pre id="Coding-JS-negation-eg2">
(query (not (parent abraham barack)))
</pre>
<script>$c.prompt("Coding-JS-negation-eg2", ["Coding-JS-parent-def"], "logic");</script>
<p>Sometimes, negation as failure may be counterintuitive to how one might expect
negation to work. Think about the result of the following query:</p>
<pre id="Coding-JS-negation-syntax">
(query (not (parent abraham ?who)))
</pre>
<script>$c.prompt("Coding-JS-negation-syntax", ["Coding-JS-parent-def"], "logic");</script>
<p>Why does this query fail? Surely there are many symbols that could be bound to
<tt class="docutils literal"><span class="pre">?who</span></tt> for which this should hold. However, the steps for negation indicate
that we first inspect the relation <tt class="docutils literal">(parent abraham <span class="pre">?who)</span></tt>. This relation
succeeds, since <tt class="docutils literal"><span class="pre">?who</span></tt> can be bound to either <tt class="docutils literal">barack</tt> or <tt class="docutils literal">clinton</tt>.
Because this relation succeeds, the negation of this relation must fail.</p>
</div>
<div class="section" id="recursive-facts">
<h3>4.4.2   Recursive Facts</h3>
<p>The <tt class="docutils literal">logic</tt> language also allows recursive facts.  That is, the conclusion of
a fact may depend upon a hypothesis that contains the same symbols.  For
instance, the ancestor relation is defined with two facts.  Some <tt class="docutils literal"><span class="pre">?a</span></tt> is an
ancestor of <tt class="docutils literal"><span class="pre">?y</span></tt> if it is a parent of <tt class="docutils literal"><span class="pre">?y</span></tt> or if it is the parent of an
ancestor of <tt class="docutils literal"><span class="pre">?y</span></tt>:</p>
<pre id="Coding-JS-ancestor-def">
(fact (ancestor ?a ?y) (parent ?a ?y))
(fact (ancestor ?a ?y) (parent ?a ?z) (ancestor ?z ?y))
</pre>
<script>$c.prompt("Coding-JS-ancestor-def", ["Coding-JS-parent-def"], "logic");</script>
<p>A single query can then list all ancestors of <tt class="docutils literal">herbert</tt>:</p>
<pre id="Coding-JS-ancestor-eg-1">
(query (ancestor ?a herbert))
</pre>
<script>$c.prompt("Coding-JS-ancestor-eg-1", ["Coding-JS-ancestor-def"], "logic");</script>
<p><strong>Compound queries.</strong> A query may have multiple subexpressions, in which case
all must be satisfied simultaneously by an assignment of symbols to variables.
If a variable appears more than once in a query, then it must take the same
value in each context.  The following query finds ancestors of both <tt class="docutils literal">herbert</tt>
and <tt class="docutils literal">barack</tt>:</p>
<pre id="Coding-JS-ancestor-eg-2">
(query (ancestor ?a barack) (ancestor ?a herbert))
</pre>
<script>$c.prompt("Coding-JS-ancestor-eg-2", ["Coding-JS-ancestor-def"], "logic");</script>
<p>Recursive facts may require long chains of inference to match queries to
existing facts in a database. For instance, to prove the fact <tt class="docutils literal">(ancestor
fillmore herbert)</tt>, we must prove each of the following facts in
succession:</p>
<pre class="literal-block">
(parent delano herbert)       ; (1), a simple fact
(ancestor delano herbert)     ; (2), from (1) and the 1st ancestor fact
(parent fillmore delano)      ; (3), a simple fact
(ancestor fillmore herbert)   ; (4), from (2), (3), &amp; the 2nd ancestor fact
</pre>
<p>In this way, a single fact can imply a large number of additional facts, or
even infinitely many, as long as the query interpreter is able to discover them.</p>
<p><strong>Hierarchical facts.</strong> Thus far, each fact and query expression has been a
list of symbols.  In addition, fact and query lists can contain lists,
providing a way to represent hierarchical data.  The color of each dog may be
stored along with the name an additional record:</p>
<pre id="Coding-JS-dog-def">
(fact (dog (name abraham) (color white)))
(fact (dog (name barack) (color tan)))
(fact (dog (name clinton) (color white)))
(fact (dog (name delano) (color white)))
(fact (dog (name eisenhower) (color tan)))
(fact (dog (name fillmore) (color brown)))
(fact (dog (name grover) (color tan)))
(fact (dog (name herbert) (color brown)))
</pre>
<script>$c.prompt("Coding-JS-dog-def", [], "logic");</script>
<p>Queries can articulate the full structure of hierarchical facts, or they can
match variables to whole lists:</p>
<pre id="Coding-JS-dog-eg-1">
(query (dog (name clinton) (color ?color)))
</pre>
<script>$c.prompt("Coding-JS-dog-eg-1", ["Coding-JS-dog-def"], "logic");</script>
<pre id="Coding-JS-dog-eg-2">
(query (dog (name clinton) ?info))
</pre>
<script>$c.prompt("Coding-JS-dog-eg-2", ["Coding-JS-dog-def"], "logic");</script>
<p>Much of the power of a database lies in the ability of the query interpreter to
join together multiple kinds of facts in a single query.  The following query
finds all pairs of dogs for which one is the ancestor of the other and they
share a color:</p>
<pre id="Coding-JS-dog-ancestor-eg">
(query (dog (name ?name) (color ?color))
       (ancestor ?ancestor ?name)
       (dog (name ?ancestor) (color ?color)))
</pre>
<script>$c.prompt("Coding-JS-dog-ancestor-eg", ["Coding-JS-dog-def", "Coding-JS-ancestor-def"], "logic");</script>
<p>Variables can refer to lists in hierarchical records, but also using dot
notation.  A variable following a dot matches the rest of the list of a fact.
Dotted lists can appear in either facts or queries. The following example
constructs pedigrees of dogs by listing their chain of ancestry.  Young
<tt class="docutils literal">barack</tt> follows a venerable line of presidential pups:</p>
<pre id="Coding-JS-dog-pedigree-def">
(fact (pedigree ?name) (dog (name ?name) . ?details))
(fact (pedigree ?child ?parent . ?rest)
      (parent ?parent ?child)
      (pedigree ?parent . ?rest))
</pre>
<script>$c.prompt("Coding-JS-dog-pedigree-def", ["Coding-JS-dog-def", "Coding-JS-parent-def"], "logic");</script>
<pre id="Coding-JS-dog-pedigree-eg">
(query (pedigree barack . ?lineage))
</pre>
<script>$c.prompt("Coding-JS-dog-pedigree-eg", ["Coding-JS-dog-pedigree-def"], "logic");</script>
<p>Declarative or logical programming can express relationships among facts with
remarkable efficiency. For example, if we wish to express that two lists can
append to form a longer list with the elements of the first, followed by the
elements of the second, we state two rules.  First, a base case declares that
appending an empty list to any list gives that list:</p>
<pre id="Coding-JS-atf-base">
(fact (append-to-form () ?x ?x))
</pre>
<script>$c.prompt("Coding-JS-atf-base", [], "logic");</script>
<p>Second, a recursive fact declares that a list with first element <tt class="docutils literal"><span class="pre">?a</span></tt> and
rest <tt class="docutils literal"><span class="pre">?r</span></tt> appends to a list <tt class="docutils literal"><span class="pre">?y</span></tt> to form a list with first element <tt class="docutils literal"><span class="pre">?a</span></tt>
and some appended rest <tt class="docutils literal"><span class="pre">?z</span></tt>.  For this relation to hold, it must be the case
that <tt class="docutils literal"><span class="pre">?r</span></tt> and <tt class="docutils literal"><span class="pre">?y</span></tt> append to form <tt class="docutils literal"><span class="pre">?z</span></tt>:</p>
<pre id="Coding-JS-atf-recur">
(fact (append-to-form (?a . ?r) ?y (?a . ?z)) (append-to-form ?r ?y ?z))
</pre>
<script>$c.prompt("Coding-JS-atf-recur", [], "logic");</script>
<p>Using these two facts, the query interpreter can compute the result of appending any
two lists together:</p>
<pre id="Coding-JS-atf-eg-1">
(query (append-to-form (a b c) (d e) ?result))
</pre>
<script>$c.prompt("Coding-JS-atf-eg-1", ["Coding-JS-atf-base", "Coding-JS-atf-recur"], "logic");</script>
<p>In addition, it can compute all possible pairs of lists <tt class="docutils literal"><span class="pre">?left</span></tt> and <tt class="docutils literal"><span class="pre">?right</span></tt>
that can append to form the list <tt class="docutils literal">(a b c d e)</tt>:</p>
<pre id="Coding-JS-atf-eg-2">
(query (append-to-form ?left ?right (a b c d e)))
</pre>
<script>$c.prompt("Coding-JS-atf-eg-2", ["Coding-JS-atf-base", "Coding-JS-atf-recur"], "logic");</script>
<p>Although it may appear that our query interpreter is quite intelligent, we will
see that it finds these combinations through one simple operation repeated many
times: that of matching two lists that contain variables in an environment.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/45-unification.html">
  		4.5 Unification
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="unification">
<h2>4.5   Unification</h2>
<p>This section describes an implementation of the query interpreter that performs
inference in the <tt class="docutils literal">logic</tt> language. The interpreter is a general problem
solver, but has substantial limitations on the scale and type of problems it
can solve. More sophisticated logical programming languages exist, but the
construction of efficient inference procedures remains an active research topic
in computer science.</p>
<p>The fundamental operation performed by the query interpreter is called
<em>unification</em>.  Unification is a general method of matching a query to a fact,
each of which may contain variables. The query interpreter applies this
operation repeatedly, first to match the original query to conclusions of
facts, and then to match the hypotheses of facts to other conclusions in the
database.  In doing so, the query interpreter performs a search through the
space of all facts related to a query.  If it finds a way to support that query
with an assignment of values to variables, it returns that assignment as a
successful result.</p>
<div class="section" id="pattern-matching">
<h3>4.5.1   Pattern Matching</h3>
<p>In order to return simple facts that match a query, the interpreter must match
a query that contains variables with a fact that does not. For example, the
query <tt class="docutils literal">(query (parent abraham <span class="pre">?child))</span></tt> and the fact <tt class="docutils literal">(fact (parent abraham
barack))</tt> match, if the variable <tt class="docutils literal"><span class="pre">?child</span></tt> takes the value <tt class="docutils literal">barack</tt>.</p>
<p>In general, a pattern matches some expression (a possibly nested Scheme list)
if there is a binding of variable names to values such that substituting those
values into the pattern yields the expression.</p>
<p>For example, the expression <tt class="docutils literal">((a b) c (a b))</tt> matches the pattern <tt class="docutils literal"><span class="pre">(?x</span> c
<span class="pre">?x)</span></tt> with variable <tt class="docutils literal"><span class="pre">?x</span></tt> bound to value <tt class="docutils literal">(a b)</tt>. The same expression
matches the pattern <tt class="docutils literal">((a <span class="pre">?y)</span> <span class="pre">?z</span> (a b))</tt> with variable <tt class="docutils literal"><span class="pre">?y</span></tt> bound to <tt class="docutils literal">b</tt>
and <tt class="docutils literal"><span class="pre">?z</span></tt> bound to <tt class="docutils literal">c</tt>.</p>
</div>
<div class="section" id="representing-facts-and-queries">
<h3>4.5.2   Representing Facts and Queries</h3>
<p>The following examples can be replicated by importing the provided <a class="reference external" href="http://composingprograms.com/examples/logic/logic.py.html">logic</a>
example program.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">logic</span> <span class="k">import</span> <span class="o">*</span>
</pre></div>

<p>Both queries and facts are represented as Scheme lists in the logic language,
using the same <tt class="docutils literal">Pair</tt> class and <tt class="docutils literal">nil</tt> object in the previous chapter.  For
example, the query expression <tt class="docutils literal"><span class="pre">(?x</span> c <span class="pre">?x)</span></tt> is represented as nested <tt class="docutils literal">Pair</tt>
instances.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">read_line</span><span class="p">(</span><span class="s2">"(?x c ?x)"</span><span class="p">)</span>
<span class="go">Pair('?x', Pair('c', Pair('?x', nil)))</span>
</pre></div>

<p>As in the Scheme project, an environment that binds symbols to values is
represented with an instance of the <tt class="docutils literal">Frame</tt> class, which has an attribute
called <tt class="docutils literal">bindings</tt>.</p>
<p>The function that performs pattern matching in the <tt class="docutils literal">logic</tt> language is called
<tt class="docutils literal">unify</tt>. It takes two inputs, <tt class="docutils literal">e</tt> and <tt class="docutils literal">f</tt>, as well as an environment
<tt class="docutils literal">env</tt> that records the bindings of variables to values.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">read_line</span><span class="p">(</span><span class="s2">"((a b) c (a b))"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">read_line</span><span class="p">(</span><span class="s2">"(?x c ?x)"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unify</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="o">.</span><span class="n">bindings</span>
<span class="go">{'?x': Pair('a', Pair('b', nil))}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">env</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">'?x'</span><span class="p">))</span>
<span class="go">(a b)</span>
</pre></div>

<p>Above, the return value of <tt class="docutils literal">True</tt> from <tt class="docutils literal">unify</tt> indicates that the pattern
<tt class="docutils literal">f</tt> was able to match the expression <tt class="docutils literal">e</tt>.  The result of unification is
recorded in the binding in <tt class="docutils literal">env</tt> of <tt class="docutils literal"><span class="pre">?x</span></tt> to <tt class="docutils literal">(a b)</tt>.</p>
</div>
<div class="section" id="the-unification-algorithm">
<h3>4.5.3   The Unification Algorithm</h3>
<p>Unification is a generalization of pattern matching that attempts to find a
mapping between two expressions that may both contain variables. The <tt class="docutils literal">unify</tt>
function implements unification via a recursive process, which performs
unification on corresponding parts of two expressions until a contradiction is
reached or a viable binding to all variables can be established.</p>
<p>Let us begin with an example. The pattern <tt class="docutils literal"><span class="pre">(?x</span> <span class="pre">?x)</span></tt> can match the pattern
<tt class="docutils literal">((a <span class="pre">?y</span> c) (a b <span class="pre">?z))</span></tt> because there is an expression with no variables that
matches both: <tt class="docutils literal">((a b c) (a b c))</tt>. Unification identifies this solution via
the following steps:</p>
<ol class="arabic simple">
<li>To match the first element of each pattern, the variable <tt class="docutils literal"><span class="pre">?x</span></tt> is bound to
the expression <tt class="docutils literal">(a <span class="pre">?y</span> c)</tt>.</li>
<li>To match the second element of each pattern, first the variable <tt class="docutils literal"><span class="pre">?x</span></tt> is
replaced by its value.  Then, <tt class="docutils literal">(a <span class="pre">?y</span> c)</tt> is matched to <tt class="docutils literal">(a b <span class="pre">?z)</span></tt> by
binding <tt class="docutils literal"><span class="pre">?y</span></tt> to <tt class="docutils literal">b</tt> and <tt class="docutils literal"><span class="pre">?z</span></tt> to <tt class="docutils literal">c</tt>.</li>
</ol>
<p>As a result, the bindings placed in the environment passed to <tt class="docutils literal">unify</tt> contain
entries for <tt class="docutils literal"><span class="pre">?x</span></tt>, <tt class="docutils literal"><span class="pre">?y</span></tt>, and <tt class="docutils literal"><span class="pre">?z</span></tt>:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">read_line</span><span class="p">(</span><span class="s2">"(?x ?x)"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">read_line</span><span class="p">(</span><span class="s2">" ((a ?y c) (a b ?z))"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unify</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="o">.</span><span class="n">bindings</span>
<span class="go">{'?z': 'c', '?y': 'b', '?x': Pair('a', Pair('?y', Pair('c', nil)))}</span>
</pre></div>

<p>The result of unification may bind a variable to an expression that also
contains variables, as we see above with <tt class="docutils literal"><span class="pre">?x</span></tt> bound to <tt class="docutils literal">(a <span class="pre">?y</span> c)</tt>. The
<tt class="docutils literal">bind</tt> function recursively and repeatedly binds all variables to their
values in an expression until no bound variables remain.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span>
<span class="go">((a b c) (a b c))</span>
</pre></div>

<p>In general, unification proceeds by checking several conditions. The
implementation of <tt class="docutils literal">unify</tt> directly follows the description below.</p>
<ol class="arabic simple">
<li>Both inputs <tt class="docutils literal">e</tt> and <tt class="docutils literal">f</tt> are replaced by their values if they are
variables.</li>
<li>If <tt class="docutils literal">e</tt> and <tt class="docutils literal">f</tt> are equal, unification succeeds.</li>
<li>If <tt class="docutils literal">e</tt> is a variable, unification succeeds and <tt class="docutils literal">e</tt> is bound to <tt class="docutils literal">f</tt>.</li>
<li>If <tt class="docutils literal">f</tt> is a variable, unification succeeds and <tt class="docutils literal">f</tt> is bound to <tt class="docutils literal">e</tt>.</li>
<li>If neither is a variable, both are not lists, and they are not equal, then
<tt class="docutils literal">e</tt> and <tt class="docutils literal">f</tt> cannot be unified, and so unification fails.</li>
<li>If none of these cases holds, then <tt class="docutils literal">e</tt> and <tt class="docutils literal">f</tt> are both pairs, and so
unification is performed on both their first and second corresponding
elements.</li>
</ol>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">unify</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Destructively extend ENV so as to unify (make equal) e and f, returning</span>
<span class="gp">    </span><span class="sd">    True if this succeeds and False otherwise.  ENV may be modified in either</span>
<span class="gp">    </span><span class="sd">    case (its existing bindings are never changed)."""</span>
<span class="gp">    </span>    <span class="n">e</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
<span class="gp">    </span>    <span class="n">f</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="kc">True</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">isvar</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">env</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="kc">True</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">isvar</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="gp">    </span>        <span class="n">env</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="kc">True</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">scheme_atomp</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">or</span> <span class="n">scheme_atomp</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">unify</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="ow">and</span> <span class="n">unify</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
</pre></div>

</div>
<div class="section" id="proofs">
<h3>4.5.4   Proofs</h3>
<p>One way to think about the <tt class="docutils literal">logic</tt> language is as a prover of assertions in a
formal system. Each stated fact establishes an axiom in a formal system, and
each query must be established by the query interpreter from these axioms.
That is, each query asserts that there is some assignment to its variables such
that all of its sub-expressions simultaneously follow from the facts of the
system. The role of the query interpreter is to verify that this is so.</p>
<p>For instance, given the set of facts about dogs, we may assert that there is
some common ancestor of Clinton and a tan dog. The query interpreter only
outputs <tt class="docutils literal">Success!</tt> if it is able to establish that this assertion is true.
As a byproduct, it informs us of the name of that common ancestor and the tan
dog:</p>
<pre id="Coding-JS-axioms">
(fact (parent abraham barack))
(fact (parent abraham clinton))
(fact (parent delano herbert))
(fact (parent fillmore abraham))
(fact (parent fillmore delano))
(fact (parent fillmore grover))
(fact (parent eisenhower fillmore))

(fact (ancestor ?a ?y) (parent ?a ?y))
(fact (ancestor ?a ?y) (parent ?a ?z) (ancestor ?z ?y))

(fact (dog (name abraham) (color white)))
(fact (dog (name barack) (color tan)))
(fact (dog (name clinton) (color white)))
(fact (dog (name delano) (color white)))
(fact (dog (name eisenhower) (color tan)))
(fact (dog (name fillmore) (color brown)))
(fact (dog (name grover) (color tan)))
(fact (dog (name herbert) (color brown)))
</pre>
<script>$c.hidden_prompt("Coding-JS-axioms", [], "logic");</script>
<pre id="Coding-JS-formal-proof">
(query (ancestor ?a clinton)
       (ancestor ?a ?brown-dog)
       (dog (name ?brown-dog) (color brown)))
</pre>
<script>$c.prompt("Coding-JS-formal-proof", ["Coding-JS-axioms"], "logic");</script>
<p>Each of the three assignments shown in the result is a trace of a larger proof
that the query is true given the facts.  A full proof would include all of the
facts that were used, for instance including <tt class="docutils literal">(parent abraham clinton)</tt> and
<tt class="docutils literal">(parent fillmore abraham)</tt>.</p>
</div>
<div class="section" id="search">
<h3>4.5.5   Search</h3>
<p>In order to establish a query from the facts already established in the system,
the query interpreter performs a search in the space of all possible facts.
Unification is the primitive operation that pattern matches two expressions. The
<em>search procedure</em> in a query interpreter chooses what expressions to unify in
order to find a set of facts that chain together to establishes the query.</p>
<p>The recursive <tt class="docutils literal">search</tt> function implements the search procedure for the
<tt class="docutils literal">logic</tt> language. It takes as input the Scheme list of <tt class="docutils literal">clauses</tt> in the
query, an environment <tt class="docutils literal">env</tt> containing current bindings of symbols to values
(initially empty), and the <tt class="docutils literal">depth</tt> of the chain of rules that have been
chained together already.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">clauses</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Search for an application of rules to establish all the CLAUSES,</span>
<span class="gp">    </span><span class="sd">    non-destructively extending the unifier ENV.  Limit the search to</span>
<span class="gp">    </span><span class="sd">    the nested application of DEPTH rules."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">clauses</span> <span class="ow">is</span> <span class="n">nil</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">yield</span> <span class="n">env</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">DEPTH_LIMIT</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">depth</span> <span class="o">&lt;=</span> <span class="n">DEPTH_LIMIT</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">if</span> <span class="n">clauses</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">first</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'not'</span><span class="p">,</span> <span class="s1">'~'</span><span class="p">):</span>
<span class="gp">    </span>            <span class="n">clause</span> <span class="o">=</span> <span class="n">ground</span><span class="p">(</span><span class="n">clauses</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
<span class="gp">    </span>            <span class="k">try</span><span class="p">:</span>
<span class="gp">    </span>                <span class="nb">next</span><span class="p">(</span><span class="n">search</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">glob</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">    </span>            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
<span class="gp">    </span>                <span class="n">env_head</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
<span class="gp">    </span>                <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">search</span><span class="p">(</span><span class="n">clauses</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">env_head</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">    </span>                    <span class="k">yield</span> <span class="n">result</span>
<span class="gp">    </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>            <span class="k">for</span> <span class="n">fact</span> <span class="ow">in</span> <span class="n">facts</span><span class="p">:</span>
<span class="gp">    </span>                <span class="n">fact</span> <span class="o">=</span> <span class="n">rename_variables</span><span class="p">(</span><span class="n">fact</span><span class="p">,</span> <span class="n">get_unique_id</span><span class="p">())</span>
<span class="gp">    </span>                <span class="n">env_head</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
<span class="gp">    </span>                <span class="k">if</span> <span class="n">unify</span><span class="p">(</span><span class="n">fact</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">clauses</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">env_head</span><span class="p">):</span>
<span class="gp">    </span>                    <span class="k">for</span> <span class="n">env_rule</span> <span class="ow">in</span> <span class="n">search</span><span class="p">(</span><span class="n">fact</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">env_head</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">    </span>                        <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">search</span><span class="p">(</span><span class="n">clauses</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">env_rule</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">    </span>                            <span class="k">yield</span> <span class="n">result</span>
</pre></div>

<p>The search to satisfy all clauses simultaneously begins with the first clause.
In the special case where our first clause is negated, rather than trying to
unify the first clause of the query with a fact, we check that there is no such
unification possible through a recursive call to <tt class="docutils literal">search</tt>. If this recursive
call yields nothing, we continue the search process with the rest of our
clauses. If unification is possible, we fail immediately.</p>
<p>If our first clause is not negated, then for each fact in the database,
<tt class="docutils literal">search</tt> attempts to unify the first clause of the fact with the first clause
of the query. Unification is performed in a new environment <tt class="docutils literal">env_head</tt>. As a
side effect of unification, variables are bound to values in <tt class="docutils literal">env_head</tt>.</p>
<p>If unification is successful, then the clause matches the conclusion of the
current rule.  The following <tt class="docutils literal">for</tt> statement attempts to establish the
hypotheses of the rule, so that the conclusion can be established. It is here
that the hypotheses of a recursive rule would be passed recursively to
<tt class="docutils literal">search</tt> in order to be established.</p>
<p>Finally, for every successful search of <tt class="docutils literal">fact.second</tt>, the resulting
environment is bound to <tt class="docutils literal">env_rule</tt>. Given these bindings of values to
variables, the final <tt class="docutils literal">for</tt> statement searches to establish the rest of the
clauses in the initial query. Any successful result is returned via the inner
<tt class="docutils literal">yield</tt> statement.</p>
<p><strong>Unique names.</strong> Unification assumes that no variable is shared among both
<tt class="docutils literal">e</tt> and <tt class="docutils literal">f</tt>.  However, we often reuse variable names in the facts and
queries of the <tt class="docutils literal">logic</tt> language. We would not like to confuse an <tt class="docutils literal"><span class="pre">?x</span></tt> in
one fact with an <tt class="docutils literal"><span class="pre">?x</span></tt> in another; these variables are unrelated.  To ensure
that names are not confused, before a fact is passed into unify, its
variable names are replaced by unique names using <tt class="docutils literal">rename_variables</tt> by
appending a unique integer for the fact.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rename_variables</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">    </span>    <span class="sd">"""Rename all variables in EXPR with an identifier N."""</span>
<span class="gp">    </span>    <span class="k">if</span> <span class="n">isvar</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">expr</span> <span class="o">+</span> <span class="s1">'_'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">    </span>    <span class="k">elif</span> <span class="n">scheme_pairp</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">Pair</span><span class="p">(</span><span class="n">rename_variables</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
<span class="gp">    </span>                    <span class="n">rename_variables</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">second</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
<span class="gp">    </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">    </span>        <span class="k">return</span> <span class="n">expr</span>
</pre></div>

<p>The remaining details, including the user interface to the <tt class="docutils literal">logic</tt> language
and the definition of various helper functions, appears in the <a class="reference external" href="http://composingprograms.com/examples/logic/logic.py.html">logic</a>
example.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/46-distributed-computing.html">
  		4.6 Distributed Computing
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="distributed-computing">
<h2>4.6   Distributed Computing</h2>
<p>Large-scale data processing applications often coordinate effort among multiple
computers.  A distributed computing application is one in which multiple
interconnected but independent computers coordinate to perform a joint
computation.</p>
<p>Different computers are independent in the sense that they do not directly
share memory. Instead, they communicate with each other using <em>messages</em>,
information transferred from one computer to another over a network.</p>
<div class="section" id="messages">
<h3>4.6.1   Messages</h3>
<p>Messages sent between computers are sequences of bytes. The purpose of a
message varies; messages can request data, send data, or instruct another
computer to evaluate a procedure call. In all cases, the sending computer must
encode information in a way that the receiving computer can decode and
correctly interpret. To do so, computers adopt a message protocol that endows
meaning to sequences of bytes.</p>
<p>A <em>message protocol</em> is a set of rules for encoding and interpreting messages.
Both the sending and receiving computers must agree on the semantics of a
message to enable successful communication.  Many message protocols specify
that a message conform to a particular format in which certain bits at fixed
positions indicate fixed conditions. Others use special bytes or byte sequences
to delimit parts of the message, much as punctuation delimits sub-expressions
in the syntax of a programming language.</p>
<p>Message protocols are not particular programs or software libraries.  Instead,
they are rules that can be applied by a variety of programs, even written in
different programming languages.  As a result, computers with vastly different
software systems can participate in the same distributed system, simply by
conforming to the message protocols that govern the system.</p>
<p><strong>The TCP/IP Protocols</strong>. On the Internet, messages are transferred from one
machine to another using the <a class="reference external" href="http://en.wikipedia.org/wiki/Internet_Protocol">Internet Protocol</a> (IP), which specifies how to
transfer <em>packets</em> of data among different networks to allow global Internet
communication. IP was designed under the assumption that networks are
inherently unreliable at any point and dynamic in structure. Moreover, it does
not assume that any central tracking or monitoring of communication exists.
Each packet contains a header containing the destination IP address, along with
other information. All packets are forwarded throughout the network toward the
destination using simple routing rules on a best-effort basis.</p>
<p>This design imposes constraints on communication.  Packets transferred using
modern IP implementations (IPv4 and IPv6) have a maximum size of 65,535 bytes.
Larger data values must be split among multiple packets.  The IP does not
guarantee that packets will be received in the same order that they were sent.
Some packets may be lost, and some packets may be transmitted multiple times.</p>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol</a> is an
abstraction defined in terms of the IP that provides reliable, ordered
transmission of arbitrarily large byte streams. The protocol provides this
guarantee by correctly ordering packets transferred by the IP, removing
duplicates, and requesting retransmission of lost packets. This improved
reliability comes at the expense of latency, the time required to send a
message from one point to another.</p>
<p>The TCP breaks a stream of data into <em>TCP segments</em>, each of which includes a
portion of the data preceded by a header that contains sequence and state
information to support reliable, ordered transmission of data. Some TCP
segments do not include data at all, but instead establish or terminate a
connection between two computers.</p>
<p>Establishing a connection between two computers <tt class="docutils literal">A</tt> and <tt class="docutils literal">B</tt> proceeds in
three steps:</p>
<ol class="arabic simple">
<li>
<tt class="docutils literal">A</tt> sends a request to a <em>port</em> of <tt class="docutils literal">B</tt> to establish a TCP connection,
providing a <em>port number</em> to which to send the response.</li>
<li>
<tt class="docutils literal">B</tt> sends a response to the port specified by <tt class="docutils literal">A</tt> and waits for its
response to be acknowledged.</li>
<li>
<tt class="docutils literal">A</tt> sends an acknowledgment response, verifying that data can be
transferred in both directions.</li>
</ol>
<p>After this three-step "handshake", the TCP connection is established, and <tt class="docutils literal">A</tt>
and <tt class="docutils literal">B</tt> can send data to each other.  Terminating a TCP connection proceeds
as a sequence of steps in which both the client and server request and
acknowledge the end of the connection.</p>
</div>
<div class="section" id="client-server-architecture">
<h3>4.6.2   Client/Server Architecture</h3>
<p>The client/server architecture is a way to dispense a service from a central
source. A <em>server</em> provides a service and multiple <em>clients</em> communicate with
the server to consume that service. In this architecture, clients and servers
have different roles. The server's role is to respond to service requests from
clients, while a client's role is to issue requests and make use of the
server's response in order to perform some task. The diagram below illustrates
the architecture.</p>
<div class="figure">
<img alt="" src="../img/clientserver.png">
</div>
<p>The most influential use of the model is the modern World Wide Web. When a web
browser displays the contents of a web page, several programs running on
independent computers interact using the client/server architecture. This
section describes the process of requesting a web page in order to illustrate
central ideas in client/server distributed systems.</p>
<p><strong>Roles</strong>. The web browser application on a Web user's computer has the role of
the client when requesting a web page. When requesting the content from a
domain name on the Internet, such as www.nytimes.com, it must communicate
with at least two different servers.</p>
<p>The client first requests the Internet Protocol (IP) address of the computer
located at that name from a Domain Name Server (DNS). A DNS provides the
service of mapping domain names to IP addresses, which are numerical
identifiers of machines on the Internet.  Python can make such a request
directly using the <tt class="docutils literal">socket</tt> module.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">socket</span> <span class="k">import</span> <span class="n">gethostbyname</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gethostbyname</span><span class="p">(</span><span class="s1">'www.nytimes.com'</span><span class="p">)</span>
<span class="go">'170.149.172.130'</span>
</pre></div>

<p>The client then requests the contents of the web page from the web server
located at that IP address. The response in this case is an <a class="reference external" href="http://en.wikipedia.org/wiki/HTML">HTML</a> document that contains headlines and
article excerpts of the day's news, as well as expressions that indicate how
the web browser client should lay out that contents on the user's screen.
Python can make the two requests required to retrieve this content using the
<tt class="docutils literal">urllib.request</tt> module.</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.request</span> <span class="k">import</span> <span class="n">urlopen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="s1">'http://www.nytimes.com'</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="p">[:</span><span class="mi">15</span><span class="p">]</span>
<span class="go">b'&lt;!DOCTYPE html&gt;'</span>
</pre></div>

<p>Upon receiving this response, the browser issues additional requests for
images, videos, and other auxiliary components of the page.  These requests are
initiated because the original HTML document contains addresses of additional
content and a description of how they embed into the page.</p>
<p><strong>An HTTP Request</strong>. The Hypertext Transfer Protocol (HTTP) is a protocol
implemented using TCP that governs communication for the World Wide Web (WWW).
It assumes a client/server architecture between a web browser and a web server.
HTTP specifies the format of messages exchanged between browsers and servers.
All web browsers use the HTTP format to request pages from a web server, and
all web servers use the HTTP format to send back their responses.</p>
<p>HTTP requests have several types, the most common of which is a <tt class="docutils literal">GET</tt> request
for a specific web page.  A <tt class="docutils literal">GET</tt> request specifies a location.  For
instance, typing the address <tt class="docutils literal"><span class="pre">http://en.wikipedia.org/wiki/UC_Berkeley</span></tt> into
a web browser issues an HTTP <tt class="docutils literal">GET</tt> request to port 80 of the web server
at <tt class="docutils literal">en.wikipedia.org</tt> for the contents at location <tt class="docutils literal">/wiki/UC_Berkeley</tt>.</p>
<p>The server sends back an HTTP response:</p>
<pre class="literal-block">
HTTP/1.1 200 OK
Date: Mon, 23 May 2011 22:38:34 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
Last-Modified: Wed, 08 Jan 2011 23:11:55 GMT
Content-Type: text/html; charset=UTF-8

... web page content ...
</pre>
<p>On the first line, the text <tt class="docutils literal">200 OK</tt>  indicates that there were no errors in
responding to the request.  The subsequent lines of the header give information
about the server, the date, and the type of content being sent back.</p>
<p>If you have typed in a wrong web address, or clicked on a broken link, you may
have seen a message such as this error:</p>
<pre class="literal-block">
404 Error File Not Found
</pre>
<p>It means that the server sent back an HTTP header that started:</p>
<pre class="literal-block">
HTTP/1.1 404 Not Found
</pre>
<p>The numbers 200 and 404 are HTTP response codes.  A fixed set of
response codes is a common feature of a message protocol.  Designers of
protocols attempt to anticipate common messages that will be sent via the
protocol and assign fixed codes to reduce transmission size and establish a
common message semantics.  In the HTTP protocol, the 200 response code
indicates success, while 404 indicates an error that a resource was not
found.  A variety of other <a class="reference external" href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">response codes</a> exist in the HTTP
1.1 standard as well.</p>
<p><strong>Modularity</strong>. The concepts of <em>client</em> and <em>server</em> are powerful
abstractions. A server provides a service, possibly to multiple clients
simultaneously, and a client consumes that service. The clients do not need to
know the details of how the service is provided, or how the data they are
receiving is stored or calculated, and the server does not need to know how its
responses are going to be used.</p>
<p>On the web, we think of clients and servers as being on different machines, but
even systems on a single machine can have client/server architectures. For
example, signals from input devices on a computer need to be generally
available to programs running on the computer. The programs are clients,
consuming mouse and keyboard input data. The operating system's device drivers
are the servers, taking in physical signals and serving them up as usable
input. In addition, the central processing unit (CPU) and the specialized
graphical processing unit (GPU) often participate in a client/server
architecture with the CPU as the client and the GPU as a server of images.</p>
<p>A drawback of client/server systems is that the server is a single point of
failure. It is the only component with the ability to dispense the service.
There can be any number of clients, which are interchangeable and can come and
go as necessary.</p>
<p>Another drawback of client-server systems is that computing resources become
scarce if there are too many clients. Clients increase the demand on the system
without contributing any computing resources.</p>
</div>
<div class="section" id="peer-to-peer-systems">
<h3>4.6.3   Peer-to-Peer Systems</h3>
<p>The client/server model is appropriate for service-oriented situations.
However, there are other computational goals for which a more equal division of
labor is a better choice. The term <em>peer-to-peer</em> is used to describe
distributed systems in which labor is divided among all the components of the
system. All the computers send and receive data, and they all contribute some
processing power and memory. As a distributed system increases in size, its
capacity of computational resources increases. In a peer-to-peer system, all
components of the system contribute some processing power and memory to a
distributed computation.</p>
<p>Division of labor among all participants is the identifying characteristic of
a peer-to-peer system. This means that peers need to be able to communicate
with each other reliably. In order to make sure that messages reach their
intended destinations, peer-to-peer systems need to have an organized network
structure. The components in these systems cooperate to maintain enough
information about the locations of other components to send messages to
intended destinations.</p>
<p>In some peer-to-peer systems, the job of maintaining the health of the network
is taken on by a set of specialized components. Such systems are not pure
peer-to-peer systems, because they have different types of components that
serve different functions. The components that support a peer-to-peer network
act like scaffolding: they help the network stay connected, they maintain
information about the locations of different computers, and they help newcomers
take their place within their neighborhood.</p>
<p>The most common applications of peer-to-peer systems are data transfer and data
storage. For data transfer, each computer in the system contributes to send
data over the network. If the destination computer is in a particular
computer's neighborhood, that computer helps send data along. For data storage,
the data set may be too large to fit on any single computer, or too valuable to
store on just a single computer. Each computer stores a small portion of the
data, and there may be multiple copies of the same data spread over different
computers. When a computer fails, the data that was on it can be restored from
other copies and put back when a replacement arrives.</p>
<p>Skype, the voice- and video-chat service, is an example of a data transfer
application with a peer-to-peer architecture. When two people on different
computers are having a Skype conversation, their communications are transmitted
through a peer-to-peer network.  This network is composed of other computers
running the Skype application. Each computer knows the location of a few other
computers in its neighborhood. A computer helps send a packet to its
destination by passing it on a neighbor, which passes it on to some other
neighbor, and so on, until the packet reaches its intended destination. Skype
is not a pure peer-to-peer system. A scaffolding network of <em>supernodes</em> is
responsible for logging-in and logging-out users, maintaining information about
the locations of their computers, and modifying the network structure when
users enter and exit.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/47-distributed-data-processing.html">
  		4.7 Distributed Data Processing
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="distributed-data-processing">
<h2>4.7   Distributed Data Processing</h2>
<p>Distributed systems are often used to collect, access, and manipulate large data
sets. For example, the database systems described earlier in the chapter can
operate over datasets that are stored across multiple machines. No single
machine may contain the data necessary to respond to a query, and so
communication is required to service requests.</p>
<p>This section investigates a typical big data processing scenario in which a
data set too large to be processed by a single machine is instead distributed
among many machines, each of which process a portion of the dataset. The result
of processing must often be aggregated across machines, so that results from
one machine's computation can be combined with others. To coordinate this
distributed data processing, we will discuss a programming framework called
<a class="reference external" href="http://en.wikipedia.org/wiki/MapReduce">MapReduce</a>.</p>
<p>Creating a distributed data processing application with MapReduce combines
many of the ideas presented throughout this text. An application is expressed
in terms of pure functions that are used to <em>map</em> over a large dataset and then
to <em>reduce</em> the mapped sequences of values into a final result.</p>
<p>Familiar concepts from functional programming are used to maximal advantage in
a MapReduce program.  MapReduce requires that the functions used to map and
reduce the data be pure functions.  In general, a program expressed only in
terms of pure functions has considerable flexibility in how it is executed.
Sub-expressions can be computed in arbitrary order and in parallel without
affecting the final result.  A MapReduce application evaluates many pure
functions in parallel, reordering computations to be executed efficiently in a
distributed system.</p>
<p>The principal advantage of MapReduce is that it enforces a separation of
concerns between two parts of a distributed data processing application:</p>
<ol class="arabic simple">
<li>The map and reduce functions that process data and combine results.</li>
<li>The communication and coordination between machines.</li>
</ol>
<p>The coordination mechanism handles many issues that arise in distributed
computing, such as machine failures, network failures, and progress monitoring.
While managing these issues introduces some complexity in a MapReduce
application, none of that complexity is exposed to the application developer.
Instead, building a MapReduce application only requires specifying the
map and reduce functions in (1) above; the challenges of distributed
computation are hidden via abstraction.</p>
<div class="section" id="id1">
<h3>4.7.1   MapReduce</h3>
<p>The MapReduce framework assumes as input a large, unordered stream of
input values of an arbitrary type. For instance, each input may be a line of
text in some vast corpus. Computation proceeds in three steps.</p>
<ol class="arabic simple">
<li>A map function is applied to each input, which outputs zero or more
intermediate key-value pairs of an arbitrary type.</li>
<li>All intermediate key-value pairs are grouped by key, so that pairs with the
same key can be reduced together.</li>
<li>A reduce function combines the values for a given key <tt class="docutils literal">k</tt>; it outputs zero
or more values, which are each associated with <tt class="docutils literal">k</tt> in the final output.</li>
</ol>
<p>To perform this computation, the MapReduce framework creates tasks (perhaps on
different machines) that perform various roles in the computation.  A <em>map
task</em> applies the map function to some subset of the input data and outputs
intermediate key-value pairs.  A <em>reduce</em> task sorts and groups key-value pairs
by key, then applies the reduce function to the values for each key.
All communication between map and reduce tasks is handled by the framework, as
is the task of grouping intermediate key-value pairs by key.</p>
<p>In order to utilize multiple machines in a MapReduce application, multiple
mappers run in parallel in a <em>map phase</em>, and multiple reducers run in parallel
in a <em>reduce phase</em>. In between these phases, the <em>sort phase</em> groups together
key-value pairs by sorting them, so that all key-value pairs with the same key
are adjacent.</p>
<p>Consider the problem of counting the vowels in a corpus of text. We can solve
this problem using the MapReduce framework with an appropriate choice of map
and reduce functions.  The map function takes as input a line of text and
outputs key-value pairs in which the key is a vowel and the value is a count.
Zero counts are omitted from the output:</p>
<pre class="literal-block">
def count_vowels(line):
    """A map function that counts the vowels in a line."""
    for vowel in 'aeiou':
        count = line.count(vowel)
        if count &gt; 0:
            emit(vowel, count)
</pre>
<p>The reduce function is the built-in sum functions in Python, which takes as
input an iterator over values (all values for a given key) and returns their
sum.</p>
</div>
<div class="section" id="local-implementation">
<h3>4.7.2   Local Implementation</h3>
<p>To specify a MapReduce application, we require an implementation of the
MapReduce framework into which we can insert map and reduce functions. In the
following section, we will use the open-source <a class="reference external" href="http://en.wikipedia.org/wiki/Hadoop">Hadoop</a> implementation. In this
section, we develop a minimal implementation using built-in tools of the Unix
operating system.</p>
<p>The Unix operating system creates an abstraction barrier between user programs
and the underlying hardware of a computer.  It provides a mechanism for
programs to communicate with each other, in particular by allowing one program
to consume the output of another. In their seminal text on Unix programming,
Kernigham and Pike assert that, ""The power of a system comes more from the
relationships among programs than from the programs themselves."</p>
<p>A Python source file can be converted into a Unix program by adding a comment
to the first line indicating that the program should be executed using the
Python 3 interpreter. The input to a Unix program is an iterable object called
<em>standard input</em> and accessed as <tt class="docutils literal">sys.stdin</tt>. Iterating over this object
yields string-valued lines of text. The output of a Unix program is called
<em>standard output</em> and accessed as <tt class="docutils literal">sys.stdout</tt>. The built-in <tt class="docutils literal">print</tt>
function writes a line of text to standard output.  The following Unix program
writes each line of its input to its output, in reverse:</p>
<pre class="literal-block">
#!/usr/bin/env python3

import sys

for line in sys.stdin:
    print(line.strip('\n')[::-1])
</pre>
<p>If we save this program to a file called <tt class="docutils literal">rev.py</tt>, we can execute it as a
Unix program. First, we need to tell the operating system that we have created
an executable program:</p>
<pre class="literal-block">
$ chmod u+x rev.py
</pre>
<p>Next, we can pass input into this program.  Input to a program can come from
another program.  This effect is achieved using the <tt class="docutils literal">|</tt> symbol (called
"pipe") which channels the output of the program before the pipe into the
program after the pipe.  The program <tt class="docutils literal">nslookup</tt> outputs the host name of an
IP address (in this case for the New York Times):</p>
<pre class="literal-block">
$ nslookup 170.149.172.130 | ./rev.py
moc.semityn.www
</pre>
<p>The <tt class="docutils literal">cat</tt> program outputs the contents of files.  Thus, the <tt class="docutils literal">rev.py</tt>
program can be used to reverse the contents of the <tt class="docutils literal">rev.py</tt> file:</p>
<pre class="literal-block">
$ cat rev.py | ./rev.py
3nohtyp vne/nib/rsu/!#

sys tropmi

:nidts.sys ni enil rof
)]1-::[)'n\'(pirts.enil(tnirp
</pre>
<p>These tools are enough for us to implement a basic MapReduce framework.  This
version has only a single map task and single reduce task, which are both Unix
programs implemented in Python. We run an entire MapReduce application using
the following command:</p>
<pre class="literal-block">
$ cat input | ./mapper.py | sort | ./reducer.py
</pre>
<p>The <tt class="docutils literal">mapper.py</tt> and <tt class="docutils literal">reducer.py</tt> programs must implement the map function
and reduce function, along with some simple input and output behavior. For
instance, in order to implement the vowel counting application described above,
we would write the following <tt class="docutils literal">count_vowels_mapper.py</tt> program:</p>
<pre class="literal-block">
#!/usr/bin/env python3

import sys
from mr import emit

def count_vowels(line):
    """A map function that counts the vowels in a line."""
    for vowel in 'aeiou':
        count = line.count(vowel)
        if count &gt; 0:
            emit(vowel, count)

for line in sys.stdin:
    count_vowels(line)
</pre>
<p>In addition, we would write the following <tt class="docutils literal">sum_reducer.py</tt> program:</p>
<pre class="literal-block">
#!/usr/bin/env python3

import sys
from mr import values_by_key, emit

for key, value_iterator in values_by_key(sys.stdin):
    emit(key, sum(value_iterator))
</pre>
<p>The <a class="reference external" href="../examples/mapreduce/mr.py">mr module</a> is a companion
module to this text that provides the functions <tt class="docutils literal">emit</tt> to emit a key-value
pair and <tt class="docutils literal">group_values_by_key</tt> to group together values that have the same
key. This module also includes an interface to the Hadoop distributed
implementation of MapReduce.</p>
<p>Finally, assume that we have the following input file called <tt class="docutils literal">haiku.txt</tt>:</p>
<pre class="literal-block">
Google MapReduce
Is a Big Data framework
For batch processing
</pre>
<p>Local execution using Unix pipes gives us the count of each vowel in the
haiku:</p>
<pre class="literal-block">
$ cat haiku.txt | ./count_vowels_mapper.py | sort | ./sum_reducer.py
'a'   6
'e'   5
'i'   2
'o'   5
'u'   1
</pre>
</div>
<div class="section" id="distributed-implementation">
<h3>4.7.3   Distributed Implementation</h3>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Hadoop">Hadoop</a> is the name of an open-source implementation of the MapReduce framework
that executes MapReduce applications on a cluster of machines, distributing
input data and computation for efficient parallel processing. Its streaming
interface allows arbitrary Unix programs to define the map and reduce
functions. In fact, our <tt class="docutils literal">count_vowels_mapper.py</tt> and <tt class="docutils literal">sum_reducer.py</tt> can
be used directly with a Hadoop installation to compute vowel counts on large
text corpora.</p>
<p>Hadoop offers several advantages over our simplistic local MapReduce
implementation. The first is speed: map and reduce functions are applied in
parallel using different tasks on different machines running simultaneously.
The second is fault tolerance: when a task fails for any reason, its result can
be recomputed by another task in order to complete the overall computation.
The third is monitoring: the framework provides a user interface for tracking
the progress of a MapReduce application.</p>
<p>In order to run the vowel counting application using the provided
<tt class="docutils literal">mapreduce.py</tt> module, install Hadoop, change the assignment statement of
<tt class="docutils literal">HADOOP</tt> to the root of your local installation, copy a collection of text
files into the Hadoop distributed file system, and then run:</p>
<pre class="literal-block">
$ python3 mr.py run count_vowels_mapper.py sum_reducer.py [input] [output]
</pre>
<p>where <tt class="docutils literal">[input]</tt> and <tt class="docutils literal">[output]</tt> are directories in the Hadoop file system.</p>
<p>For more information on the Hadoop streaming interface and use of the system,
consult the <a class="reference external" href="http://hadoop.apache.org/docs/stable/streaming.html">Hadoop Streaming Documentation</a>.</p>
</div>
</div>
  <p><i>Continue</i>:
  	<a href="../pages/48-parallel-computing.html">
  		4.8 Parallel Computing
  	</a>
      </p>
</div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div><div class="inner-content">
  <div class="section" id="parallel-computing">
<h2>4.8   Parallel Computing</h2>
<p>From the 1970s through the mid-2000s, the speed of individual processor cores
grew at an exponential rate. Much of this increase in speed was accomplished by
increasing the <em>clock frequency</em>, the rate at which a processor performs basic
operations. In the mid-2000s, however, this exponential increase came to an
abrupt end, due to power and thermal constraints, and the speed of individual
processor cores has increased much more slowly since then. Instead, CPU
manufacturers began to place multiple cores in a single processor, enabling more
operations to be performed concurrently.</p>
<p>Parallelism is not a new concept. Large-scale parallel machines have been used
for decades, primarily for scientific computing and data analysis. Even in
personal computers with a single processor core, operating systems and
interpreters have provided the abstraction of concurrency. This is done through
<em>context switching</em>, or rapidly switching between different tasks without
waiting for them to complete. Thus, multiple programs can run on the same
machine concurrently, even if it only has a single processing core.</p>
<p>Given the current trend of increasing the number of processor cores, individual
applications must now take advantage of parallelism in order to run faster.
Within a single program, computation must be arranged so that as much work can
be done in parallel as possible. However, parallelism introduces new challenges
in writing correct code, particularly in the presence of shared, mutable state.</p>
<p>For problems that can be solved efficiently in the functional model, with no
shared mutable state, parallelism poses few problems. Pure functions provide
<em>referential transparency</em>, meaning that expressions can be replaced with their
values, and vice versa, without affecting the behavior of a program. This
enables expressions that do not depend on each other to be evaluated in
parallel. As discussed in the previous section, the MapReduce framework allows
functional programs to be specified and run in parallel with minimal programmer
effort.</p>
<p>Unfortunately, not all problems can be solved efficiently using functional
programming. The Berkeley View project has identified <a class="reference external" href="http://view.eecs.berkeley.edu/wiki/Dwarf_Mine">thirteen common
computational patterns</a> in
science and engineering, only one of which is MapReduce. The remaining patterns
require shared state.</p>
<p>In the remainder of this section, we will see how mutable shared state can
introduce bugs into parallel programs and a number of approaches to prevent such
bugs. We will examine these techniques in the context of two applications, a
web <a class="reference external" href="../examples/parallel/crawler.py.html">crawler</a> and a particle <a class="reference external" href="../examples/parallel/particle.py.html">simulator</a>.</p>
<div class="section" id="parallelism-in-python">
<h3>4.8.1   Parallelism in Python</h3>
<p>Before we dive deeper into the details of parallelism, let us first explore
Python's support for parallel computation. Python provides two means of
parallel execution: threading and multiprocessing.</p>
<p><strong>Threading</strong>. In <em>threading</em>, multiple "threads" of execution exist within a
single interpreter. Each thread executes code independently from the others,
though they share the same data. However, the CPython interpreter, the main
implementation of Python, only interprets code in one thread at a time,
switching between them in order to provide the illusion of parallelism. On
the other hand, operations external to the interpreter, such as writing to a
file or accessing the network, may run in parallel.</p>
<p>The <tt class="docutils literal">threading</tt> module contains classes that enable threads to be created
and synchronized. The following is a simple example of a multithreaded program:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">threading</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">thread_hello</span><span class="p">():</span>
<span class="gp">    </span>    <span class="n">other</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread_say_hello</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">())</span>
<span class="gp">    </span>    <span class="n">other</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">    </span>    <span class="n">thread_say_hello</span><span class="p">()</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">thread_say_hello</span><span class="p">():</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'hello from'</span><span class="p">,</span> <span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thread_hello</span><span class="p">()</span>
<span class="go">hello from Thread-1</span>
<span class="go">hello from MainThread</span>
</pre></div>

<p>The <tt class="docutils literal">Thread</tt> constructor creates a new thread. It requires a target function
that the new thread should run, as well as the arguments to that function.
Calling <tt class="docutils literal">start</tt> on a <tt class="docutils literal">Thread</tt> object marks it ready to run. The
<tt class="docutils literal">current_thread</tt> function returns the <tt class="docutils literal">Thread</tt> object associated with the
current thread of execution.</p>
<p>In this example, the prints can happen in any order, since we haven't
synchronized them in any way.</p>
<p><strong>Multiprocessing</strong>. Python also supports <em>multiprocessing</em>, which allows a
program to spawn multiple interpreters, or <em>processes</em>, each of which can run
code independently. These processes do not generally share data, so any shared
state must be communicated between processes. On the other hand, processes
execute in parallel according to the level of parallelism provided by the
underlying operating system and hardware. Thus, if the CPU has multiple
processor cores, Python processes can truly run concurrently.</p>
<p>The <tt class="docutils literal">multiprocessing</tt> module contains classes for creating and synchronizing
processes. The following is the hello example using processes:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">process_hello</span><span class="p">():</span>
<span class="gp">    </span>    <span class="n">other</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">process_say_hello</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">())</span>
<span class="gp">    </span>    <span class="n">other</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">    </span>    <span class="n">process_say_hello</span><span class="p">()</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">process_say_hello</span><span class="p">():</span>
<span class="gp">    </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">'hello from'</span><span class="p">,</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">process_hello</span><span class="p">()</span>
<span class="go">hello from MainProcess</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hello</span> <span class="kn">from</span> <span class="nn">Process</span><span class="o">-</span><span class="mi">1</span>
</pre></div>

<p>As this example demonstrates, many of the classes and functions in
<tt class="docutils literal">multiprocessing</tt> are analogous to those in <tt class="docutils literal">threading</tt>. This example also
demonstrates how lack of synchronization affects shared state, as the display
can be considered shared state. Here, the interpreter prompt from the
interactive process appears before the print output from the other process.</p>
</div>
<div class="section" id="the-problem-with-shared-state">
<h3>4.8.2   The Problem with Shared State</h3>
<p>To further illustrate the problem with shared state, let's look at a simple
example of a counter that is shared between two threads:</p>
<pre class="literal-block">
import threading
from time import sleep

counter = [0]

def increment():
    count = counter[0]
    sleep(0) # try to force a switch to the other thread
    counter[0] = count + 1

other = threading.Thread(target=increment, args=())
other.start()
increment()
print('count is now: ', counter[0])
</pre>
<p>In this program, two threads attempt to increment the same counter. The CPython
interpreter can switch between threads at almost any time. Only the most basic
operations are <em>atomic</em>, meaning that they appear to occur instantly, with no
switch possible during their evaluation or execution. Incrementing a counter
requires multiple basic operations: read the old value, add one to it, and write
the new value. The interpreter can switch threads between any of these
operations.</p>
<p>In order to show what happens when the interpreter switches threads at the wrong
time, we have attempted to force a switch by sleeping for 0 seconds. When this
code is run, the interpreter often does switch threads at the <tt class="docutils literal">sleep</tt> call.
This can result in the following sequence of operations:</p>
<pre class="literal-block">
Thread 0                    Thread 1
read counter[0]: 0
                            read counter[0]: 0
calculate 0 + 1: 1
write 1 -&gt; counter[0]
                            calculate 0 + 1: 1
                            write 1 -&gt; counter[0]
</pre>
<p>The end result is that the counter has a value of 1, even though it was
incremented twice! Worse, the interpreter may only switch at the wrong time very
rarely, making this difficult to debug. Even with the <tt class="docutils literal">sleep</tt> call, this
program sometimes produces a correct count of 2 and sometimes an incorrect count
of 1.</p>
<p>This problem arises only in the presence of shared data that may be mutated by
one thread while another thread accesses it. Such a conflict is called a <em>race
condition</em>, and it is an example of a bug that only exists in the parallel
world.</p>
<p>In order to avoid race conditions, shared data that may be mutated and accessed
by multiple threads must be protected against concurrent access. For example, if
we can ensure that thread 1 only accesses the counter after thread 0 finishes
accessing it, or vice versa, we can guarantee that the right result is computed.
We say that shared data is <em>synchronized</em> if it is protected from concurrent
access. In the next few subsections, we will see multiple mechanisms providing
synchronization.</p>
</div>
<div class="section" id="when-no-synchronization-is-necessary">
<h3>4.8.3   When No Synchronization is Necessary</h3>
<p>In some cases, access to shared data need not be synchronized, if concurrent
access cannot result in incorrect behavior. The simplest example is read-only
data. Since such data is never mutated, all threads will always read the same
values regardless when they access the data.</p>
<p>In rare cases, shared data that is mutated may not require synchronization.
However, understanding when this is the case requires a deep knowledge of how
the interpreter and underlying software and hardware work. Consider the
following example:</p>
<pre class="literal-block">
items = []
flag = []

def consume():
    while not flag:
        pass
    print('items is', items)

def produce():
    consumer = threading.Thread(target=consume, args=())
    consumer.start()
    for i in range(10):
        items.append(i)
    flag.append('go')

produce()
</pre>
<p>Here, the producer thread adds items to <tt class="docutils literal">items</tt>, while the consumer waits
until <tt class="docutils literal">flag</tt> is non-empty. When the producer finishes adding items, it adds an
element to <tt class="docutils literal">flag</tt>, allowing the consumer to proceed.</p>
<p>In most Python implementations, this example will work correctly. However, a
common optimization in other compilers and interpreters, and even the hardware
itself, is to reorder operations within a single thread that do not depend on
each other for data. In such a system, the statement <tt class="docutils literal"><span class="pre">flag.append('go')</span></tt> may
be moved before the loop, since neither depends on the other for data. In
general, you should avoid code like this unless you are certain that the
underlying system won't reorder the relevant operations.</p>
</div>
<div class="section" id="synchronized-data-structures">
<h3>4.8.4   Synchronized Data Structures</h3>
<p>The simplest means of synchronizing shared data is to use a data structure
that provides synchronized operations. The <tt class="docutils literal">queue</tt> module contains a
<tt class="docutils literal">Queue</tt> class that provides synchronized first in, first out access to
data. The <tt class="docutils literal">put</tt> method adds an item to the <tt class="docutils literal">Queue</tt>, and the <tt class="docutils literal">get</tt>
method retrieves an item. The class itself ensures that these methods are
synchronized, so items are not lost no matter how thread operations are
interleaved. Here is a producer/consumer example that uses a <tt class="docutils literal">Queue</tt>:</p>
<pre class="literal-block">
from queue import Queue

queue = Queue()

def synchronized_consume():
    while True:
        print('got an item:', queue.get())
        queue.task_done()

def synchronized_produce():
    consumer = threading.Thread(target=synchronized_consume, args=())
    consumer.daemon = True
    consumer.start()
    for i in range(10):
        queue.put(i)
    queue.join()

synchronized_produce()
</pre>
<p>There are a few changes to this code, in addition to the <tt class="docutils literal">Queue</tt> and <tt class="docutils literal">get</tt>
and <tt class="docutils literal">put</tt> calls. We have marked the consumer thread as a <em>daemon</em>, which means
that the program will not wait for that thread to complete before exiting. This
allows us to use an infinite loop in the consumer. However, we do need to ensure
that the main thread exits, but only after all items have been consumed from the
<tt class="docutils literal">Queue</tt>. The consumer calls the <tt class="docutils literal">task_done</tt> method to inform the <tt class="docutils literal">Queue</tt>
that it is done processing an item, and the main thread calls the <tt class="docutils literal">join</tt>
method, which waits until all items have been processed, ensuring that the
program exits only after that is the case.</p>
<p>A more complex example that makes use of a <tt class="docutils literal">Queue</tt> is a parallel web
<a class="reference external" href="../examples/parallel/crawler.py.html">crawler</a> that searches for dead links on a website. This crawler follows all
links that are hosted by the same site, so it must process a number of URLs,
continually adding new ones to a <tt class="docutils literal">Queue</tt> and removing URLs for processing.
By using a synchronized <tt class="docutils literal">Queue</tt>, multiple threads can safely add to and
remove from the data structure concurrently.</p>
</div>
<div class="section" id="locks">
<h3>4.8.5   Locks</h3>
<p>When a synchronized version of a particular data structure is not available, we
have to provide our own synchronization. A <em>lock</em> is a basic mechanism to do so.
It can be <em>acquired</em> by at most one thread, after which no other thread may
acquire it until it is <em>released</em> by the thread that previously acquired it.</p>
<p>In Python, the <tt class="docutils literal">threading</tt> module contains a <tt class="docutils literal">Lock</tt> class to provide
locking. A <tt class="docutils literal">Lock</tt> has <tt class="docutils literal">acquire</tt> and <tt class="docutils literal">release</tt> methods to acquire and
release the lock, and the class guarantees that only one thread at a time can
acquire it. All other threads that attempt to acquire a lock while it is already
being held are forced to wait until it is released.</p>
<p>For a lock to protect a particular set of data, all the threads need to be
programmed to follow a rule: no thread will access any of the shared data unless
it owns that particular lock. In effect, all the threads need to "wrap" their
manipulation of the shared data in <tt class="docutils literal">acquire</tt> and <tt class="docutils literal">release</tt> calls for that
lock.</p>
<p>In the parallel web <a class="reference external" href="../examples/parallel/crawler.py.html">crawler</a>, a set is used to keep track of all URLs that
have been encountered by any thread, so as to avoid processing a particular URL
more than once (and potentially getting stuck in a cycle). However, Python does
not provide a synchronized set, so we must use a lock to protect access to a
normal set:</p>
<pre class="literal-block">
seen = set()
seen_lock = threading.Lock()

def already_seen(item):
    seen_lock.acquire()
    result = True
    if item not in seen:
        seen.add(item)
        result = False
    seen_lock.release()
    return result
</pre>
<p>A lock is necessary here, in order to prevent another thread from adding the URL
to the set between this thread checking if it is in the set and adding it to the
set. Furthermore, adding to a set is not atomic, so concurrent attempts to add
to a set may corrupt its internal data.</p>
<p>In this code, we had to be careful not to return until after we released the
lock. In general, we have to ensure that we release a lock when we no longer
need it. This can be very error-prone, particularly in the presence of
exceptions, so Python provides a <tt class="docutils literal">with</tt> compound statement that handles
acquiring and releasing a lock for us:</p>
<pre class="literal-block">
def already_seen(item):
    with seen_lock:
        if item not in seen:
            seen.add(item)
            return False
        return True
</pre>
<p>The <tt class="docutils literal">with</tt> statement ensures that <tt class="docutils literal">seen_lock</tt> is acquired before its suite
is executed and that it is released when the suite is exited for any reason.
(The <tt class="docutils literal">with</tt> statement can actually be used for operations other than locking,
though we won't cover alternative uses here.)</p>
<p>Operations that must be synchronized with each other must use the same lock.
However, two disjoint sets of operations that must be synchronized only with
operations in the same set should use two different lock objects to avoid
over-synchronization.</p>
</div>
<div class="section" id="barriers">
<h3>4.8.6   Barriers</h3>
<p>Another way to avoid conflicting access to shared data is to divide a program
into phases, ensuring that shared data is mutated in a phase in which no other
thread accesses it. A <em>barrier</em> divides a program into phases by requiring
all threads to reach it before any of them can proceed. Code that is executed
after a barrier cannot be concurrent with code executed before the barrier.</p>
<p>In Python, the <tt class="docutils literal">threading</tt> module provides a barrier in the form of the
the <tt class="docutils literal">wait</tt> method of a <tt class="docutils literal">Barrier</tt> instance:</p>
<pre class="literal-block">
counters = [0, 0]
barrier = threading.Barrier(2)

def count(thread_num, steps):
    for i in range(steps):
        other = counters[1 - thread_num]
        barrier.wait() # wait for reads to complete
        counters[thread_num] = other + 1
        barrier.wait() # wait for writes to complete

def threaded_count(steps):
    other = threading.Thread(target=count, args=(1, steps))
    other.start()
    count(0, steps)
    print('counters:', counters)

threaded_count(10)
</pre>
<p>In this example, reading and writing to shared data take place in different
phases, separated by barriers. The writes occur in the same phase, but they are
disjoint; this disjointness is necessary to avoid concurrent writes to the same
data in the same phase. Since this code is properly synchronized, both counters
will always be 10 at the end.</p>
<p>The multithreaded particle <a class="reference external" href="../examples/parallel/particle.py.html">simulator</a> uses a barrier in a similar fashion to
synchronize access to shared data. In the simulation, each thread owns a number
of particles, all of which interact with each other over the course of many
discrete timesteps. A particle has a position, velocity, and acceleration, and a
new acceleration is computed in each timestep based on the positions of the
other particles. The velocity of the particle must be updated accordingly, and
its position according to its velocity.</p>
<p>As with the simple example above, there is a read phase, in which all particles'
positions are read by all threads. Each thread updates its own particles'
acceleration in this phase, but since these are disjoint writes, they need not
be synchronized. In the write phase, each thread updates its own particles'
velocities and positions. Again, these are disjoint writes, and they are
protected from the read phase by barriers.</p>
</div>
<div class="section" id="message-passing">
<h3>4.8.7   Message Passing</h3>
<p>A final mechanism to avoid improper mutation of shared data is to entirely avoid
concurrent access to the same data. In Python, using multiprocessing rather than
threading naturally results in this, since processes run in separate
interpreters with their own data. Any state required by multiple processes can
be communicated by passing messages between processes.</p>
<p>The <tt class="docutils literal">Pipe</tt> class in the <tt class="docutils literal">multiprocessing</tt> module provides a communication
channel between processes. By default, it is duplex, meaning a two-way channel,
though passing in the argument <tt class="docutils literal">False</tt> results in a one-way channel. The
<tt class="docutils literal">send</tt> method sends an object over the channel, while the <tt class="docutils literal">recv</tt> method
receives an object. The latter is <em>blocking</em>, meaning that a process that calls
<tt class="docutils literal">recv</tt> will wait until an object is received.</p>
<p>The following is a producer/consumer example using processes and pipes:</p>
<pre class="literal-block">
def process_consume(in_pipe):
    while True:
        item = in_pipe.recv()
        if item is None:
            return
        print('got an item:', item)

def process_produce():
    pipe = multiprocessing.Pipe(False)
    consumer = multiprocessing.Process(target=process_consume, args=(pipe[0],))
    consumer.start()
    for i in range(10):
        pipe[1].send(i)
    pipe[1].send(None) # done signal

process_produce()
</pre>
<p>In this example, we use a <tt class="docutils literal">None</tt> message to signal the end of communication.
We also passed in one end of the pipe as an argument to the target function when
creating the consumer process. This is necessary, since state must be explicitly
shared between processes.</p>
<p>The multiprocess version of the particle <a class="reference external" href="../examples/parallel/particle.py.html">simulator</a> uses pipes to communicate
particle positions between processes in each timestep. In fact, it uses pipes to
set up an entire circular pipeline between processes, in order to minimize
communication. Each process injects its own particles' positions into its
pipeline stage, which eventually go through a full rotation of the pipeline. At
each step of the rotation, a process applies forces from the positions that are
currently in its own pipeline stage on to its own particles, so that after a
full rotation, all forces have been applied to its particles.</p>
<p>The <tt class="docutils literal">multiprocessing</tt> module provides other synchronization mechanisms for
processes, including synchronized queues, locks, and as of Python 3.3, barriers.
For example, a lock or a barrier can be used to synchronize printing to the
screen, avoiding the improper display output we saw previously.</p>
</div>
<div class="section" id="synchronization-pitfalls">
<h3>4.8.8   Synchronization Pitfalls</h3>
<p>While synchronization methods are effective for protecting shared state, they
can also be used incorrectly, failing to accomplish the proper synchronization,
over-synchronizing, or causing the program to hang as a result of deadlock.</p>
<p><strong>Under-synchronization</strong>. A common pitfall in parallel computing is to neglect
to properly synchronize shared accesses. In the set example, we need to
synchronize the membership check and insertion together, so that another thread
cannot perform an insertion in between these two operations. Failing to
synchronize the two operations together is erroneous, even if they are
separately synchronized.</p>
<p><strong>Over-synchronization</strong>. Another common error is to over-synchronize a program,
so that non-conflicting operations cannot occur concurrently. As a trivial
example, we can avoid all conflicting access to shared data by acquiring a
master lock when a thread starts and only releasing it when a thread completes.
This serializes our entire code, so that nothing runs in parallel. In some
cases, this can even cause our program to hang indefinitely. For example,
consider a consumer/producer program in which the consumer obtains the lock and
never releases it. This prevents the producer from producing any items, which in
turn prevents the consumer from doing anything since it has nothing to consume.</p>
<p>While this example is trivial, in practice, programmers often over-synchronize
their code to some degree, preventing their code from taking complete advantage
of the available parallelism.</p>
<p><strong>Deadlock</strong>. Because they cause threads or processes to wait on each other,
synchronization mechanisms are vulnerable to <em>deadlock</em>, a situation in which
two or more threads or processes are stuck, waiting for each other to finish. We
have just seen how neglecting to release a lock can cause a thread to get stuck
indefinitely. But even if threads or processes do properly release locks,
programs can still reach deadlock.</p>
<p>The source of deadlock is a <em>circular wait</em>, illustrated below with processes.
No process can continue because it is waiting for other processes that are
waiting for it to complete.</p>
<div class="figure">
<img alt="" src="../img/deadlock.png">
</div>
<p>As an example, we will set up a deadlock with two processes. Suppose they share
a duplex pipe and attempt to communicate with each other as follows:</p>
<pre class="literal-block">
def deadlock(in_pipe, out_pipe):
    item = in_pipe.recv()
    print('got an item:', item)
    out_pipe.send(item + 1)

def create_deadlock():
    pipe = multiprocessing.Pipe()
    other = multiprocessing.Process(target=deadlock, args=(pipe[0], pipe[1]))
    other.start()
    deadlock(pipe[1], pipe[0])

create_deadlock()
</pre>
<p>Both processes attempt to receive data first. Recall that the <tt class="docutils literal">recv</tt> method
blocks until an item is available. Since neither process has sent anything, both
will wait indefinitely for the other to send it data, resulting in deadlock.</p>
<p>Synchronization operations must be properly aligned to avoid deadlock. This may
require sending over a pipe before receiving, acquiring multiple locks in the
same order, and ensuring that all threads reach the right barrier at the right
time.</p>
</div>
<div class="section" id="conclusion">
<h3>4.8.9   Conclusion</h3>
<p>As we have seen, parallelism presents new challenges in writing correct and
efficient code. As the trend of increasing parallelism at the hardware level
will continue for the foreseeable future, parallel computation will become more
and more important in application programming. There is a very active body of
research on making parallelism easier and less error-prone for programmers. Our
discussion here serves only as a basic introduction to this crucial area of
computer science.</p>
</div>
</div>
      </div><div class="wrap">
    <footer id="contentinfo" class="body">
        Composing Programs by <a href="http://www.denero.org">John
        DeNero</a>, based on the textbook <a
        href="http://mitpress.mit.edu/sicp/">Structure and
        Interpretation of Computer Programs</a> by Harold Abelson and
        Gerald Jay Sussman, is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-sa/3.0/">Creative
        Commons Attribution-ShareAlike 3.0 Unported License</a>.
    </footer><!-- /#contentinfo -->
</div></body>
</html>